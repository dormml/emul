<<< dynamic linked list #1
brk := 0xa000;
_new = code(s:Int) {
    ret : Int;
    ret, brk = brk, (brk+((s+1)&~1));
};
new = [T] code( =>T^) {
    _new(sizeof(T)){T^};
};

List = [T] data {   // 10
    node : T;
    next : List^;
};

makeList = code () {
    head, prev : List<Int>^ = nil, nil;
    for x in 100 do {
        node := new<List<Int> >();
        node.node = x;
        if prev != nil then prev.next = node else head = node; // 20
        prev = node;
    };
    head;
};

main = code() {
    list := makeList();
    c : Int = 0;
    n := list; while n != nil do c, n = c+1, n.next;
    0xf000{Int^}^ = c;
};
===
call main
assert 0xf000 == 100
>>>

<<< dynamic linked list #2
brk := 0xa000;
_new = code(s:Int) {
    ret : Int;
    ret, brk = brk, (brk+((s+1)&~1));
};
new = code #macro (macro T) {
    _new(sizeof(T)){T^};
};

List = [T] data {   // 10
    node : T;
    next : List^;
};

makeList = code () {
    head, prev : List<Int>^ = nil, nil;
    for x in 100 do {
        node := new(typeof(head^));
        node.node = x;
        if prev != nil then prev.next = node else head = node; // 20
        prev = node;
    };
    head;
};

main = code() {
    list := makeList();
    c, s : Int = 0;
    n := list; while n != nil do c, n, s = c+1, n.next, s + n.node;
    0xf000{Int^}^ = c;
    0xf002{Int^}^ = s;
};
===
call main
assert 0xf000 == 100
assert 0xf002 == 4950
>>>

