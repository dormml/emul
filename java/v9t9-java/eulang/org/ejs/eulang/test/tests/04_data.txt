<<< dynamic linked list #1
brk := 0xa000;
_new = code(s:Int) {
    ret : Int;
    ret, brk = brk, (brk+((s+1)&~1));
};
new = [T] code( =>T^) {
    _new(sizeof(T)){T^};
};

List = [T] data {   // 10
    node : T;
    next : List^;
};

makeList = code () {
    head, prev : List<Int>^;
    for x in 100 do {
        node := new<List<Int>>();
        node.node = x;
        if prev then prev.next = node else head = node; // 20
        prev = node;
    };
    head;
};

main = code() {
    list := makeList();
    c : Int = 0;
    n := list; while n do c, n = c+1, n.next;
    0xf000{Int^}^ = c;
};
===
call main
assert 0xf000 == 100
>>>

<<< dynamic linked list #2
brk := 0xa000;
_new = code(s:Int) {
    ret : Int;
    ret, brk = brk, (brk+((s+1)&~1));
};
new = code #macro (T #macro) {
    _new(sizeof(T)){T^};
};

List = [T] data {   // 10
    node : T;
    next : List^;
};

makeList = code () {
    head, prev : List<Int>^ = nil, nil;
    for x in 100 do {
        node := new(typeof(head^));
        node.node = x;
        if prev then prev.next = node else head = node; // 20
        prev = node;
    };
    head;
};

main = code() {
    list := makeList();
    c, s : Int = 0;
    n := list; while n do c, n, s = c+1, n.next, s + n.node;
    0xf000{Int^}^ = c;
    0xf002{Int^}^ = s;
};
===
call main
assert 0xf000 == 100
assert 0xf002 == 4950
>>>

<<< method calls #1
Class = data {
   x,y:Int;
   somethingElse:Int;
   pt = code #this () { (x,y) };
};
foo = code() {
   x : Class;
   x.x, x.y = 123, 456;
   (a,b) := x.pt();
   a+b
};
===
call foo
assert R0 == 579
>>>

<<< field access
Class = data {
   x,y:Int;
   somethingElse:Int;
   sePtr = code #this () { &somethingElse };    // also tests bad peephole of Plea
};
foo = code() {
   y : Class;
   x : Class^ = &y;
   x.somethingElse = 100;
   x.x, x.y = 123, 456;
   x.sePtr()^
};
===
call foo
assert R0 == 100
>>>

<<< static init
Class = data {
   x,y:Int = 3, 5;
   plus := code #this () { x+y };
};
x : Class;
foo = code() {
   x.x, x.y = 123, 456;
   x.plus();
};
===
call foo
assert R0 == 579
>>>

<<< static init #2
Class = data {
   x,y:Int = 3, 5;
   plus := code #this () { x+y };
};
x : Class;
y : Class;

// global init code
({
x.y = 456;
}) 

foo = code() {
   x.x = 123;
   x.plus() - y.plus();
};
===
call foo
assert R0 == 571
// don't init twice
call foo
assert R0 == 571
>>>

<<< static init #3
Class = data {
   x,y:Int = 3, 5;
   plus := code #this () { x+y };
};
x : Class;
y : Class;

// global init code
({
p := 456;
x.y = p;
}) 

// distinct 'p'
({
p : Byte = 123;
x.x = p;
}) 

foo = code() {
   x.plus() - y.plus();
};
===
call foo
assert R0 == 571
// don't init twice
call foo
assert R0 == 571
>>>

<<< virtual methods 1
Class = data {
   x,y:Int = 3,5;
   op : code #this ( => Int) = code { x + y };
   other : code #this(x:Int => Int) = code { -x + :x };
};
Derived = Class + data {
   op ::= code { x - y };
   y ::= 100;
};
foo = code() {
   y : Derived;
   x : Class^ = &y;
   x.op() * x.y;
};
===
call foo
assert R0 == -9700
>>> 

<<< new methods
brk := 0xa000;
_new = code(s:Int) {
    ret : Int;
    ret, brk = brk, (brk+((s+1)&~1));
};
new = code #macro (T #macro; args #macro #list) {
    ptr := _new(sizeof(T)){T^};
    ptr.__init__(args);
    ptr;
};

Node = data {
    x : Int;
    __init__ = code #this (x:Int) {
        :x = x;
    };
}; 
Node2 = data {
    x : Int;
    y : Str^;
    __init__ = code #this (x:Int; y:Str^) {
        (:x, :y) = (x, y);
    };
}; 
main = code() {
    n1 := new(Node, 10);
    n2 := new(Node2, 40, "foo");
    n2.y.length + n2.x + n1.x + (n2.y[1] << 8); // last bit tests implicit index of Str and fixup of types
};
===
call main
assert R0 == 0x6f35
>>>

<<< list of pairs
Pair = [T, U] data { first : T; second : U; };
List = [T] data {
        node:T;
        next:List<T>^;
};

squareList = code (x:Int) {
  entries:List<Pair<Char,Int>>[10];
  a:List<Pair<Char, Int>>^;
  for i in x do {
       p:Pair =[Char(i), Int((i+1)*(i+1))];
        b:List = [p];
        b.next=a;
       entries[i]=b;
        a = &entries[i];
  };
};
main = code() {
    a := squareList(5);
    s := 0;
    while a do s, a = s + a.node.second, a.next; 
    s;
};
===
call main
// 1+4+9+16+25
assert R0 == 55
>>>
