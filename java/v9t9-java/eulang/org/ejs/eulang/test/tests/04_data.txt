<<< dynamic linked list #1
brk := 0xa000;
_new = code(s:Int) {
    ret : Int;
    ret, brk = brk, (brk+((s+1)&~1));
};
new = [T] code( =>T^) {
    _new(sizeof(T)){T^};
};

List = [T] data {   // 10
    node : T;
    next : List^;
};

makeList = code () {
    head, prev : List<Int>^ = nil, nil;
    for x in 100 do {
        node := new<List<Int> >();
        node.node = x;
        if prev != nil then prev.next = node else head = node; // 20
        prev = node;
    };
    head;
};

main = code() {
    list := makeList();
    c : Int = 0;
    n := list; while n != nil do c, n = c+1, n.next;
    0xf000{Int^}^ = c;
};
===
call main
assert 0xf000 == 100
>>>

<<< dynamic linked list #2
brk := 0xa000;
_new = code(s:Int) {
    ret : Int;
    ret, brk = brk, (brk+((s+1)&~1));
};
new = code #macro (T #macro) {
    _new(sizeof(T)){T^};
};

List = [T] data {   // 10
    node : T;
    next : List^;
};

makeList = code () {
    head, prev : List<Int>^ = nil, nil;
    for x in 100 do {
        node := new(typeof(head^));
        node.node = x;
        if prev != nil then prev.next = node else head = node; // 20
        prev = node;
    };
    head;
};

main = code() {
    list := makeList();
    c, s : Int = 0;
    n := list; while n != nil do c, n, s = c+1, n.next, s + n.node;
    0xf000{Int^}^ = c;
    0xf002{Int^}^ = s;
};
===
call main
assert 0xf000 == 100
assert 0xf002 == 4950
>>>

<<< method calls #1
Class = data {
   x,y:Int;
   somethingElse:Int;
   pt = code #this () { (x,y) };
};
foo = code() {
   x : Class;
   x.x, x.y = 123, 456;
   (a,b) := x.pt();
   a+b
};
===
call foo
assert R0 == 579
>>>

<<< field access
Class = data {
   x,y:Int;
   somethingElse:Int;
   sePtr = code #this () { &somethingElse };    // also tests bad peephole of Plea
};
foo = code() {
   y : Class;
   x : Class^ = &y;
   x.somethingElse = 100;
   x.x, x.y = 123, 456;
   x.sePtr()^
};
===
call foo
assert R0 == 100
>>>

<<< static init
Class = data {
   x,y:Int = 3, 5;
   plus := code #this () { x+y };
};
x : Class;
foo = code() {
   x.x, x.y = 123, 456;
   x.plus();
};
===
call foo
assert R0 == 579
>>>

<<< static init #2
Class = data {
   x,y:Int = 3, 5;
   plus := code #this () { x+y };
};
x : Class;
y : Class;

({
x.y = 456;
}) 

foo = code() {
   x.x = 123;
   x.plus() - y.plus();
};
===
call foo
assert R0 == 571
// don't init twice
call foo
assert R0 == 571
>>>


<<< static init #3
Class = data {
   x,y:Int = 3, 5;
   plus := code #this () { x+y };
};
x : Class;
y : Class;

({
p := 456;
x.y = p;
}) 

({
p := 123;
x.x = p;
}) 

foo = code() {
   x.plus() - y.plus();
};
===
call foo
assert R0 == 571
// don't init twice
call foo
assert R0 == 571
>>>