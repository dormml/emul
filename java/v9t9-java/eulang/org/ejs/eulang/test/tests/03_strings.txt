<<< string data
a := "SUCKA!!! \r\n\t\xff\x7f\x00\x02";
testStrings = code () {
   z := "hello";
  y := "there";
};
===
call testStrings
>>>

<<< string access
testStrings = code () {
   z := "hello";
  y := "there";
  z[1]-'e'+y[1]
};
===
call testStrings
assert byte R0 == 0x68
>>>

<<< string access 2
// this one tests stack alignment (7 byte string objects) and
// the copy-loop expansion moves the lifetime of 'z.length' to a later
// linear block, which also tests proper local lifetime allocation 
// (it shouldn't be removed as dead, making the loop exit immediately)
testStrings = code () {
   z := "hello";
  y := "there";
  s := 0;
  for x in z.length do s += z[x] - y[x];
};
===
call testStrings
assert R0 == -4
>>>

<<< string access 3 
// hmm, the addr-of-literal doesn't make sense without exporting literals earlier (than isel time)
// allow addressing string literals, and be sure to externalize them to data
testStrings = code () {
   z := &"hello";
  y := &"there";
  s := 0;
  for x in z.length do s += z[x] - y[x];
};
===
call testStrings
assert R0 == -4
>>>