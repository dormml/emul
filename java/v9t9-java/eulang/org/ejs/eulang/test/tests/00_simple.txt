<<< simple
x : Int = 5;
getX = code() { x; };
===
call getX
assert R0 == 5
>>>

<<< shifting
x : Int = 5;
testShift1 = code() { y := 4; z := ((x << y) << 8); y = 16; z |= x << y; };
===
call testShift1
assert R0 == 0x5000
>>>

<<< caller arg access
doGetArg1 = code(x:Int[10]) {
    x[0];
};
getArg1 = code() {
    loc:Int[10];
    loc[0] = 1234;
    doGetArg1(loc); 
};
===
call getArg1
assert R0 == 1234
>>>

<<< call negate
x := 100;
negate = [T] code(x) { -x; };
testSimpleCall1 = code() { y := x*2; z := negate(y);  };
===
call testSimpleCall1
assert R0 == -200
>>>

<<< factorial!
fac = code(x:Int) {
    if x <= 1 then 1 else x * fac(x-1)
};
doFac = code() { fac(8); };
===
call doFac
assert R0 == 40320
>>>

<<< factorial w/stack copy
Bloat =: Byte[8];
fac = code(x:Int; b:Bloat) {
    if x <= 1 then 1 else x * fac(x-1, b)
};
b : Bloat;
doFac = code() { fac(8, b); };
===
call doFac
assert R0 == 40320
>>>

<<< integer multiply
mulBy = macro(macro val : Int; macro K : Int) {
    val * K
};
stuff = code(x : Byte; y : Int) {
    // TODO: we can't do an unsigned trunc cast!  (Byte -> Int sign extends)
    //(mulBy(x, 10) + mulBy(x, 100){+Byte} + mulBy(y, -5) + mulBy(y, -17);
    ((mulBy(x, 10) + mulBy(x, 100))&0xff) + mulBy(y, -5) + mulBy(y, -17);
};
mulper = code() {
    stuff(2, 9);
};
===
call mulper
assert R0 == 22
>>>
