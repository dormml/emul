<<< simple
x : Int = 5;
getX = code() { x; };
===
call getX
assert R0 == 5
>>>

<<< shifting
x : Int = 5;
testShift1 = code() { y := 4; z := ((x << y) << 8); y = 16; z |= x << y; };
===
call testShift1
assert R0 == 0x5000
>>>

<<< caller arg access
doGetArg1 = code(x:Int[10]) {
    x[0];
};
getArg1 = code() {
    loc:Int[10];
    loc[0] = 1234;
    doGetArg1(loc); 
};
===
call getArg1
assert R0 == 1234
>>>

<<< call negate
x := 100;
negate = [T] code(x) { -x; };
testSimpleCall1 = code() { y := x*2; z := negate(y);  };
===
call testSimpleCall1
assert R0 == -200
>>>

<<< factorial!
fac = code(x:Int) {
    if x <= 1 then 1 else x * fac(x-1)
};
doFac = code() { fac(8); };
===
call doFac
assert R0 == 40320
>>>

<<< factorial w/stack copy
Bloat =: Byte[8];
fac = code(x:Int; b:Bloat) {
    if x <= 1 then 1 else x * fac(x-1, b)
};
b : Bloat;
doFac = code() { fac(8, b); };
===
call doFac
assert R0 == 40320
>>>

<<< integer multiply and unsigned cast
mulBy = macro(macro val : Int; macro K : Int) {
    val * K
};
stuff = code(x : Byte; y : Int) {
    (mulBy(x, 10) + mulBy(x, 100)){+Int} + mulBy(y, -5) + mulBy(y, -17);
};
mulper = code() {
    stuff(2, 9);
};
===
call mulper
assert R0 == 22
>>>

<<< unsigned cast
mulper = code() {
    255{Byte}{+Int}
};
===
call mulper
assert R0 == 255
>>>

<<< test some complex pointers
dat:Byte[]=[0,1,2,3,4,5,6,7,8,9];
test = code(idx:Int) {
 p:Byte^=&dat;
 (p + idx*3 + idx + 1)^;
};
===
write R0 1
call test
assert byte R0 == 0x5
>>>

<<< char literals
foo:Char[] = ['a', 'b', '\\', '\'', '"', '\r', '\n', '\t' ];
main = code() {
    foo[2] - '\\' + foo[6];
};        
===
call main
assert byte R0 == 10
>>>

<<< rotate left intrinsics
main = code(x,y:Int) {
    x <<| y
};
mainB = code(x,y:Byte) {
    x <<| y
};
===
write R0 0xF000
write R1 1
call main
assert R0 == 0xE001

write R0 0x000F
write R1 15
call main
assert R0 == 0x8007

write R0 0xF000
write R1 0x0100
call mainB
assert byte R0 == 0xE1

write R0 0x0F00
write R1 0x0700
call mainB
assert byte R0 == 0x87

>>>

<<< rotate right intrinsics
main = code(x,y:Int) {
    x >>| y
};
mainB = code(x,y:Byte) {
    x >>| y
};
===
write R0 0xF000
write R1 15
call main
assert R0 == 0xE001

write R0 0x000F
write R1 1
call main
assert R0 == 0x8007

write R0 0xF000
write R1 0x0700
call mainB
assert byte R0 == 0xE1

write R0 0x0F00
write R1 0x0100
call mainB
assert byte R0 == 0x87

>>>

<<< divisor intrinsics
main = code(x,y:Int) {
    x / y  // signed
};
===
write R0 15
write R1 7
call main
assert R0 == 2

write R0 -15
write R1 7
call main
assert R0 == -2

write R0 -15
write R1 -7
call main
assert R0 == 2

write R0 15
write R1 -7
call main
assert R0 == -2


>>>

<<< remainder intrinsics
main = code(x,y:Int) {
    x \ y  // remainder
};
===
write R0 15
write R1 7
call main
assert R0 == 1

write R0 -15
write R1 7
call main
assert R0 == -1

write R0 15
write R1 -7
call main
assert R0 == 1

write R0 -15
write R1 -7
call main
assert R0 == -1

>>>

<<< remainder intrinsics #2
main = code(x,y:Int) {
    (x / y) * y + (x \ y) 
};
===
// note: this is ALSO testing reuse of registers R0 and R1 in different contexts
write R0 15
write R1 7
call main
assert R0 == 15

write R0 -15
write R1 7
call main
assert R0 == -15

write R0 15
write R1 -7
call main
assert R0 == 15

write R0 -15
write R1 -7
call main
assert R0 == -15

>>>

<<< modulo
main = code(x,y:Int) {
    x % y  // modulo, which treats negative 'x' sensibly
};
===
write R0 7
write R1 6
call main
assert R0 == 1

write R0 -1
write R1 6
call main
assert R0 == 5

write R0 -8
write R1 6
call main
assert R0 == 4

write R0 11
write R1 -5     // treated as positive
call main
assert R0 == 11
>>>