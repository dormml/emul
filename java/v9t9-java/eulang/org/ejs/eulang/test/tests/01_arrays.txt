<<< sum of array
testArraySum = code() {
  vals : Int[10];
  s := 0;
  for i in 10 do vals[i] = i+1;
  for i in 10 do s += vals[i];
};
===
call testArraySum 
assert R0 == 55
>>>

<<< sum of array through pointer
vals:Int[10];
testArraySum = code() {
  valp : Int[]^ = &vals;
  s := 0;
  for i in 10 do valp[i] = i+1;
  for i in 10 do s += valp[i];
};
===
call testArraySum
assert R0 == 55
>>>

<<< sum of array row/col
ARRAY =: Int[3,3];
vals:ARRAY;
doSum = code(valp:ARRAY^) {
  s := 0;
  for i in 3 do for j in 3 do valp[i,j] = i*3+j;       // 0,1,2 | 3,4,5 | 6,7,8
  for i in 3 do s += valp[i,i]+3;     // 0+3 | 4+3 | 8+3
};
testArraySum = code() {
  valp := &vals;
  doSum(valp);
};
===
call testArraySum
assert R0 == 21
>>>

<<< oblique test of locals being copied (and CLR/NEG peephole)
vals: Int[3,3];
doSum = code(arr: Int[3,3]) {
  s := 0;
  for i in 3 do for j in 3 do arr[i,j] = (i+2)*(j+2);       // 4,6,8 | 6,9,12 | 8,12,16
  for i in 3 do for j in 3 do vals[i][j] -= arr[i][j];
};
testArrayAndCopy = code() {
  doSum(vals);
};
===
call testArrayAndCopy
assert vals == -4
>>>

<<< array copies
vals: Int[3,3];
doSum = code() {
  s := 0;
  arr: Int[3];
  for i in 3 do arr[2-i] = 100*(i+1);
  for i in 3 do for j in 3 do vals[i] = arr;
};
===
call doSum
assert vals == 300
assert vals + 2 == 200
assert vals + 4 == 100
assert vals + 6 == 300
assert vals + 8 == 200
assert vals + 10 == 100
assert vals + 12 == 300
assert vals + 14 == 200
assert vals + 16 == 100
>>>

skip
<<< variable-sized arrays
mySummer = code(size:Int) {
    arr:Int[size];
    for x in size do arr[x] = x; 
    s : Int;
    for x in size do s += arr[x];
};
===
write R0 10
call mySummer
assert R0 == 45
>>>

<<< pointer math 1
vals: Int[3,3]; 
doSum = code() {
    valp : Int^ = (&vals){Int^};
    s := 0;
    for i in 9 do (valp+i)^ = i+1;
    for i in 3 do for j in 3 do s += vals[i][j];
};
===
call doSum
assert R0 == 45
>>>

<<< pointer math 2
vals: Int[3,3]; 
doSum = code() {
    valp : Int^ = (&vals){Int^};
    s := 0;
    for i in 3 do for j in 3 do (valp+(i*3+j))^ = i*3+j+1;
    for i in 3 do for j in 3 do s += vals[j][i];
};
===
call doSum
assert R0 == 45
>>>

<<< string data
a := "SUCKA!!! \r\n\t\xff\x7f\x00\x02";
testStrings = code () {
   z := "hello";
  y := "there";
  z[1]-'e'+y[1]
};
===
call testStrings
assert byte R0 == 0x68
>>>
