

1 <export

User STATE

: literal ( n -- )  
    dup -8 >= over 8 < and  if
        $f and $20 or c,  else
    dup -128 >= over 128 < and  if
        $78 c, c,
    else
        $79 c, ,
    then then
; immediate target-only
 
: dliteral ( d -- )  
        $7e c,
    2dup -8. d>= over 8. d< and  if
        drop $f and $20 or c,  else
    2dup -128. d>= over 128. d< and  if
        drop $78 c, c,
    else
        $79 c, ,
    then then
; immediate target-only 
 
: >call  1 urshift $8000 or  ; 
 
: compile,
  dup ['] ;s       = if  Iexit c,        drop    exit   then
  dup ['] branch   = if  IbranchB c,     drop    exit   then
  dup ['] 0branch  = if  I0branchB c,    drop    exit   then
  dup ['] unloop   = if  Irdrop_d ,      drop    exit   then
  dup ['] i        = if  IatR c,         drop    exit   then
  dup ['] (?do)    = if  Idup_d , ItoR_d , Isub c, I0branchB c,  drop  exit  then
  dup ['] (loop)   = if  IloopUp c,      drop    exit   then  
  dup ['] (+loop)  = if  IplusLoopUp c,  drop    exit   then
  dup ['] (uloop)  = if  IuloopUp c,     drop    exit   then
  dup ['] (u+loop) = if  IuplusloopUp c, drop    exit   then

  >call ,   
;

export>


1 [if]
    : RamVar  ( n -- )  create  
    
        negate  ramptr +!  
        ramptr @  ,
    
        ( be sure compiler doesn't optimize )
    does>
        @
    
    ;  
[else]
    : RamVar  ( n -- )    
    
        create immediate
        
        negate  ramptr +!  
        ramptr @  , 
    
    does>
    
        \ oops, for "state" itself, this um compiles a ton of shit
        \ into the dictionary -- prolly a bug
        state @ if 
        
            $79 c, 
            @
            ,  $70 c,
        else
            @
        then
    
    ;  

[then]

