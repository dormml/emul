
: >call  1 urshift $8000 or  ; 
: call>  1 lshift  ; 
 
:: inlineable ( opc -- f )
    opc $20 >= 
    opc $7a $7f within not
    opc Idovar = not  
    and and
;


1 <export

User STATE

: literal ( n -- )  
    dup -8 >= over 8 < and  if
        $f and $20 or c,  else
    dup -128 >= over 128 < and  if
        $78 c, c,
    else
        $79 c, ,
    then then
; immediate target-only
 
: dliteral ( d -- )  
        $7e c,
    2dup -8. d>= over 8. d< and  if
        drop $f and $20 or c,  else
    2dup -128. d>= over 128. d< and  if
        drop $78 c, c,
    else
        $79 c, ,
    then then
; immediate target-only 
 
: compile,
    :> addr
    
    \ ;s
    addr ['] ;s       = if  Iexit c,        exit   then

    \ ones we must directly detect
    addr ['] branch   = if  IbranchB c,     exit   then
    addr ['] 0branch  = if  I0branchB c,    exit   then

    \ empty prims or words
    addr c@ $70 = if
        exit
    then    
        
    \ 1 byte prims
    addr 1+ c@ $70 = if
        addr c@  dup  inlineable  if
            c,
        else
            drop
            addr >call ,
        then
        exit
    then
    
    \ 2 byte prims
    addr 2+ c@ $70 = if
        addr c@  dup  inlineable 
        addr 1+ c@  dup  inlineable
        and if
            swap c, c,
        else
            2drop
            addr >call ,   
        then
        exit
    then        
    
    \ special case of prim that uses r-stack and must be inlined    
    addr ['] (?do)    = if  Idup_d , ItoR_d , Isub c, I0branchB c,  exit  then

    \ all other cases
    addr >call ,   
;

export>


1 [if]
    : RamVar  ( n -- )  create  
    
        negate  ramptr +!  
        ramptr @  ,
    
        ( be sure compiler doesn't optimize )
    does>
        @
    
    ;  
[else]
    : RamVar  ( n -- )    
    
        create immediate
        
        negate  ramptr +!  
        ramptr @  , 
    
    does>
    
        \ oops, for "state" itself, this um compiles a ton of shit
        \ into the dictionary -- prolly a bug
        state @ if 
        
            $79 c, 
            @
            ,  $70 c,
        else
            @
        then
    
    ;  

[then]

: +Nfield    ( "name" ptr -- ptr' )    - dup Constant ; immediate
: +field    ( "name" ptr -- ptr' )    2- dup Constant ; immediate
: +1field   ( "name" ptr -- ptr' )    1- dup Constant ; immediate

