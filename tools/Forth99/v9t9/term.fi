
( In the terminal, characters are located by a video-mode-specific
position in a video-mode-specific window.  I.e. for text modes
they represent characters, and for graphics modes, they 
represent pixels.  These are called "units" here.

The video mode determines how to advance the cursor based on
the current font.
)

0   RamVar  t-data

t-data
    ( cursor position, in units, offset from window )
    +field  v-x             \ cursor x unit
    +field  v-y             \ cursor y unit
    
    ( maximum window size, in units )
    +field  win-mx  
    +field  win-my  

    ( window attributes, in units )
    +field  win-x
    +field  win-y
    +field  win-sx
    +field  win-sy

dup constant t-data0
    
t-data over -  Constant t-data-size

ramptr !

: term-refresh
    v-text  c@ not  if
        v-width @   v-fntwidth c@  align-to  win-mx  !
        v-height @  v-fntheight c@ align-to  win-my  !
    else
        v-width @   win-mx  !
        v-height @  win-my  !
    then
;

\   Reset terminal from the current mode
: term-reset
    cursor-off
    
    term-refresh

    full!
    
    home
;

1 <export
:   home
    0 v-x !
    0 v-y !
;

:   xy ( -- v-x v-y )
    v-x @  v-y @
;

:   at-xy ( x y  -- )
    cursor-off
    v-y !  v-x !
;

( in units )
::   win! ( w h x y -- )
    w  win-mx @  umin  x +  win-mx @  umin  :> x2
    h  win-my @  umin  y +  win-my @  umin  :> y2
    0 x max  dup  win-x !  x2  swap -  win-sx !
    0 y max  dup  win-y !  y2  swap -  win-sy !
;

( set full window )
: full!
    -1 -1 0 0  win!
;

export>

( screen, vs. window, x y ) 
:   $xy ( -- x y )
    v-x @ win-x @ +
    v-y @ win-y @ +
;


:   txt-xy>addr ( x y -- addr )
    win-y @ +  v-width @  U*  
    swap  win-x @ +  +
    v-screen @ +
;

:   home-col
    0 v-x !
;

:   ch>xy ( ch -- xs ys )
    drop  v-text c@  if  1 1  else  v-fntwidth c@  v-fntheight c@  then
;
:   ch>y ( ch -- ys )
    drop  v-text c@  if  1  else  v-fntheight c@  then   
;
:   ch>x ( ch -- xs )
    drop  v-text c@  if  1  else  v-fntwidth c@  then   
;

:   win-chsize ( -- xs ys )
    v-text c@ if
        win-sx @ win-sy @
    else
        win-sx @ v-fntwidth c@  u/
        win-sy @ v-fntheight c@ u/
    then
;

:   advance-row 
    v-y @  32 ch>y  +   
    dup win-sy @ >= if
       drop 0
    then
    v-y !
;

:   advance-cursor ( ch -- )
    ch>x  v-x @  +   
    dup win-sx @ >= if
        drop 0
        advance-row 
    then
    v-x !
;

:   cursor-off
    $xy v-cursor-off
;

:   crlf
    cursor-off    
    advance-row
    home-col 
;  

:   bksp ( ch -- )
    cursor-off
    ch>xy  negate :> y  negate :> x   
    x v-x +!
    v-x @ 0< if
        win-sx @ x +  v-x !
        y v-y +!
        v-y @ 0< if
            win-sy @ y +  v-y !
        then
    then
;

1 <EXPORT

::   chfill  ( ch -- )
    home
    win-chsize  :> rows  :> cnt
    rows 0 do
        ch cnt hchar
        advance-row
    loop
;

:   hchar ( ch len -- ) 
    'v-hchar @  ?dup if
        >r  $xy  r>  execute
    else
        xy 2>r
        0 do  dup  (emit) dup  advance-cursor  loop  drop
        2r> at-xy
    then
;

::   vchar ( ch len -- ) 
    'v-vchar @  ?dup if
        >r  ch len $xy  r>  execute
    else
        ch ch>xy :> ys :> xs
        v-y @ :> origvy
        xy 2>r
        len 0 do  
            ch  (emit) 
            v-y @  ys +  win-sy @ umod  dup v-y !  
            origvy = if
                v-x @ xs +  win-sx @ umod  v-x !
            then   
        loop 
        2r> at-xy
    then
;

:   cls  
    \ 'v-clear @  execute
    32  win-sx @ win-sy @ U*  hchar   
    home
;

:   (emit)  ( ch -- )
    $xy  'v-drawchar @  execute  
;

:   emit    ( ch -- )
    cursor-off
    dup 13 = if
        drop crlf
    else dup 8 = if
        drop 32 bksp
    else
        dup  (emit) advance-cursor
    then then 
;    target-only

:   getch    ( x y -- ch )
    'v-readchar @  ?dup if
        execute
    else
        2drop -1
    then
;

:   cr  13 emit  ; 
:   space  32 emit  ;

:   type ( caddr n -- )
    over + swap do i c@ emit loop     
;

EXPORT>


