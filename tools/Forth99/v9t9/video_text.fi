
: txt-chaddr ( x y -- addr )
    v-width @ U*  +
    v-screen @ + 
;

: txt-waddr ( x y -- )
    txt-chaddr !vwaddr
;

: txt-drawchar ( ch x y -- )
    txt-waddr VDPWD c!   
;
: txt-readchar ( x y -- )
    txt-chaddr vwaddr VDPRD c@
;
: txt-blinkcursor ( x y -- )
    txt-chaddr 
    
    $80 v-curs c+!
    v-curs c@ if  
        dup vwaddr              \ read char under cursor
        VDPRD c@  v-curs-under c!
        
        !vwaddr
        [CHAR] _  VDPWD c!      \ draw cursor
    else
        !vwaddr
        v-curs-under c@  
        VDPWD c!                \ restore char under cursor
    then
;

0 [IF]
( Split a range that wraps around a boundary )
:: range-wrap ( sz addr start len -- addr1 len1 addr2 len2 )
    ( portion from addr...min addr+sz,start+len )
    addr  addr sz +  start len +  min  addr  -
    
    ( portion from start...start + sz % len )
    start  over  sz - negate
;
 
: txt-hchar ( ch len x y -- )
    txt-chaddr
    rot >r
    v-screen @ v-screensz @  range-wrap
    
    r@   rot rot  vfill
    r>   rot rot  vfill
;

:: txt-vchar ( ch len x y -- )
    x y txt-chaddr  v-screen @ -  :> offs
    v-screensz @  :> lim
    
    len 0 do
        offs  v-screen @ +  !vwaddr  ch VDPWD c!
        offs  win-sx @ +  dup lim >= if
            lim -  1+  win-sx @  umod  
        then  
        offs!
    loop
;
[THEN]

: txt-setupmode
    true v-text c!
;

: txt-updatecolors
    color-byte  $8700  or v-regaddr
;

: txt-clear
    $20  v-screen @ v-screensz @ vfill
;

\ -------------------

: std-setfont   ( addr -- )
    v-patts @   $800  gvmove
;


\ -------------------

Create TextFunctions 
    'v-drawchar ,        ' txt-drawchar ,
    'v-readchar ,        ' txt-readchar ,
    'v-blinkcursor ,     ' txt-blinkcursor ,
    'v-setfont ,         ' std-setfont ,
    'v-clear ,           ' txt-clear ,
    \ 'v-hchar ,           ' txt-hchar ,
    \ 'v-vchar ,           ' txt-vchar ,
    0 , 



\       0=text mode
\           >0000 = screen
\           >0800 = patts
\           >1000+= free
\
Create TextModeParams
    v-screen    , 0 ,       v-screensz  , 960 ,
    v-patts     , $800 ,    v-pattsz    , $800 ,
    v-colors    , $0 ,      v-colorsz   , $0 ,
    v-sprites   , $0 ,      v-sprcol    , $0 ,
    v-sprpat    , $0 ,      v-sprmot    , $0 ,
    v-free      , $1000 ,

    v-width     , 40 ,      v-height    , 24 ,
    
    'v-setupmode ,           ' txt-setupmode ,
    'v-updatecolors ,        ' txt-updatecolors ,
    
    0 ,
    
create  TextModeRegs
    $8000 , $81B0 , $8200 , $8401 , 0 ,
    
: text-mode
    TextFunctions write-var-list
    TextModeParams write-var-list
        
    TextModeRegs write-vregs
;

\ -------------------

: (sprite-setup)
    $00  v-sprites @  $80  vfill
    $00  v-sprpat @   $800 vfill
    $00  v-sprmot @   $80 vfill
;


: std-sprite-setup
    (sprite-setup)
    $D0  v-sprites @ +vc!
;

: v9938-sprite-setup
    (sprite-setup)
    $D8  v-sprites @ +vc!
    $00  v-sprcol @  $200  vfill
;


\ -------------------

\       1=graphics mode
\           >0000 = screen
\           >0300 = sprites
\           >0380 = colors
\           >03A0 = sprite motion
\           >0420 = sprite patterns (really 0->800)
\           >0800 = char patts
\           >1000+= free
\
Create GfxModeRegs
    $8000 , $81A0 , $8200 , $830E , $8401 , $8506 , $8600 , 0 ,

Create GfxModeParams
    v-screen    , 0 ,       v-screensz  , 768 ,
    v-colors    , $380 ,    v-colorsz   , $20 ,
    v-patts     , $800 ,    v-pattsz    , $800 ,
    v-sprites   , $300 ,    v-sprcol    , $0 ,
    v-sprpat    , $0 ,      v-sprmot    , $3A0 ,
    v-free      , $1000 ,
    
    v-width     , 32 ,      v-height    , 24 ,
    
    'v-setupmode ,           ' gfx-setupmode ,
    'v-updatecolors ,        ' gfx-updatecolors ,
    
    0 ,

: gfx-setupmode
    std-sprite-setup
    true v-text c!
;

: gfx-updatecolors
    color-byte  v-colors @  v-colorsz @  vfill
;

: gfx-mode
    TextFunctions write-var-list
    GfxModeParams write-var-list
      
    GfxModeRegs write-vregs
;


\ -------------------

:: txt2-drawchar ( ch x y -- )
    ch x y  txt-drawchar
    
    \ reset or set blink bit
    x y  v-width @ U*  +  
    dup  7 and  $80 swap urshift  :> mask
    3 urshift  v-colors @ +  :> addr
    
    \ assume bank is still valid
    addr  vc@
    mask  v-blink c@  if  OR  else  INVERT AND  then  
    addr  vc!
;

: txt2-clear
    txt-clear
    
    \ clear colors (blinks)
    v-blink c@  not not
    v-colors @  v-colorsz @  vfill
;

\       8=text 2 mode
\           >0000 = screen (to >870 for 212-line mode)
\           >0A00 = colors (blinks)
\           >1000 = patts
\           >1800+= free
\
Create Text2ModeRegs
    $8004 , $81B0 , $8200 , $832F , $8A00 , $8402 , $8D22 , $8980 , 0 ,

Create Text2Functions
    'v-drawchar ,       ' txt2-drawchar  ,      
    'v-clear ,          ' txt2-clear     ,      
    0 ,

Create Text2ModeParams
    v-screen    , 0 ,       v-screensz  , 2160 ,
    v-colors    , $a00 ,    v-colorsz   , 2160 8 / ,
    v-patts     , $1000 ,   v-pattsz    , $800 ,
    v-sprites   , 0 ,       v-sprcol    , 0 ,
    v-sprpat    , 0 ,       v-sprmot    , 0 , 
    v-free      , $1800 ,
     
    v-width     , 80 ,      v-height    , 26 ,
    
    'v-setupmode ,           ' txt2-setupmode ,
    'v-updatecolors ,        ' txt-updatecolors ,

    0 ,
    
: txt2-setupmode
    txt-setupmode
\    $00  v-colors @ v-colorsz @  vfill
    \ set blink to inverse colors
    bg@  4 lshift  fg@  OR  $8C00 OR  v-regaddr  

;
    
: text2-mode
    TextFunctions write-var-list
    Text2Functions write-var-list
    Text2ModeParams write-var-list
        
    Text2ModeRegs write-vregs

;
    