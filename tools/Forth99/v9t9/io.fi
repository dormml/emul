
( the routine that handles RWBLK )
| User >rwblk

\ mini-exception handler
| User exclink


\
\  Before:      After (before return):
\
\                   exclink -> old RP
\ 
\  RP           RP
\
\               ret
\               old SP          <-- new exclink
\               old exclink
\  ret          ret
\          
: guard ( -- -1 | err 0 )
    r@   ( ret )
    exclink @  >r
    sp@ cell+  >r
    rp@  exclink !
    -1  
    
    swap ( -1 ret )  >r
;


: toss ( err -- )
    exclink @  rp!
    exclink !  \ store return here for now
    r>  sp!
    r>  
    exclink @  \ retrieve return    
    swap exclink !
    0   
    \ exit...
;


\
\  Before:                  After (before return):
\ 
\   exclink -> old RP @SP
\
\  RP                       RP
\
\  ret'         
\  old SP       
\  old exclink  
\  ret                      ret'
\          
: unguard ( -- )
    r>      ( ret' )
    exclink @   rp!
    r>  drop
    r>   exclink ! 
    rdrop  >r      ( R: ret' )
;


: ?toss ( 0|err -- )
    ?dup if toss then
;

\ ----------------------------

( execute 'xt' for up to 'ms' mseconds until it returns !0; return 0 if timeout )
:: wait4 ( ms xt -- 0 | -1 )

    [ 0 [if] ]
         ms 0 do
            xt execute
            ?dup if  unloop exit  then
        loop
        -1
    [ [else] ]
        ms 60 1000 U*/  s>d
        vdp-ticks d@  d+  :> h-limit :> l-limit
        
        begin
            xt execute
            ?dup if exit then
            ints-check
            vdp-ticks d@  l-limit h-limit  d>=  if 0 exit then
        again
    [ [then] ]         
;


0 <export

: fdc-ready ( -- 0|$80 )
    'DSKST c@ 
    dup  #dskStRdy <
    swap #dskStBusy AND 0=
    AND
;

: fdc-wait-ready ( ms -- ! )
    ['] fdc-ready  wait4  0=  ?toss 
;

: fdc-command ( cmd-byte -- ! )
    3000 fdc-wait-ready
    
    'DSKCMD c!
    
    3000 fdc-wait-ready
;


:: dsk-flg! ( on? mask -- )
    mask  'DSKFLG c@  on?  if OR else NAND then   
    'DSKFLG c!
;

: dsk-flg? ( mask -- )
    'DSKFLG c@  AND
;

: motor ( on? -- 0|err )
    #dskFlgMotor dsk-flg!
;


: seek-command ( cmd -- )
    [ #dskCmd'Head #dskCmd'Verify #dskCmd'10ms OR OR literal ] OR      
    fdc-command 
;

:: seek-track ( trk side -- )
    true motor
    false #dskFlgHold dsk-flg!
    
    side 1 U>=  ?toss
     
    \ set side
    side #dskFlgSide  dsk-flg!
    \ load head
    true #dskFlgHead  dsk-flg!

    \ STUPID for now
    #dskCmdRestore seek-command   
    
    trk 'DSKDAT c!
    #dskCmdSeek seek-command
    
    \ keep motor going in case of xfers 
;


\ ---------

40 constant tracks-per-side
9 constant secs-per-track
256 constant bytes-per-sector
chars/block bytes-per-sector u/  constant secs-per-block

: sec>attrs ( sec# -- sec trk side )
    secs-per-track U/MOD
    tracks-per-side U/MOD
;

: block>sec ( block -- sec )
    secs-per-block  U*
;


: disk-seek-sec ( sec# -- )
    sec>attrs
    seek-track
    'DSKSEC c!
;

: drq-ready ( -- 0|$2 )
    'DSKST c@  #dskStDrq  AND
;

: (dsk-read) ( addr --  )
    'DSKDAT c@  swap c!  
;
    
: (dsk-write) ( addr -- )
    c@  'DSKDAT c!   
;
    
: xfer ( addr xt cmd -- addr )
    fdc-command

    true #dskFlgHold dsk-flg!
    true motor
        
    1 ['] drq-ready  wait4  0= ?toss 
    bytes-per-sector 0 do
        2dup execute  swap 1+ swap
    loop
    drop

    false #dskFlgHold dsk-flg!
    \ keep motor going in case of further xfers
;

\ read/write block on current disk 
:: (disk-rwblk)  ( addr  block# r/w -- err )
    block#  secs-per-block U*  :> sec
    secs-per-block 0 do
        i sec +  disk-seek-sec
        
        addr
        r/w if
            ['] (dsk-read)  #dskCmdReadSector
        else
            ['] (dsk-write) #dskCmdWriteSector
        then
        xfer
        addr!
    loop
            
    0
;

\ ---------------

: disk-rwblk    ( addr  block# r/w -- 0|err )
    1 'DSKNUM c!

    guard if 
        (disk-rwblk)
        unguard
    else
        >r   ( error )
        
        2drop drop
        
        r>    
    then
    
    0 'DSKNUM c!
;

| >gram_base negate chars/block U/  
            Constant    #GRAM


: gram-rwblk    ( addr  block# r/w -- err )
    >r
    dup  0  #GRAM 1-  within if 
        chars/block U*  >gram_base +  
        r>  if  
            swap  chars/block  gcmove  
        else  
            chars/block        cgmove  
        then
        0
    else
        drop 2drop rdrop -1
    then
;

: set-disk  ( xt -- )
    flush
    >rwblk  !
;

export>

: DSK1 ( -- )
    guard if 
        #dskCmdInterrupt fdc-command
        unguard
    then
    ['] disk-rwblk  set-disk
;

: GRAM ( -- )
    ['] gram-rwblk  set-disk
;


\ read or write:  r/w == TRUE means read, FALSE means write
: RWBLK    ( addr  block# r/w -- err )
    >rwblk @  execute
;

| : io-init
    GRAM    
    0 exclink !
; 
