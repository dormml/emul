
( the routine that handles RWBLK )
| User >rwblk

\ mini-exception handler
| User exclink


\
\  Before:      After (before return):
\
\                   exclink -> old RP
\ 
\  RP           RP
\
\               ret
\               old SP          <-- new exclink
\               old exclink
\  ret          ret
\          
: guard ( -- -1 | err 0 )
    r@   ( ret )
    exclink @  >r
    sp@ cell+  >r
    rp@  exclink !
    -1  
    
    swap ( -1 ret )  >r
;


: toss ( err -- )
    exclink @  rp!
    exclink !  \ store return here for now
    r>  sp!
    r>  
    exclink @  \ retrieve return    
    swap exclink !
    0   
    \ exit...
;


\
\  Before:                  After (before return):
\ 
\   exclink -> old RP @SP
\
\  RP                       RP
\
\  ret'         
\  old SP       
\  old exclink  
\  ret                      ret'
\          
: unguard ( -- )
    r>      ( ret' )
    exclink @   rp!
    r>  drop
    r>   exclink ! 
    rdrop  >r      ( R: ret' )
;


: ?toss ( 0|err -- )
    ?dup if toss then
;

\ ----------------------------

( execute 'xt' for up to 'ms' mseconds until it returns !0; return 0 if timeout )
:: wait4 ( ms xt -- 0 | -1 )

    [ 0 [if] ]
         ms 0 do
            xt execute
            ?dup if  unloop exit  then
        loop
        -1
    [ [else] ]
        ms 60 1000 U*/  s>d
        vdp-ticks d@  d+  :> h-limit :> l-limit
        
        begin
            xt execute
            ?dup if exit then
            ints-check
            vdp-ticks d@  l-limit h-limit  d>=  if 0 exit then
        again
    [ [then] ]         
;


0 <export

: fdc-ready ( -- 0|$80 )
    'DSKST c@  $80 <
;

: fdc-wait-ready ( ms -- ! )
    ['] fdc-ready  wait4  0=  ?toss 
;

: fdc-command ( cmd-byte -- ! )
    1000 fdc-wait-ready
    
    'DSKCMD c!
    
    1000 fdc-wait-ready
;


:: dsk-flg! ( on? mask -- )
    mask  'DSKFLG c@  on?  if OR else NAND then   
    'DSKFLG c!
;

: dsk-flg? ( mask -- )
    'DSKFLG c@  AND
;

: motor ( on? -- 0|err )
    $01 dsk-flg!
;


: seek-command ( cmd -- )
    $0E OR      ( load head, verify, step, 10ms )
    fdc-command 
;

:: seek-track ( trk side -- )
    true motor
    
    side 1 U>=  ?toss
     
    \ set side
    side $01  dsk-flg!

    \ STUPID for now
    $00 seek-command    ( restore )
    
    trk 'DSKTRK c!
    $01 seek-command 
;


\ ---------

40 constant tracks-per-side
9 constant secs-per-track
256 constant bytes-per-sector

: sec>attrs ( sec# -- sec trk side )
    secs-per-track U/MOD
    tracks-per-side U/MOD
;

: block>sec ( block -- sec )
    [ chars/block bytes-per-sector u/  literal ] U*
;

: disk-seek-block ( block# -- )
    block>sec  sec>attrs
    seek-track
    
    'DSKSEC c!
;

\ read/write block on current disk 
: (disk-rwblk)  ( addr  block# r/w -- err )
    guard if
        >r
    
        disk-seek-block 
    
        r>   ( r/w )
        
        . .  0
        
        unguard
    else
        >r   ( error )
        
        2drop drop
        
        r>    
    then
;

\ ---------------

: disk-rwblk    ( addr  block# r/w -- 0|err )
    1 'DSKNUM c!

    (disk-rwblk)
    
    0 'DSKNUM c!
;

$2000 Constant GRAMBASE
$E000 chars/block U/  Constant #GRAM

: gram-rwblk    ( addr  block# r/w -- err )
    >r
    dup  0  #GRAM 1-  within if 
        chars/block U*  GRAMBASE +  
        r>  if  
            swap  chars/block  gcmove  
        else  
            chars/block        cgmove  
        then
        0
    else
        drop 2drop rdrop -1
    then
;

export>

: DSK1 ( -- )
    ['] disk-rwblk  >rwblk  !
;

: GRAM ( -- )
    ['] gram-rwblk  >rwblk  !
;


\ read or write:  r/w == TRUE means read, FALSE means write
: RWBLK    ( addr  block# r/w -- err )
    >rwblk @  execute
;

| : io-init
    GRAM    
    0 exclink !
; 
