
\   Write VWADDR for reading
\   Assumes addr is masked into 0x3fff range
\
:   vwaddr ( addr -- )
    \ dup VDPWA c! swpb VDPWA c!
    VDPWA !
;

\   Write VWADDR for writing
\   Assumes addr is masked into 0x3fff range
\
:   !vwaddr ( addr -- )
    $4000 OR  VDPWA !
;

\   Set the VDP RAM bank.
\
\   This directly sets VR14 without saving it off (unlike vwreg).
\   It does honor the page offset, though.
\
: vsetbank  ( vaddr -- addr-16k )
    dup 14 urshift 
    \ vpob c@ +
    $8E00 OR  VDPWA !
    $3fff AND
;

\   Write VWADDR and page
\
:   +vwaddr ( addr -- )
    vsetbank
    VDPWA !
;

:   +!vwaddr ( addr -- )
    vsetbank
    $4000 OR  VDPWA !
;


:   gwaddr ( addr -- )
    \ dup swpb GPLWA c! GPLWA c!
    GPLWA !
;

:   graddr ( -- addr )
    \ GPLRA c@ 8 lshift  GPLRA c@  or 1-
    GPLRA @ 1- 
;

:   g@  ( addr -- )
    gwaddr  GPLRD c@  8 lshift  GPLRD c@  or 
;

:   gc@  ( addr -- )
    gwaddr  GPLRD c@
;

:   vc@  ( addr -- )
    vwaddr  VDPRD c@
;
:   vc!  ( val addr -- )
    !vwaddr  VDPWD c!
;

:   +vc@  ( addr -- )
    +vwaddr  VDPRD c@
;
:   +vc!  ( val addr -- )
    +!vwaddr  VDPWD c!
;

:   vfill ( ch addr len -- )
    swap !vwaddr
    VDPWD swap 0 (cfill) 
;
:   +vfill ( ch addr len -- )
    swap +!vwaddr
    VDPWD swap 0 (cfill) 
;

( GPL to VDP move )
:   gvmove ( gaddr vaddr len -- )
    rot gwaddr
    swap  +!vwaddr
    GPLRD VDPWD rot  0 0 (cmove)
;

( VDP to CPU move )
::   vcmove ( vaddr addr len -- )
    vaddr  +vwaddr
    VDPRD addr len  0 1 (cmove)
;
( CPU to VDP move )
::   cvmove ( addr vaddr len -- )
    vaddr  +!vwaddr
    addr VDPWD len  1 0 (cmove)
;

( GPL to CPU move )
::   gcmove ( gaddr addr len -- )
    gaddr  gwaddr
    GPLRD addr len  0 1 (cmove)
;
( CPU to GPL move )
::   cgmove ( addr gaddr len -- )
    gaddr  gwaddr
    addr GPLWD len  1 0 (cmove)
;

:   >bit ( mask -- lowest bit# )
    16 0 do
        dup  1 and  if
            drop i unloop exit
        then
        1 urshift
    loop
    
    drop true
;

