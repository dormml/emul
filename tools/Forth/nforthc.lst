*** nforth.tsm
90                            	incl	general.i
*** general.i
25                                #if ENHANCED_MEMORY
26    >FF80                   VDPRD   equ >FF80
27    >FF82                   VDPST   equ >FF82
28    >FF88                   VDPWD   equ >FF88
29    >FF8A                   VDPWA   equ >FF8A
30    >FF8C                   VDPCL   equ >FF8C
31    >FF8E                   VDPWI   equ >FF8E
32    >FF90                   GPLRD   equ >FF90
33    >FF92                   GPLRA   equ >FF92
34    >FF94                   GPLWD   equ >FF94
35    >FF96                   GPLWA   equ >FF96
36    >FF98                   SPCHRD  equ >FF98
37    >FF9A                   SPCHWT  equ >FF9A
38    >FFA0                   SOUND   equ >FFA0   ; 0x20!
39    >FFC0                   ROMBANK equ >FFC0
40    >FFC2                   FTHBANK equ >FFC2
41                                #else
61    >0001                   SR0	equ	1
62    >0002                   SR1	equ	2
63    >0004                   SR2	equ	4
64    >0008                   SR3	equ	8
65    >0010                   SR4	equ	16
66    >0020                   SR5	equ	32
67    >0040                   SR6	equ	64
68    >0080                   SR7	equ	128
69    >0100                   SR8	equ	256
70    >0200                   SR9	equ	512
71    >0400                   SR10	equ	1024
72    >0800                   SR11	equ	2048
73    >1000                   SR12	equ	4096
74    >2000                   SR13	equ	8192
75    >4000                   SR14	equ	16384
76    >8000                   SR15	equ	32768
82    >0001                   ST_L	equ	1
83    >0002                   ST_A	equ	2
84    >0004                   ST_E	equ	4
85    >0008                   ST_C	equ	8
86    >0010                   ST_OV	equ	16
87    >0020                   ST_OP	equ	32
88    >0040                   ST_X	equ	64
95    >0000                   grom_kbdlist		equ	>0000
96    >0130                   grom_font8x8		equ	>0130
97    >0930                   grom_font5x6		equ >0930
100   >000A                   SP	equ		10
102                            define Push SP, ... [
108                            define Pop SP, ... [
114                            define Vector label, ws [
*** nforth.tsm
91                            	incl	ram.i
*** ram.i
25                            	incl	cpuram.i
*** cpuram.i
28                             #if ENHANCED_MEMORY
30    >FC00                   mainws  equ >FC00       ; main FORTH/system workspace
31    >FC20                   dskws   equ >FC20       ; disk workspace
32    >FC40                   intws   equ >FC40       ; interrupt workspace
33    >FC40                   xopws   equ >FC40       ; XOP workspace (shared, ints off)
34    >FC60                   vidws   equ >FC60       ; video & term workspace   ; shared by interrupts!
36    >FB00                   cpurambase equ >FB00    ; CPU RAM base for DSRs
37    >FF60                   sharedvarbase equ >FF60 ; where vars shared with FORTH are seen
38    >F700                   privvarbase equ >F700   ; where ROM private vars are stored
40                             #else
60    >FB70                       aorg    cpurambase + >70
61    >FB70                   vdplimit    bss 2       ; VDP memory size (this points to a location offset from V9938 bank 3 (>C000))
66    >FB40                       aorg    cpurambase + >40
68    >0001                   int1flag    equ >1
69    >0002                   int2flag    equ >2
70    >0004                   xop1flag    equ >4
72    >FB40                   intsfromA   bss 2
77    >FF60                       aorg    sharedvarbase
78                             
81    >FF60                   vintflags   bss 1       ; VDP interrupt flags
82    >0080                   nvblnk      equ >80     ;       1: suppress blink cursor and blank screen
83    >0040                   nvkeyscan   equ >40     ;       1: suppress scan keyboard
84    >0020                   nvsprmot    equ >20     ;       1: suppress sprite motion
85    >0010                   nsoundlist  equ >10     ;       1: suppress sound list
87    >FF61                   vstatus     bss 1       ; VDP status last read during interrupt
89    >FF62                   userint     bss 2       ; user VDP interrupt handler (called when VDP interrupts)
90    >FF64                   timerisr    bss 2       ; user timer handler (called when clock ticks)
92    >FF66                   nsprmot     bss 1       ; number of sprites in motion (00 = none)
94    >FF67                   sndflags    bss 1       ; sound list flags
95                                                    ;       $00: CPU RAM, $80: VDP 
96                                                    ;       $0f: tempo adjust (signed: -4 to 3) 
97    >FF68                   sndlist     bss 2       ; address of classic sound list (0 = none), incremented on tick
98    >FF6A                   snddur      bss 1       ; duration of current group
100   >FF6C                           even
101                                   
103   >FF6C                   _CPURAMSTART equ $
105   >FF6C                   vpob        bss 1       ; VDP "page offset" bank (added to V9938 bank to select the page outside 64k)
106   >FF6D                   vblinkflag  bss 1       ; flag to set blink bit in text2 
107   >FF6E                   vpgrow      bss 2       ; VDP "page row offset" (added to V9938 commands to select the page)
108   >FF70                   vtextpage   bss 2       ; VDP text-ish page offset (screen, patterns, colors) (in addition to vpob)
110   >FF72                   vidvarstart bss 2       ; start addr of important video variables
111   >FF74                   vidvarsize  bss 2       ; size of important video variables
113   >000A                   _CPURAMSIZE  equ $ - _CPURAMSTART
*** ram.i
30                             #if ENHANCED_MEMORY
31    >F700                       aorg    privvarbase      
32                             #else
35                                 
36    >0040                   vstacksize equ  >40
37    >F700                   vstack  bss vstacksize      ; video stack is stored here for speed in slow-mode
39                             #if ENHANCED_MEMORY
40                                ; keep going
41                             #else
44                             
45    >F740                   sysstack bss    >40         ; system stack
46    >0040                   sysstacksize equ $ - sysstack
48    >F780                   _RAMSTART equ $ 
50    >F780                   uptime	bss	4			; time in 1/60 seconds
51    >F784                   timeout	bss	2			; timeout counter
53    >F786                   _VIDVARSTART equ $
55    >F786                   vscreen	bss	2			; VDP addr of screen
56    >F788                   vscreensz	bss	2			; VDP size of screen table
57    >F78A                   vpatts	bss	2			; VDP addr of patterns
58    >F78C                   vpattsz	bss	2			; VDP size of pattern table
59    >F78E                   vcolors bss	2			; VDP addr of colors
60    >F790                   vcolorsz bss	2			; VDP size of color table
61    >F792                   vsprites bss	2			; VDP addr of sprites
62    >F794                   vsprcol bss 2           ; VDP addr of sprite color table (0 if not sprite 2 mode)
63    >F796                   vsprpat bss	2			; VDP addr of sprite patterns
64    >F798                   vsprmot	bss	2			; VDP addr of sprite motion
65    >F79A                   vfree	bss	2			; usable space
67    >F79C                   vdrawchar bss	2			; draw char in window (BLWP @)
68    >F79E                   vscroll	bss	2			; scroll window up a line (BLWP @)
69    >F7A0                   vclearline	bss	2			; clear line (BL @)  [R0=window coord, R2=length; preserve 0, 3]
71    >F7A2                   vbsize	bss	2			; bitmapped font size (x/y)
73    >F7A4                   vcoordaddr bss	2			; get SIT addr of R0 coord   [R0=window coord => R0=addr, R1=shift; 
74                                                        ;                               preserve R2]
76    >F7A6                   vcrstimer bss	1			; timer for blink
77    >F7A7                   vcrsblink bss	1			; limit in 1/60 s
78    >F7A8                   vcursor	bss	2			; cursor blinker (BLWP @)
79    >F7AA                   vcurs	bss	1			; cursor blink state (0 or >80)
81    >F7AB                   vcursunder bss	8	   	; char or bits under cursor
83    >F7B3                   vheight bss 1           ; phys screen height in chars
84    >F7B4                   vwidth  bss 2           ; phys screen width in chars
85    >F7B6                       even
86                                
87    >F7B6                   vbit4stride bss 2        ; row stride  
88    >F7B8                   vbit4shift bss 2        ; shift for column # to byte
89    >F7BA                   vbit4mask bss 2        ;  mask for column # to byte portion
91    >F7BC                   vfont	bss	2			; GROM font addr
95    >F7BE                   vfgbg	bss	2			; foreground|background color
96    >F7C0                   vch	bss	1			; current char
98    >F7C1                   vcurschar bss	1			; char of cursor
100   >F7C2                   vwx	bss	1			; window left
101   >F7C3                   vwy	bss	1			; window right
102   >F7C4                   vwxs	bss	1			; width of window
103   >F7C5                   vwys	bss	1			; height of window
104   >F7C6                   vwcy	bss	1			; last cleared row
106   >F7C7                   vmode	bss	1         ; last set video mode (not M_xxx)
108   >F7C8                       even
109   >F7C8                   vtermptr bss 2          ; pointer to standard term stuff for mode
110                               
111   >F7CA                   vx	bss	1			; x-coord of cursor in window
112   >F7CB                   vy	bss	1			; y-coord of cursor in window
114   >F7CC                   vmono	bss	1
115   >F7CD                   vidmode	bss	1			; what mode are we in?  (M_xxxx)
117   >0000                   M_text	equ	0
118   >0001                   M_graph	equ	1
119   >0002                   M_multi equ 2
120   >0003                   M_bit	equ	3			; both mono and color
121   >0004                   M_bit4	equ	4			; new bitmap modes
122   >0005                   M_text2 equ 5           ; 80-column
124   >F7CE                   vscrnx  bss 2           ; res x
125   >F7D0                   vscrny  bss 2           ; res y
127   >F7D2                   vlinex	bss	2
128   >F7D4                   vliney	bss	2
130   >F7D6                   savedvregs bss 16       ; first 16 VRs set via vwreg
131   >F7D7                   vregr1    equ savedvregs + 1           ; VDP register 1
133   >0060                   _VIDVARSIZE  equ $ - _VIDVARSTART
135   >F7E6                   vbitbuf bss 256         ; buffer for bitmap font manip
139   >F8E6                   kbdlast bss 1           ; last char pressed (or 0)
140   >F8E7                   kbdtimer bss    1           ; timer (1/60 s) since last repeat
142   >F8E8                   kbdscan bss 1           ; most recent scancode     (0-47)
143   >F8E9                   kbdshft bss 1           ; most recent shift status (>70)
145   >F8EA                   kbdhead bss 1           ; head of kbd buffer
146   >F8EB                   kbdtail bss 1           ; tail of kbd buffer  
147                                               ; head==tail => empty
149   >0020                   kbdbufsize equ  32
150   >F8EC                   kbdbuf  bss kbdbufsize          
152   >F90C                   kbdlimit bss    1           ; 1/60s before repeating
153   >F90D                   kbddelay bss    1           ; delay between keyscans
155   >F90E                   kbdflag bss 1           ; keyboard state
156                                                   ; | >80 = currently repeating bit
157                                                   
158   >F910                       even
160   >F910                   randnoise bss 2			; random noise
161   >F912                   randseed1 bss 2			; random seed (lfsr)
162   >F914                   randseed2 bss 2			; random seed
166   >0020                   dskstacksize 	equ	>20
167   >F916                   dskstack bss	dskstacksize
169   >F936                   forthdsk bss	10			; filename for FORTH disk
175   >0000                   pv_clock    equ 0           ; the clock for the voice (done when > 64k)
176   >0002                   pv_incr     equ 2           ; the increment per clock (0 = owned by other voice)
177   >0004                   pv_hertz    equ 4           ; the frequency of the voice
178   >0006                   pv_track    equ 6           ; the global track owning this voice (addr)
179   >0008                   pv_port     equ 8           ; the sound port
180   >000A                   pv_freqmask equ 10          ; sound command frequency mask for the voice
181   >000B                   pv_volmask  equ 11          ; sound command volume mask for the voice
182   >000C                   pv_size     equ 12
186   >0010                   NUMVOICES   equ 16
187   >F940                   voices      bss pv_size * NUMVOICES   ; 4 sets of 3 tones + 1 noise
188   >FA00                   VOICES_END equ $
192   >0000                   lt_cmdptr   equ 0           ; pointer to next command (start of lump)
193   >0002                   lt_clock    equ 2           ; accumulator timing til next lump (when > 64k)
194   >0004                   lt_incr     equ 4           ; clock increment for lump length
195   >0006                   lt_tempoincr equ 6          ; increment for current tempo
196   >0008                   lt_a_d      equ 8           ; attack, decay (byte)
197   >0009                   lt_h_r      equ 9           ; hold, release (byte)
198   >000A                   lt_volume   equ 10          ; current volume (byte)
199   >000B                   lt_sustain  equ 11          ; sustain ratio (when adhr != 0)
200   >000C                   lt_vibrato  equ 12          ; vibrato 
201   >000D                   lt_tremolo  equ 13          ; tremolo 
202   >000E                   lt_waveform equ 14          ; waveform 
203   >000F                   lt_balance  equ 15          ; balance
204   >0010                   lt_size     equ 16
208   >0008                   NUMTRACKS   equ 8
209   >FA00                   tracks      bss lt_size * NUMTRACKS
210   >FA80                   TRACKS_END  equ $
214   >0004                   MAXTRACKSPERSONG equ 4 
216   >0000                   ls_phrase   equ 0          ; pointer to current phrase
217   >0002                   ls_phrases  equ 2           ; ptr in zero-terminated array of phrases 
218   >0004                   ls_tracks   equ 4           ; map of logical tracks to global tracks
219   >0008                   ls_size     equ 4 + MAXTRACKSPERSONG
223   >0004                   NUMSONGS    equ 4
224   >FA80                   songs       bss ls_size * NUMSONGS
225   >FAA0                   SONGS_END   equ $
227   >FAA0                   _RAMEND     equ   $
229                            
*** nforth.tsm
97    >0000                   	aorg	>0
99    >0000                   resetv	dw	mainws,INT0PC		; vector for RESET
      >0000=>FC00 >000E       
100   >0004                   int1v	dw	intws,INT1PC		; vector for INTERRUPTS
      >0004=>FC40 >0018       
104   >000C                   	aorg	>c
106   >000C=>30AA             	db		>30,>AA				; flag bytes for normal ROM
108   >000E                   INT0PC:
109   >000E=>06A0 >004A       	bl		@bankA
110   >0012=>0000             	data	0
111   >0014=>0460 >2928       	b		@reset
113   >0018                   INT1PC:	
114   >0018=>0300 >0000       	limi	0
115   >001C=>06A0 >004A       	bl		@bankA
116   >0020=>0001             	data	int1flag
117   >0022=>0460 >0276       	b		@int1
119   >0026                   XOP1PC:
120   >0026=>0300 >0000       	limi	0
121   >002A=>C07E             	mov		*14+,1				; code
122   >002C=>C00B             	mov		11,0
123   >002E=>06A0 >004A       	bl		@bankA
124   >0032=>0004             	data	xop1flag
125   >0034=>C2C0             	mov		0,11
126   >0036=>0460 >00CA       	b		@xop1_real
128   >0040                   	aorg 	>40
130   >0040                   xop0v	dw 0,0
      >0040=>0000 >0000       
131   >0044                   xop1v	dw	xopws,XOP1PC			; vector for XOP 1
      >0044=>FC40 >0026       
133   >0048=>0000             	data	0					; forth_start
136   >004A                   BANK:
138   >004A                   bankA:
139   >004A=>E83B >FB40       	soc		*11+,@intsfromA
140   >004E=>0720 >FFC0       	seto	@ROMBANK
141   >0052=>045B             	rt
142   >0054                   bankB:
143   >0054=>0720 >FFC2       	seto	@FTHBANK
144   >0058=>045B             	rt
146   >005A                   bankBrtwp:
147   >005A=>06A0 >0054       	bl		@bankB
148   >005E=>0380             	rtwp
150   >0060                   FORTH_COLD:
151   >0060=>06A0 >0054       	bl		@bankB
152   >0064=>1000             	nop
153   >0066=>1000             	nop
155   >0068                   FORTH_QUIT:
156   >0068=>06A0 >0054       	bl		@bankB
157   >006C=>1000             	nop
158   >006E=>1000             	nop
161   >0070                   ABORT:
162   >0070=>0300 >0000           limi    0
163   >0074=>0720 >FB40           seto    @intsfromA
165   >0078=>02E0 >FC00           lwpi    mainws
166   >007C=>10F5                 jmp     FORTH_QUIT         ; ctrl+fctn+shift+space breaks
167                               
168   >007E                   COMMON_END:
170   >007E                   bankrtwp:
171   >007E=>C020 >FB40       	mov		@intsfromA,0
172   >0082=>203B             	coc		*11+,0
173   >0084=>16EA             	jne		bankBrtwp
174   >0086=>0380             	rtwp
211   >0088                   xop1list dw	xop1_restore_mode,xop1_key_avail,xop1_read_key,xop1_emit,xop1_emit_raw
      >0088=>00EA >00F0 >0108 
      >008E=>0110 >011A       
212   >0092=>0122 >012A >0130 	dw		xop1_gotoxy,xop1_clear_window,xop1_set_window,xop1_get_window,xop1_set_mode
      >0098=>013C >0146       
213   >009C=>014E >0156 >015C 	dw		xop1_set_fgbg,xop1_get_fgbg,xop1_draw_line,xop1_draw_pixel,xop1_reset_screen
      >00A2=>0162 >0168       
214   >00A6=>0172 >017E >0186 	dw		xop1_set_vintflags,xop1_set_font,xop1_fill_rect,xop1_random,xop1_dsrlnk
      >00AC=>018C >0194       
215   >00B0=>019E >01A8 >01B4 	dw      xop1_get_vtab,xop1_set_vdpreg,xop1_get_vdpreg,xop1_set_vrwpage,xop1_set_vpage
      >00B6=>01BE >01C6       
216   >00BA=>01CE >01D4 >01E2 	dw      xop1_reset_palette,xop1_video_state,xop1_get_text_addr,xop1_get_xy,xop1_type
      >00C0=>01F2 >01F8       
217   >00C4=>0202 >0208 >0210 	dw      xop1_rw_block,xop1_qtrack,xop1_draw_circle
218   >00CA                   xop1last equ $
224   >00CA                   xop1_real:
225   >00CA=>C2AD >0014       	mov @SP+SP(13), SP			; stack ptr
226   >00CE=>064A             	dect SP
227   >00D0=>C68C             	mov 12 , *SP
228   >00D2=>C30B             	mov 11 , 12				; copy op ptr
230   >00D4=>0281 >0021       	ci	1,(xop1last - xop1list) / 2
231   >00D8=>1204             	jle	xop1_pick
232   >00DA                   xop1_out
233   >00DA=>C33A             	mov *SP+, 12
234   >00DC=>06A0 >007E       	bl	@bankrtwp
235   >00E0=>0004             	data	xop1flag
237   >00E2                   xop1_pick
238   >00E2=>A041             	a	1,1
239   >00E4=>C061 >0088       	mov	@xop1list(1),1
240   >00E8=>0451             	b	*1
242                               ;   0 = restore video mode (minimal)
243   >00EA                   xop1_restore_mode
244   >00EA=>06A0 >04A0       	bl @vrestoremode
245   >00EE=>10F5             	jmp xop1_out
246                           	
247                           	;	1 = keyavail?
248   >00F0                   xop1_key_avail 
249   >00F0=>02E0 >FC60           lwpi    vidws
250   >00F4=>06A0 >18B6           bl  @scankbd
251   >00F8=>02E0 >FC40           lwpi    xopws
252   >00FC=>06A0 >1A0E       	bl	@kbdavail
253   >0100=>04DC             	clr	*12
254   >0102=>1301             	jeq xop1_1_out
255   >0104=>071C             	seto *12
256   >0106                   xop1_1_out
257   >0106=>10E9             	jmp xop1_out
259                           	;	2 = readkey
260   >0108                   xop1_read_key	
261   >0108=>06A0 >1A16       	bl	@kbdread
263   >010C=>C700             	mov	0,*12
264   >010E=>10E5             	jmp xop1_out
266                           	;	3 = emit (interpreted)
267   >0110                   xop1_emit
268   >0110=>D06C >0001       	movb   @1(12),1
269   >0114=>06A0 >1C50       	bl     @emit
270   >0118=>10E0             	jmp    xop1_out
272                           	;	4 = emit, not interpreted
273   >011A                   xop1_emit_raw
274   >011A=>C05C             	mov    *12,1
275   >011C=>06A0 >1AA4       	bl	    @printchar
276   >0120=>10DC             	jmp    xop1_out
278                           	; 	5 = gotoxy
279   >0122                   xop1_gotoxy
280   >0122=>C01C             	mov *12,0		; hi=x, lo=y
281   >0124=>06A0 >1ACE       	bl @gotoxy
282   >0128=>10D8             	jmp xop1_out
284                           	;	6 = cls (window)
285   >012A                   xop1_clear_window
286   >012A=>06A0 >1B2E           bl @termclear
287   >012E=>10D5             	jmp xop1_out
289                           	;	7 = text window
290                           	;	
291   >0130                   xop1_set_window
292   >0130=>C01C             	mov *12, 0
293   >0132=>C06C >0002       	mov @2(12), 1
294   >0136=>06A0 >1A50       	bl @window
295   >013A=>10CF             	jmp xop1_out
297                           	;	8 = report text window
298   >013C                   xop1_get_window
299   >013C=>CF20 >F7C2       	mov @vwx, *12+
300   >0140=>CF20 >F7C4       	mov @vwxs, *12+
301   >0144=>10CA             	jmp xop1_out
303                           	;	9 = graphics mode (ONLY)
304   >0146                   xop1_set_mode
305   >0146=>C05C             	mov *12, 1
306   >0148=>0420 >074C       	blwp @vsetmode
307   >014C=>10C6             	jmp xop1_out
309                           	;	10 = set colors
310   >014E                   xop1_set_fgbg:
311   >014E=>C01C             	mov *12, 0
312   >0150=>06A0 >0368       	bl @vsetcolor
313   >0154=>10C2             	jmp xop1_out
315                           	;	11 = get colors
316   >0156                   xop1_get_fgbg:
317   >0156=>C720 >F7BE       	mov @vfgbg, *12
318   >015A=>10BF             	jmp xop1_out
320                           	;	12 = draw line
321   >015C                   xop1_draw_line:
322   >015C=>0420 >0B6C       	blwp @line
323   >0160=>10BC             	jmp xop1_out
325                           	;	13 = draw pixel
326   >0162                   xop1_draw_pixel:
327   >0162=>0420 >0A6E       	blwp @pixel
328   >0166=>10B9             	jmp xop1_out
330                           	;	14 = reset video screen
331   >0168                   xop1_reset_screen:
332   >0168=>06A0 >0894           bl  @vreset
333   >016C=>06A0 >04E8           bl  @vscreenon
334   >0170=>10B4             	jmp xop1_out
336                           	;	15 = set video int flags (see vintflags)
337   >0172                   xop1_set_vintflags:
338                               ; ensure cursor is erased (usually indicates we're drawing)
339   >0172=>06A0 >0A58           bl     @vcursoroff
340   >0176=>D82C >0001 >FF60 	movb   @1(12), @vintflags
341   >017C=>10AE             	jmp    xop1_out
343                           	;	16 = set font
344   >017E                   xop1_set_font:
345   >017E=>C05C             	mov *12, 1
346   >0180=>06A0 >09DA       	bl @vsetfont
347   >0184=>10AA             	jmp xop1_out
349                           	;	17 = draw filled rect
350   >0186                   xop1_fill_rect:
351   >0186=>0420 >0AF2       	blwp @fillrect
352   >018A=>10A7             	jmp	xop1_out
354                           	;	18 = generate pseudorandom number
355   >018C                   xop1_random:
356   >018C=>06A0 >021A       	bl @random
357   >0190=>C700             	mov 0, *12
358   >0192=>10A3             	jmp xop1_out
360                           	;	19 = DSRLNK
361   >0194                   xop1_dsrlnk:
362   >0194=>C05C             	mov *12, 1
363   >0196=>0420 >1E00       	blwp @dsrlnk
364   >019A=>C700             	mov 0, *12
365   >019C=>109E             	jmp xop1_out
367                               ;   20 = get video table ( # -- addr )
368   >019E                   xop1_get_vtab:
369   >019E=>C05C                 mov *12, 1
370   >01A0=>06A0 >07AC           bl @vgettab
371   >01A4=>C700                 mov 0, *12
372   >01A6=>1037                 jmp xop1_out2
374                               ;   21 = set VDP reg ( newval index -- )
375   >01A8                   xop1_set_vdpreg:
376   >01A8=>C03C                 mov *12+, 0
377   >01AA=>0A80                 sla 0, 8
378   >01AC=>E01C                 soc *12, 0
379   >01AE=>06A0 >046A           bl @vwreg
380   >01B2=>1031                 jmp xop1_out2
382                               ;   22 = get VDP reg ( index -- val )
383   >01B4                   xop1_get_vdpreg:
384   >01B4=>C05C                 mov *12, 1
385   >01B6=>06A0 >0498           bl @vrreg    
386   >01BA=>C701                 mov 1, *12
387   >01BC=>102C                 jmp xop1_out2
389                               ;   23 = set r/w video page ( 0|1|2|3 -- val )
390   >01BE                   xop1_set_vrwpage:
391   >01BE=>C05C                 mov *12, 1
392   >01C0=>06A0 >03B0           bl @vrwpage
393   >01C4=>1028                 jmp xop1_out2
394                               
395                               ;   24 = set visible video page ( 0|1|2|3 -- val )
396   >01C6                   xop1_set_vpage:
397   >01C6=>C05C                 mov *12, 1
398   >01C8=>06A0 >03E8           bl @vpage
399   >01CC=>1024                 jmp xop1_out2
401                               ;   25 = reset palette
402   >01CE                   xop1_reset_palette:
403   >01CE=>06A0 >15F4           bl      @vsetpalette
404   >01D2=>1021                 jmp     xop1_out2
405                              
406                               ;   26 = save/restore/query video state   ( ... req -- ... )
407   >01D4                   xop1_video_state:
408   >01D4=>C05C                 mov     *12, 1
409   >01D6=>C0AC >0002           mov     @2(12), 2  ; if used
410   >01DA=>06A0 >0976           bl      @vsaverestore
411   >01DE=>C701                 mov     1, *12
412   >01E0=>101A                 jmp     xop1_out2
414                               ;   27 = get address of X/Y in window   ( x|y -- addr shift )
415   >01E2                   xop1_get_text_addr:
416   >01E2=>C01C                 mov     *12, 0
417   >01E4=>C060 >F7A4           mov     @vcoordaddr, 1
418   >01E8=>0691                 bl      *1
419   >01EA=>C700                 mov     0, *12
420   >01EC=>CB01 >0002           mov     1, @2(12)
421   >01F0=>1012                 jmp     xop1_out2
422                              
423                              ;    28 = get X/Y coords ( -- x|y )
424   >01F2                   xop1_get_xy:
425   >01F2=>C720 >F7CA           mov     @vx, *12
426   >01F6=>100F                 jmp     xop1_out2
427                              
428                              ;    29 = type (interpreted) ( caddr u -- )
429   >01F8                   xop1_type:
430   >01F8=>C0BC                 mov     *12+, 2
431   >01FA=>C0DC                 mov     *12, 3
432   >01FC=>06A0 >1C74           bl      @type
433   >0200=>100A                 jmp     xop1_out2
434                                  
435                               ;   30 = read/write disk block ( block# addr r/w -- err )
436   >0202                   xop1_rw_block:
437   >0202=>0420 >1F20           blwp @rwblock
438   >0206=>1007                 jmp xop1_out2
440                               ;   31 = queue sound track ( track -- )
441   >0208                   xop1_qtrack:
442   >0208=>C09C                 mov     *12, 2
443   >020A=>06A0 >2502           bl      @xsnd_queue_track
444   >020E=>1003                 jmp     xop1_out2
446                           	;	32 = draw circle
447   >0210                   xop1_draw_circle:
448   >0210=>0420 >0BC2       	blwp @circle
449   >0214=>1000             	jmp xop1_out2
451                               
452   >0216                   xop1_out2:
453   >0216=>0460 >00DA           b   @xop1_out
454   >021A                   random:
455   >021A=>C020 >F912       	mov    @randseed1, 0
456   >021E=>C040             	mov    0, 1
457   >0220=>0910             	srl    0, 1
458   >0222=>0241 >0001       	andi   1, 1
459   >0226=>0501             	neg    1
460   >0228=>0241 >B400       	andi   1, >B400
461   >022C=>2801             	xor    1, 0
462   >022E=>C800 >F912       	mov    0, @randseed1
464   >0232=>0202 >6FE5       	li     2, >6fe5
465   >0236=>38A0 >F914       	mpy    @randseed2, 2
466   >023A=>0225 >7AB9       	ai     5, >7ab9
467   >023E=>C805 >F914       	mov    5, @randseed2
469   >0242=>A020 >F780       	a	   @uptime, 0
470   >0246=>0B05             	src    5, 0
471   >0248=>2805             	xor    5, 0
472   >024A=>2820 >F910       	xor    @randnoise, 0
473   >024E=>045B             	rt
479   >0250                   clr mov     *11+, 0
      >0250=>C03B             
480   >0252=>C07B                 mov     *11+, 1
481   >0254                   $1: clr     *0+
      >0254=>04F0             
482   >0256=>0641                 dect    1
483   >0258=>15FD                 jgt     $1-
484   >025A=>045B                 rt
485                               
486   >025C                   sinit	
487   >025C=>020A >F780       	li SP,sysstack + sysstacksize
488                           	
489                           	; setup NMI interrupt
490   >0260=>C820 >29A8 >FFFC 	mov    #intws, @>fffc
491   >0266=>C820 >29AA >FFFE 	mov    #abort, @>fffe
493   >026C=>0200 >ACE1       	li     0, >ACE1
494   >0270=>C800 >F912       	mov    0,@randseed1
495                           	
496                               ;   reset clears all memory
497                           	;clr	   @uptime
498                           	;clr	   @uptime + 2
499                           	;clr	   @timeout
500                           	;clr	   @userint
501                           	;clr    @randseed2
502                           	;clr    @randnoise
504   >0274=>045B             	rt
507                           	incl	int.i
*** int.i
31    >0276                   int1 limi	0			; disable interrupts 
      >0276=>0300 >0000       
33    >027A=>04CC             	clr		r12			; point to 9901
34    >027C=>1F02             	tb		2			; VDP interrupt?
35    >027E=>160D             	jne		intvdp		; yup.
37    >0280=>1F03                 tb      3           ; timer interrupt?
38    >0282=>1306                 jeq     $1+         ; nope, must be device
40    >0284=>1D03                 sbo     3           ; acknowledge
41                                
42    >0286=>C0E0 >FF64           mov     @timerisr, 3 ; does user hook the timer?
43    >028A=>1302                 jeq     $1+
44                                
45    >028C=>0693                 bl      *3          ; call user handler
46    >028E=>1044                 jmp     int1out
48    >0290                   $1:     
49                                ; device interrupt (some other bit)
50                                  	
51    >0290=>02E0 >83E0       	lwpi	>83e0		; they require this...
52    >0294=>02E0 >FC40       	lwpi	intws
53    >0298=>103F             	jmp		int1out		; don't handle device interrupts yet
55    >029A                   intvdp:
56    >029A=>1D02             	sbo	    2			; acknowledge VDP interrupt
57                                
58    >029C=>05A0 >F782       	inc		@uptime + 2	; time in 1/60 seconds
59    >02A0=>1702             	jnc		intv00		; overflow?
60    >02A2=>05A0 >F780          	inc		@uptime	 	; more time accuracy
62    >02A6                   intv00:	
63    >02A6=>D0E0 >FF60           movb    @vintflags,3    ; check our commands
64    >02AA=>0A13                 sla     3,1             ; suppress blinking/blanking?
65    >02AC=>1810                 joc     intv01
67                                ; ----------------------- blink/blank
68                                    
69    >02AE=>05E0 >F784       	inct	@timeout	    ; blank screen?
70    >02B2=>1602             	jne		intv00b
72    >02B4=>06A0 >04E0       	bl     	@vscreenoff 
74    >02B8                   intv00b:
75    >02B8=>0200 >F7A6       	li		0,vcrstimer
76    >02BC=>B420 >01BB       	ab		#1,*0			; cursor timer
77    >02C0=>9810 >F7A7       	cb		*0,@vcrsblink	; to blink or not to blink?
78    >02C4=>1A04             	jl		intv01
80    >02C6=>7410             	sb		*0,*0			; clear
81    >02C8=>C020 >F7A8       	mov		@vcursor,0		; get ptr
82    >02CC=>0410             	blwp	*0				; blink it
84    >02CE                   intv01:
85    >02CE=>0A13                 sla     3,1             ; suppress keyboard scan?
86    >02D0=>1805                 joc     intv02
88                                ; ----------------------- keyboard scan
89                                
90    >02D2=>B820 >01BB >F8E7     ab      #1,@kbdtimer    ; inc repeat delay
91    >02D8=>06A0 >18B6           bl      @scankbd        ; get keyboard, save char       TRASHES REGS
93    >02DC                   intv02:
94    >02DC=>D0E0 >FF60           movb    @vintflags, 3   ; kbd trashed, so reread
95    >02E0=>0A33                 sla     3,3
96    >02E2=>1808                 joc     intv03          ; suppress sprite motion?
97                                
98    >02E4=>C020 >F798           mov     @vsprmot, 0
99    >02E8=>1305                 jeq     intv03          ; skip if no sprite motion table
100                               
101   >02EA=>D020 >FF66           movb    @nsprmot, 0     ; or no sprites
102   >02EE=>1302                 jeq     intv03
103                               
104   >02F0=>0420 >0CA4           blwp    @vspritemotion
105                               
106   >02F4                   intv03:
107   >02F4=>0A13                 sla     3,1
108   >02F6=>1805                 joc     intv04          ; sound list?
110                               ; ------------------------ play sound list
111                               
112   >02F8=>C020 >FF68           mov     @sndlist, 0
113   >02FC=>1302                 jeq     intv04
114                               
115   >02FE=>0420 >2088           blwp    @soundlist
116                               
117   >0302                   intv04:    
118   >0302=>0420 >24F4          blwp    @sound_sequencer
119                               
120                               ; ----------------------- user interrupt?
121                               
122   >0306=>C020 >FF62       	mov		@userint,0		
123   >030A=>1303             	jeq		intv05
125   >030C=>0690             	bl		*0				; execute user interrupt routine
126   >030E=>02E0 >FC40       	lwpi	intws
128   >0312                   intv05:
129                               ;movb    #>00, @VDPWA    ; point to SR0     ; the client must guarantee this
130                               ;movb    #>8f, @VDPWA
131   >0312=>D820 >FF82 >FF61 	movb	@VDPST, @vstatus ; clear interrupt
133   >0318                   int1out:
135   >0318=>06A0 >007E       	bl		@bankrtwp
136   >031C=>0001             	data	int1flag
138   >031E                   int2
139   >031E=>06A0 >007E       	bl		@bankrtwp
140   >0322=>0002             	data	int2flag
*** nforth.tsm
509                           	incl	video.i
*** video.i
30    >0324                   h08	byte	8
      >0324=>08             
31    >0325                   hunder	byte	"_"
      >0325=>5F             
32    >0326                   h07	data	7
      >0326=>0007             
33    >0328                   	even
38    >0328                   vinit	  PUSH    SP, 0, 11
*** <expansion of push>
1     >0328=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >032C=>CA80 >0002               mov  0 , @(2-0-1)*2(SP)
2     >0330=>C68B                     mov  11, @(2-1-1)*2(SP)
*** video.i
39                            	
40    >0332=>C820 >29AC >FF72 	mov    #_VIDVARSTART, @vidvarstart
41    >0338=>C820 >29AE >FF74 	mov    #_VIDVARSIZE, @vidvarsize
43    >033E=>0200 >000F       	li	   0,15
44    >0342=>C800 >F7A6       	mov	   0,@vcrstimer			 ; set up standard blink
45                            	;sb	   @vcurs,@vcurs		 ; it's off
47    >0346=>0201 >0107       	li	   1,>0107
48    >034A=>C801 >F7BE       	mov	   1,@vfgbg
50    >034E=>C820 >29B0 >F7A2     mov    #>808, @vbsize          ; set in case we lazily switch to bitmap mode
52    >0354=>04C1                 clr     1
53    >0356=>0420 >074C       	blwp   @vsetmode
54    >035A=>06A0 >0894       	bl     @vreset
55                            	;bl    @vrestoremode
56    >035E=>06A0 >04E8       	bl     @vscreenon
58                            	POP    SP, 0, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0362=>C2FA                     mov *SP+,  11
2     >0364=>C03A                     mov *SP+,  0 
*** video.i
59    >0366=>045B             	rt
62    >0368                   vsetcolor
63    >0368=>064A             	dect   SP
64    >036A=>C68B             	mov    11, *SP
65    >036C=>C800 >F7BE       	mov    0, @vfgbg
66                            	
67    >0370=>9820 >0019 >F7CD 	cb     #M_text,@vidmode
68    >0376=>1304             	jeq    vsetcolor1
69    >0378=>9820 >0226 >F7CD 	cb     #M_text2,@vidmode
70    >037E=>1608             	jne    vsetcolor0
72    >0380                   vsetcolor1:
73    >0380=>06A0 >0398           bl     @vgetcolorbyte
74    >0384=>06C0                 swpb   0
75    >0386=>0260 >0700       	ori    0,>700
76    >038A=>06A0 >046A       	bl     @vwreg
78    >038E=>1002             	jmp    vsetcolor9
80    >0390                   vsetcolor0:
81    >0390=>06A0 >082C       	bl     @vcolorsetup
82    >0394                   vsetcolor9:
83    >0394=>C2FA             	mov    *SP+, 11
84    >0396=>045B             	rt
87    >0398                   vgetcolorbyte
88    >0398=>04C0                 clr     0
89    >039A=>D020 >F7BE           movb    @vfgbg,0
90    >039E=>0A40                 sla     0,4
91    >03A0=>F020 >F7BF           socb    @vfgbg+1,0
92    >03A4=>045B                 rt
93                                
95    >03A6                   vgetfgcolorbyte
96    >03A6=>04C0                 clr     0
97    >03A8=>D020 >F7BE           movb    @vfgbg,0
98    >03AC=>0A40                 sla     0,4
99    >03AE=>045B                 rt
100                               
101                               
106   >03B0                   vrwpage PUSH SP,11
*** <expansion of push>
1     >03B0=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >03B2=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video.i
107   >03B4=>06A0 >0A58           bl      @vcursoroff
108   >03B8=>C081                 mov     r1 , r2
109   >03BA=>9820 >0014 >F7CD     cb     #M_bit4, @vidmode
110   >03C0=>1309                 jeq     vrwpage0
111                               
112                               ; text/graphics mode allows page access on 0x2000 boundaries
113   >03C2=>0AD1                 sla     r1, 13
114   >03C4=>C801 >FF70           mov     r1, @vtextpage
115   >03C8=>0A72                 sla     r2, 7
116   >03CA=>0242 >0400           andi    r2, >400
117   >03CE=>D802 >FF6C           movb    r2, @vpob 
118   >03D2=>1008                 jmp     vrwpageout
119                                
120   >03D4                   vrwpage0:
121   >03D4=>0A81                 sla     r1 , 8
122   >03D6=>C801 >FF6E           mov     r1 , @vpgrow       ; page row offset is 256 * page
123                               ; the page bank offset is this page row offset times bytes-per-line divided by 16k
124   >03DA=>38A0 >F7B6           mpy     @vbit4stride , r2   ; e.g. 256 * 1 , 128 * 1 ...
125   >03DE=>0A23                 sla     r3 , 2
126   >03E0=>D803 >FF6C           movb    r3 , @vpob
127   >03E4                   vrwpageout:    
128                               POP SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >03E4=>C2FA                     mov *SP+,  11
*** video.i
129   >03E6=>045B                 rt
130                                   
134   >03E8                   vpage PUSH SP,11
*** <expansion of push>
1     >03E8=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >03EA=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video.i
135   >03EC=>C001                 mov     r1 , r0
136   >03EE=>D2E0 >F7CD           movb    @vidmode, 11
137   >03F2=>92E0 >0014           cb     #M_bit4, 11
138   >03F6=>1320                 jeq     vpage0
139                               
140                               ; text/graphics mode allows page access on 0x2000 boundaries
141   >03F8=>0A30                 sla     0, 3
142   >03FA=>7000                 sb      0, 0
143   >03FC=>92E0 >0226           cb     #M_text2, 11
144   >0400=>1303                 jeq     vpage1
145   >0402=>0260 >0200           ori     0,>200
146   >0406=>101B                 jmp     vpageout
147                               
148   >0408                   vpage1:
149                               ; V9938 needs lower bits set
150   >0408=>0260 >0203           ori     0,>203
151   >040C=>06A0 >046A           bl      @vwreg
152                               
153                               ; move color table too (A00 away from screen)
154   >0410=>C001                 mov     1, 0
155   >0412=>0240 >0001           andi    0, 1
156   >0416=>0A70                 sla     0, 7
157   >0418=>0260 >032F           ori     0,>32f
158   >041C=>06A0 >046A           bl      @vwreg
159   >0420=>C001                 mov     1, 0
160   >0422=>0910                 srl     0, 1
161   >0424=>0260 >0A00           ori     0,>A00
162   >0428=>06A0 >046A           bl      @vwreg
163                               
164                               ; and move pattern table
165   >042C=>C001                 mov     1, 0
166   >042E=>0A20                 sla     0, 2
167   >0430=>05C0                 inct    0
168   >0432=>0260 >0400           ori     0,>400
169   >0436=>1003                 jmp     vpageout
170                                
171   >0438                   vpage0:    
172   >0438=>0A50                 sla     r0 , 5
173   >043A=>0260 >821F           ori     r0 , >821f
174   >043E                   vpageout:    
175   >043E=>06A0 >046A           bl      @vwreg
176                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0442=>C2FA                     mov *SP+,  11
*** video.i
177   >0444=>045B                 rt
189   >0446                   gwaddr	movb	0,@GPLWA
      >0446=>D800 >FF96       
190   >044A=>06C0             	swpb	0
191   >044C=>D800 >FF96       	movb	0,@GPLWA
192   >0450=>06C0             	swpb	0
193   >0452=>045B             	rt
201   >0454                   vwaddr	ori	0,>4000
      >0454=>0260 >4000       
202   >0458                   vraddr
203   >0458=>06C0             	swpb	0
204   >045A=>D800 >FF8A       	movb	0,@VDPWA
205   >045E=>06C0             	swpb	0
206   >0460=>D800 >FF8A       	movb	0,@VDPWA
207   >0464=>0240 >3FFF       	andi    0,>3fff
208   >0468=>045B             	rt
209                           	
212   >046A                   vwreg   
213   >046A=>064A                 dect    SP
214   >046C=>C681                 mov     1, *SP
215   >046E=>C040                 mov     0, 1
216   >0470=>0241 >7FFF           andi    1,>7FFF
217   >0474=>0260 >8000           ori     0,>8000
218   >0478=>06C0                 swpb    0
219   >047A=>0281 >0F00           ci      1,>0F00
220   >047E=>1403                 jhe     vwreg0
221   >0480=>0981                 srl     1,8
222   >0482=>D840 >F7D6           movb    0,@savedvregs(1)
223   >0486                   vwreg0:    
224   >0486=>D800 >FF8A           movb    0,@VDPWA
225   >048A=>06C0                 swpb    0
226   >048C=>D800 >FF8A           movb    0,@VDPWA
227   >0490=>C07A                 mov     *SP+,1
228   >0492=>045B                 rt
231   >0494                   vwregnext 
232   >0494=>C03B                 mov     *11+, 0
233   >0496=>10E9                 jmp     vwreg
234                               
240   >0498                   vrreg
241   >0498=>D061 >F7D6           movb    @savedvregs(1),1
242   >049C=>0981                 srl     1,8
243   >049E=>045B                 rt
244                               
248   >04A0                   vrestoremode
249   >04A0=>064A                 dect SP
250   >04A2=>C68B                 mov 11,*SP
251   >04A4=>020C >FF8A           li  12,VDPWA
252   >04A8=>0201 >F7D6           li  1, savedvregs
253   >04AC=>0200 >8000           li 0, >8000
254   >04B0                   vrm0 movb *1+, *12
      >04B0=>D731             
255   >04B2=>D700                 movb 0, *12
256   >04B4=>0220 >0100           ai 0, >100
257   >04B8=>0280 >8F00           ci 0, >8F00    
258   >04BC=>16F9                 jne  vrm0
259   >04BE=>06A0 >04E8           bl @vscreenon
260   >04C2=>C2FA                 mov *SP+,11
261   >04C4=>045B                 rt
269   >04C6                   vclr	dect SP
      >04C6=>064A             
270   >04C8=>C68B             	mov	11,*SP
271   >04CA=>064A             	dect SP
272   >04CC=>C682             	mov	2,*SP
275   >04CE=>06A0 >0454       	bl	@vwaddr
276   >04D2                   vclr0	movb	1,@VDPWD
      >04D2=>D801 >FF88       
277   >04D6=>0602             	dec	2
278   >04D8=>16FC             	jne	vclr0
279                           	
280   >04DA=>C0BA             	mov	*SP+,2
281   >04DC=>C2FA             	mov	*SP+,11
282   >04DE=>045B             	rt
302   >04E0                   vscreenoff
303   >04E0=>5820 >021F >F7D7 	szcb 	#>40,@vregr1
304   >04E6=>1003             	jmp	vreg1set
305   >04E8                   vscreenon
306   >04E8=>F820 >021F >F7D7 	socb	#>40,@vregr1
307   >04EE                   vreg1set:
308   >04EE=>D820 >F7D7 >FF8A 	movb	@vregr1,@VDPWA
309   >04F4=>D820 >00D5 >FF8A 	movb	#>81,@VDPWA
310   >04FA=>045B             	rt
314   >04FC                   vtmap	dw	vscreen,vscreensz,vcolors,vcolorsz,vpatts,vpattsz,vsprpat,vsprites,vsprmot,vsprcol,vfree
      >04FC=>F786 >F788 >F78E 
      >0502=>F790 >F78A >F78C 
      >0508=>F796 >F792 >F798 
      >050E=>F794 >F79A       
315   >0512=>F7CE >F7D0       	dw  vscrnx,vscrny
316   >001A                   vtmapsize equ $-vtmap
323   >0516                   vtxt db 0,>0,1,>B0,2,>0,4,>1,-1
      >0516=>0000 >01B0 >0200 
      >051C=>0401 >FF       
324   >0520=>0000 >03C0 >0000     dw  >0,960,>0,>0,>800,>800,0,0,0,0,>1000
      >0526=>0000 >0800 >0800 
      >052C=>0000 >0000 >0000 
      >0532=>0000 >1000       
325   >0536=>0100 >00C0           dw 256,192
326   >053A=>093A >2818 >0325     dw vtextterms, >2818, hunder
336   >0540                   vgfx 	db	0,>0,1,>A0,2,>0,3,>E,4,>1,5,>6,6,>0,-1
      >0540=>0000 >01A0 >0200 
      >0546=>030E >0401 >0506 
      >054C=>0600 >FF       
337   >0550=>0000 >0300 >0380 	dw	>0,768,>380,>20,>800,>800,>000,>300,>3A0,0,>1000
      >0556=>0020 >0800 >0800 
      >055C=>0000 >0300 >03A0 
      >0562=>0000 >1000       
338   >0566=>0100 >00C0       	dw 256,192
339   >056A=>093A >2018 >0325 	dw vtextterms, >2018, hunder
350   >0570                   vbit db	0,>2,1,>A0,2,>6,3,>ff,4,>03,5,>36,6,>3,-1
      >0570=>0002 >01A0 >0206 
      >0576=>03FF >0403 >0536 
      >057C=>0603 >FF       
351   >0580=>1800 >0300 >2000 	dw	>1800,>300,>2000,>1800,>0000,>1800,>1800,>1b00,>1B80,0,>3800
      >0586=>1800 >0000 >1800 
      >058C=>1800 >1B00 >1B80 
      >0592=>0000 >3800       
352   >0596=>0100 >00C0           dw 256,192
353   >059A=>0942 >2018 >0734     dw vbitterms, >2018,hff
366   >05A0                   vbit3  db  0,>4,1,>A0,2,>E,3,>ff,4,>03,5,>36,>B,0,6,>3,-1
      >05A0=>0004 >01A0 >020E 
      >05A6=>03FF >0403 >0536 
      >05AC=>0B00 >0603 >FF 
367   >05B2=>3800 >0300 >2000     dw  >3800,768,>2000,>1800,>0,>1800,>1800,>1b00,>1b80,>1900,>3B00
      >05B8=>1800 >0000 >1800 
      >05BE=>1800 >1B00 >1B80 
      >05C4=>1900 >3B00       
368   >05C8=>0100 >00C0           dw 256,192
369   >05CC=>0942 >2018 >0734     dw vbitterms, >2018, hff
370                               
371                               
380   >05D2                   vbit4  db  0,>6,1,>A0,2,>0,5,>F4,>B,0,6,>E,-1
      >05D2=>0006 >01A0 >0200 
      >05D8=>05F4 >0B00 >060E 
      >05DE=>FF             
381   >05E0=>0000 >0000 >0000     dw >0000,0,>0000,>0000,>0,>6400,>7000,>7A00,>7A80,>7800,>8000
      >05E6=>0000 >0000 >6400 
      >05EC=>7000 >7A00 >7A80 
      >05F2=>7800 >8000       
382   >05F6=>0100 >00D4           dw 256,212
383   >05FA=>0080 >0001 >FFFE     dw >80, 1, >FFFE
384   >0600=>094A >201B >0734     dw vbit4terms, >201B, hff
394   >0606                   vbit5  db  0,>8,1,>A0,2,>0,5,>F4,>B,0,6,>E,7,>FF,-1
      >0606=>0008 >01A0 >0200 
      >060C=>05F4 >0B00 >060E 
      >0612=>07FF >FF       
395   >0616=>0000 >0000 >0000     dw  >0000,0,>0000,>0000,>0,>6A00,>7000,>7A00,>7A80,>7800,>8000
      >061C=>0000 >0000 >6A00 
      >0622=>7000 >7A00 >7A80 
      >0628=>7800 >8000       
396   >062C=>0200 >00D4           dw 512,212
397   >0630=>0080 >0002 >FFFC     dw >80, 2, >FFFC
398   >0636=>0952 >401B >0734     dw vbit5terms, >401B, hff
408   >063C                   vbit6  db  0,>A,1,>A0,2,>0,5,>AC,>B,>1,6,>1B,-1
      >063C=>000A >01A0 >0200 
      >0642=>05AC >0B01 >061B 
      >0648=>FF             
409   >064A=>0000 >0000 >0000     dw  >0000,0,>0000,>0000,>0,>D400,>D800,>D600,>D680,>D400,>E000
      >0650=>0000 >0000 >D400 
      >0656=>D800 >D600 >D680 
      >065C=>D400 >E000       
410   >0660=>0200 >00D4           dw 512,212
411   >0664=>0100 >0001 >FFFE     dw >100, 1, >FFFE
412   >066A=>094A >401B >0734     dw vbit4terms, >401B, hff
422   >0670                   vbit7  db  0,>E,1,>A0,2,>0,5,>AC,>B,>1,6,>1B,-1
      >0670=>000E >01A0 >0200 
      >0676=>05AC >0B01 >061B 
      >067C=>FF             
423   >067E=>0000 >0000 >0000     dw  >0000,0,>0000,>0000,>0,>D400,>D800,>D600,>D680,>D400,>E000
      >0684=>0000 >0000 >D400 
      >068A=>D800 >D600 >D680 
      >0690=>D400 >E000       
424   >0694=>0100 >00D4           dw 256,212
425   >0698=>0100 >0000 >FFFF     dw >100, 0, >FFFF
426   >069E=>095A >201B >0734     dw vbit7terms, >201B, hff
434   >06A4                   vtxt2  db  0,>4,1,>B0,2,>0,3,>2f,>A,0,4,>2,>D,>22,-1
      >06A4=>0004 >01B0 >0200 
      >06AA=>032F >0A00 >0402 
      >06B0=>0D22 >FF       
435   >06B4=>0000 >0870 >0A00     dw  >0,2160,>A00,2160/8,>1000,>800,0,0,0,0,>1800
      >06BA=>010E >1000 >0800 
      >06C0=>0000 >0000 >0000 
      >06C6=>0000 >1800       
436   >06CA=>0200 >00D4           dw  512, 212
437   >06CE=>093A >501B >0325     dw vtextterms, >501B, hunder
438                               
448   >06D4                   vmonobit db 0,>2,1,>B0,2,>6,3,>80,4,>03,5,>36,6,>3,-1
      >06D4=>0002 >01B0 >0206 
      >06DA=>0380 >0403 >0536 
      >06E0=>0603 >FF       
449   >06E4=>1800 >0300 >2000     dw  >1800,>300,>2000,>800,>0000,>1800,>1800,>1B00,>1B80,0,>2800
      >06EA=>0800 >0000 >1800 
      >06F0=>1800 >1B00 >1B80 
      >06F6=>0000 >2800       
450   >06FA=>0100 >00C0           dw 256,192
451   >06FE=>0942 >2018 >0734     dw vbitterms, >2018, hff
460   >0704                   vmulti    db  0,>0,1,>8,2,>0,3,>0,4,>1,5,>6,6,>0,-1
      >0704=>0000 >0108 >0200 
      >070A=>0300 >0401 >0506 
      >0710=>0600 >FF       
461   >0714=>0000 >0300 >0000     dw  >0,768,0,0,>800,>800,>1000,>300,>380,0,>1800
      >071A=>0000 >0800 >0800 
      >0720=>1000 >0300 >0380 
      >0726=>0000 >1800       
462   >072A=>0100 >00C0           dw 256,192
463   >072E=>0962 >2018 >0325     dw vmultiterms, >2018, hunder
464                               
466   >0734                   hff db >ff
      >0734=>FF             
467   >0736                       even
468   >0736                   vmodesetups	
469   >0736=>0D56                 dw vtextsetup       ; 0
470   >0738=>0DA2                 dw vgraphsetup      ; 1
471   >073A=>0F1A                 dw vbitmapsetup     ; 2
472   >073C=>0F4E                 dw vbitmap3setup    ; 3
473   >073E=>1618                 dw vbitmap4setup    ; 4
474   >0740=>164A                 dw vbitmap5setup    ; 5
475   >0742=>1650                 dw vbitmap6setup    ; 6
476   >0744=>1656                 dw vbitmap7setup    ; 7
477   >0746=>0D78                 dw vtext2setup      ; 8
478   >0748=>0F42                 dw vmonosetup       ; 9
479   >074A=>0DC4                 dw vmultisetup      ; 10
484                            Vector vsetmode, vidws
*** <expansion of vector>
1     >074C                   vsetmode  data vidws, vsetmode_entry
      >074C=>FC60 >0750       
2     >0750                   vsetmode_entry:    
*** video.i
485   >0750=>020A >F740           li     SP,vstack + vstacksize 
486   >0754=>D06D >0003           movb   @3(13), 1
487   >0758=>D801 >F7C7           movb   1, @vmode
488   >075C=>0971             	srl    1, 7
489   >075E=>C061 >0736       	mov    @vmodesetups(1), 1
490   >0762=>0691             	bl     *1
492   >0764=>0380             	rtwp
495   >0766                   vsetupregs:
496   >0766=>064A                 dect SP
497   >0768=>C68B                 mov 11,*SP
498                               
499   >076A                   vts0 cb #>ff,*1
      >076A=>9460 >0467       
500   >076E=>1304                 jeq  vts1
501   >0770=>C031                 mov   *1+, 0
502   >0772=>06A0 >046A           bl  @vwreg
503   >0776=>15F9             	jgt	vts0
505   >0778                   vts1:
506   >0778=>05C1                 inct 1
508   >077A=>06A0 >0398           bl  @vgetcolorbyte
509   >077E=>06C0                 swpb 0
510   >0780=>0260 >0700           ori 0,>700
511   >0784=>06A0 >046A           bl @vwreg
513   >0788=>7820 >FF6C >FF6C     sb      @vpob, @vpob
514   >078E=>04E0 >FF6E           clr     @vpgrow
515   >0792=>04E0 >FF70           clr     @vtextpage
516                           	
517   >0796=>C2FA             	mov *SP+,11
518   >0798=>045B             	rt
521   >079A                   vsetupaddrs:
522   >079A=>0200 >04FC       	li	0,vtmap
523   >079E                   vsa1 mov *1+,3
      >079E=>C0F1             
524   >07A0=>C130             	mov	*0+,4
525   >07A2=>C503             	mov	3,*4
526   >07A4=>0280 >0516       	ci 0,vtmap + vtmapsize
527   >07A8=>11FA             	jlt	vsa1
528   >07AA=>045B             	rt
531   >07AC                   vgettab
532   >07AC=>A041                 a 1,1
533   >07AE=>C021 >04FC           mov @vtmap(1), 0
534   >07B2=>045B                 rt
535                               
536   >07B4                   vcleartables:
537   >07B4=>064A             	dect SP	
538   >07B6=>C68B             	mov 11,*SP
540                               ; don't clear patterns... font routines and/or vtermclear does that
541                               ;mov @vpatts, 0
542                               ;bl @vsetbank
543                               ;clr 1
544                               ;mov @vpattsz, 2
545                               ;bl @vclr
546   >07B8=>1002                 jmp vct0
547                               
548   >07BA                   vcleartables4x:
549   >07BA=>064A                 dect SP 
550   >07BC=>C68B                 mov 11,*SP
551   >07BE                   vct0:
552   >07BE=>06A0 >082C           bl @vcolorsetup
554   >07C2=>06A0 >15F4           bl @vsetpalette
555                               
556   >07C6                   vclrtabscr:    
557   >07C6=>C0A0 >F788           mov @vscreensz, 2
558   >07CA=>1306                 jeq vclrtabspr
559   >07CC=>C020 >F786           mov @vscreen, 0
560   >07D0=>0201 >2000           li 1,>2000
561   >07D4=>06A0 >04C6           bl @vclr
562                               
563   >07D8                   vclrtabspr:
564   >07D8=>C020 >F792       	mov	@vsprites,0
565   >07DC=>1325             	jeq vclrtabout
566                           	
567                           	; delete the sprites; $d0 for mode 1 and $d8 for mode 2
568   >07DE=>C060 >F794           mov @vsprcol, 1
569   >07E2=>1603                 jne vclrtabspr2
570   >07E4=>D060 >0110       	movb #>d0,1
571   >07E8=>100C                 jmp vclrtabsprs
572   >07EA                   vclrtabspr2:
574                               ; clear sprite color table too
575   >07EA=>C001                 mov 1, 0
576   >07EC=>04C1                 clr 1
577   >07EE=>0202 >0200           li 2,>200
578   >07F2=>06A0 >178C           bl @vsetbank
579   >07F6=>06A0 >04C6           bl @vclr
580   >07FA=>C020 >F792           mov @vsprites, 0
581   >07FE=>D060 >0176       	movb #>d8,1
582   >0802                   vclrtabsprs:
583   >0802=>06A0 >178C           bl @vsetbank
584   >0806=>06A0 >0454           bl  @vwaddr    
585   >080A=>D801 >FF8A           movb 1,@VDPWA
586   >080E=>0580             	inc 0
587   >0810=>04C1             	clr	1
588   >0812=>0202 >007F       	li	2,127
589   >0816=>06A0 >04C6       	bl	@vclr
591   >081A=>C020 >F798       	mov	@vsprmot,0
592                               ;bl @vsetbank       ; it'll be in the same page
593   >081E=>04C1             	clr	1
594   >0820=>0202 >0080       	li	2,128
595   >0824=>06A0 >04C6       	bl	@vclr
597   >0828                   vclrtabout:
598   >0828=>C2FA             	mov *SP+,11
599   >082A=>045B             	rt
604   >082C                   vcolorsetup
605   >082C=>C0A0 >F790           mov @vcolorsz, 2
606   >0830=>1313                 jeq vcolorsetup0
607   >0832=>064A                 dect SP
608   >0834=>C68B                 mov 11, *SP
609   >0836=>04C1                 clr 1
610   >0838=>9820 >0226 >F7CD     cb #M_text2, @vidmode
611   >083E=>1303                 jeq vcolorsetup1
612   >0840=>06A0 >0398           bl @vgetcolorbyte
613   >0844=>D040                 movb 0,1
614   >0846                   vcolorsetup1:    
615   >0846=>C020 >F78E           mov @vcolors,0
616   >084A=>A020 >FF70           a   @vtextpage, 0
617   >084E=>06A0 >178C           bl  @vsetbank
618   >0852=>06A0 >04C6           bl  @vclr
619   >0856=>C2FA                 mov *SP+, 11
620   >0858                   vcolorsetup0:   
621   >0858=>045B                 rt
627   >085A                   vtermsetup
628                               PUSH    SP,R11
*** <expansion of push>
1     >085A=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >085C=>C68B                     mov  R11, @(1-0-1)*2(SP)
*** video.i
629                               
630   >085E=>C060 >F7C8           mov     @vtermptr,1
631   >0862=>0200 >0932           li      0,vtermptrs
632   >0866=>C0F1                 mov     *1+,3
633   >0868                   vtts0:
634   >0868=>C0B0                 mov     *0+,2
635   >086A=>C4B3                 mov     *3+,*2
636   >086C=>0280 >093A           ci      0,vtermptrsend
637   >0870=>16FB                 jne     vtts0
638                               
639                               ; force window to full screen
640   >0872=>C811 >F7C4           mov     *1, @vwxs
641                               
642   >0876=>D0B1                 movb    *1+, 2
643   >0878=>0982                 srl     2,8
644   >087A=>C802 >F7B4           mov     2,@vwidth
645   >087E=>D831 >F7B3           movb    *1+, @vheight
646                               
647   >0882=>04E0 >F7C2           clr     @vwx
648   >0886=>04E0 >F7CA           clr     @vx
650                               ; get cursor char
651   >088A=>C0B1                 mov     *1+,2
652   >088C=>D812 >F7C1           movb    *2,@vcurschar
653                               
654                               POP     SP,R11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0890=>C2FA                     mov *SP+,  R11
*** video.i
655   >0892=>045B                 rt
662   >0894                   vreset
663                               PUSH SP,1,2,11    
*** <expansion of push>
1     >0894=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0898=>CA81 >0004               mov  1 , @(3-0-1)*2(SP)
2     >089C=>CA82 >0002               mov  2 , @(3-1-1)*2(SP)
3     >08A0=>C68B                     mov  11, @(3-2-1)*2(SP)
*** video.i
664                               
665   >08A2=>06A0 >085A           bl @vtermsetup
666   >08A6=>06A0 >07B4           bl  @vcleartables
667                               
668   >08AA=>D060 >F7CD           movb @vidmode,1
669   >08AE=>9060 >0019           cb   #M_text,1
670   >08B2=>1309                 jeq  vresettextish
671   >08B4=>9060 >0226           cb   #M_text2,1
672   >08B8=>1306                 jeq  vresettextish
673   >08BA=>9060 >0078           cb   #M_multi,1
674   >08BE=>1304                 jeq  vresetmulti
675   >08C0=>9060 >01BB           cb   #M_graph,1
676   >08C4=>1619                 jne  vreset0
678   >08C6                   vresettextish:    
679   >08C6=>102C                 jmp     vresetout
681   >08C8                   vresetmulti:
682                               ; setup standard SIT for multi mode
683                               ; 0 1 2 3 ... 30 31  x  4
684                               ; 32 33 ... 62 63    x 4
685                               ; ... 190 191
686   >08C8=>C020 >F786           mov     @vscreen,0      ; never banked
687   >08CC=>06A0 >0454           bl      @vwaddr
688   >08D0=>04C1                 clr     1
689   >08D2                   vbs4    li  2, 4 
      >08D2=>0202 >0004       
690   >08D6                   vbs3    movb 1,@VDPWD
      >08D6=>D801 >FF88       
691   >08DA=>0221 >0100           ai      1,>0100
692   >08DE=>2460 >29B2           czc     #>1f00, 1
693   >08E2=>16F9                 jne     vbs3
694   >08E4=>0221 >E000           ai      1,->2000
695   >08E8=>0602                 dec     2
696   >08EA=>15F5                 jgt     vbs3
697   >08EC=>0221 >2000           ai      1,>2000
698   >08F0=>0281 >C000           ci      1,>C000
699   >08F4=>1AEE                 jl      vbs4
700   >08F6=>1014                 jmp     vresetout
701                               
702   >08F8                   vreset0:    
703   >08F8=>9820 >0018 >F7CD     cb      #M_bit,@vidmode
704   >08FE=>160E                 jne     vreset1
705                               
706                               ; setup standard SIT for bitmap mode
707   >0900=>C020 >F786           mov     @vscreen,0      ; never banked
708   >0904=>06A0 >0454           bl      @vwaddr
709   >0908=>04C1                 clr     1
710   >090A=>0202 >0300           li      2,768
711   >090E                   vbs2    movb    1,@VDPWD
      >090E=>D801 >FF88       
712   >0912=>0221 >0100           ai      1,>100
713   >0916=>0602                 dec     2
714   >0918=>15FA                 jgt     vbs2
715                               
716   >091A=>1002                 jmp     vresetbitcommon
718   >091C                   vreset1:
719                               ; must be M_bit4
720                               
721   >091C=>06A0 >07BA           bl      @vcleartables4x
722                               
723   >0920                   vresetbitcommon:
724                                   
725   >0920                   vresetout:
726   >0920=>04C1                 clr     1
727   >0922=>06A0 >09DA           bl      @vsetfont
728   >0926=>06A0 >1B2E           bl      @termclear
729                               
730                               POP     SP,1,2,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >092A=>C2FA                     mov *SP+,  11
2     >092C=>C0BA                     mov *SP+,  2 
3     >092E=>C07A                     mov *SP+,  1 
*** video.i
731   >0930=>045B                 rt
733   >0932                   vtermptrs dw vdrawchar,vclearline,vcursor,vcoordaddr
      >0932=>F79C >F7A0 >F7A8 
      >0938=>F7A4             
734   >093A                   vtermptrsend equ $
736   >093A                   vtextterms dw vtextchar,vtextclearline,vtextcursor,vtextaddr
      >093A=>0E5E >0E1A >0ED0 
      >0940=>0DD0             
737   >0942                   vbitterms dw  vbitchar,vbitclearline,vbitcursor,vbitaddr
      >0942=>1010 >0F9A >1086 
      >0948=>0F6A             
738   >094A                   vbit4terms dw  vbit4xchar,vbit4xclearline,vbit4xcursor,vbit4xaddr
      >094A=>17B6 >175E >180C 
      >0950=>165C             
739   >0952                   vbit5terms dw  vbit4xchar,vbit4xclearline,vbit4xcursor,vbit4xaddr
      >0952=>17B6 >175E >180C 
      >0958=>165C             
740   >095A                   vbit7terms dw  vbit4xchar,vbit4xclearline,vbit4xcursor,vbit4xaddr
      >095A=>17B6 >175E >180C 
      >0960=>165C             
741   >0962                   vmultiterms dw vnopchar,vnopclearline,vnopcursor,vtextaddr
      >0962=>0F14 >0F18 >0F14 
      >0968=>0DD0             
744   >096A                   vstdmode
745                               ;clr     @vpob
746                               ;clr     @vpgrow
747                               ;clr     @vtextpage
748   >096A=>04E0 >F7B6           clr     @vbit4stride
749   >096E=>0200 >0900           li      0, >900      ; 192 rows
750   >0972=>0460 >046A           b       @vwreg       
760   >CCB1                   vsaverestore_s equ >ccb1    ; mov *1+, *2+
761   >CC72                   vsaverestore_r equ >cc72    ; mov *2+, *1+
763   >0976                   vsaverestore 
764   >0976=>C041                 mov     1, 1
765   >0978=>1322                 jeq     vsvrssz
767                               PUSH    SP,11,12  
*** <expansion of push>
1     >097A=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >097E=>CA8B >0002               mov  11 , @(2-0-1)*2(SP)
2     >0982=>C68C                     mov  12, @(2-1-1)*2(SP)
*** video.i
768   >0984=>0204 >CCB1           li      4, vsaverestore_s
769   >0988=>0281 >0001           ci      1, 1
770   >098C=>1302                 jeq     vsvrsrst
771   >098E=>0204 >CC72           li      4, vsaverestore_r
772   >0992                   vsvrsrst:    
773   >0992=>0201 >FF6C           li      1, _CPURAMSTART
774   >0996=>0203 >0005           li      3, (_CPURAMSIZE+1) / 2
775   >099A                   vsvrsrst0:  x 4
      >099A=>0484             
776   >099C=>0603                 dec     3
777   >099E=>15FD                 jgt     vsvrsrst0
778   >09A0=>0201 >F786           li      1, _VIDVARSTART
779   >09A4=>0203 >0030           li      3, (_VIDVARSIZE+1) / 2
780   >09A8                   vsvrsrst1:  x 4
      >09A8=>0484             
781   >09AA=>0603                 dec     3
782   >09AC=>15FD                 jgt     vsvrsrst1
783                               
784   >09AE=>0284 >CC72           ci      4, vsaverestore_r
785   >09B2=>1602                 jne     vsvrsrst2
787                               ;movb    @vmode, 1
788                               ;srl     1, 7
789                               ;mov     @vmodesetups(1), 1
790                               ;bl      *1
791                               
792   >09B4=>06A0 >04A0           bl      @vrestoremode
793                               
794   >09B8                   vsvrsrst2:    
795                               POP     SP,11,12
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >09B8=>C33A                     mov *SP+,  12
2     >09BA=>C2FA                     mov *SP+,  11 
*** video.i
796   >09BC=>045B                 rt
797                                       
798   >09BE                   vsvrssz:
799   >09BE=>0201 >000B           li      1, _CPURAMSIZE+1
800   >09C2=>0221 >0061           ai      1, _VIDVARSIZE+1
801   >09C6=>045B                 rt
802                               
804   >09C8                   vfonts dw vf_8x8, vf_6x8, vf_5x6
      >09C8=>09CE >09D2 >09D6 
806   >09CE                   vf_8x8 dw >0808, grom_font8x8
      >09CE=>0808 >0130       
807   >09D2                   vf_6x8 dw >0608, grom_font8x8
      >09D2=>0608 >0130       
808   >09D6                   vf_5x6 dw >0506, grom_font5x6
      >09D6=>0506 >0930       
816   >09DA                   vsetfont PUSH SP,11
*** <expansion of push>
1     >09DA=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >09DC=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video.i
817   >09DE=>A041                 a      r1,r1
818   >09E0=>C061 >09C8           mov    @vfonts(r1), r1
819                               
820   >09E4=>C831 >F7A2           mov    *1+, @vbsize
821   >09E8=>C011                 mov    *1, 0
822   >09EA=>C800 >F7BC           mov    0,@vfont
824   >09EE=>9820 >0018 >F7CD     cb     #M_bit, @vidmode
825   >09F4=>1316                 jeq    vsetfont1
826   >09F6=>9820 >0014 >F7CD     cb     #M_bit4, @vidmode
827   >09FC=>1312                 jeq    vsetfont1
828                               
829   >09FE                   vsetfont0:
830   >09FE=>06A0 >0446           bl      @gwaddr
832   >0A02=>C020 >F78A           mov     @vpatts, 0
833   >0A06=>A020 >FF70           a       @vtextpage, 0
834   >0A0A=>06A0 >178C           bl      @vsetbank
835   >0A0E=>06A0 >0454           bl      @vwaddr
837   >0A12=>0202 >0800           li      2,>800
838   >0A16                   vgf1 movb   @GPLRD,@VDPWD
      >0A16=>D820 >FF90 >FF88 
839   >0A1C=>0602                 dec     2
840   >0A1E=>15FB                 jgt     vgf1
842   >0A20=>1019                 jmp     vsetfont2
844   >0A22                   vsetfont1:    
845                               ; reset the maximum vwidth/vheight
846   >0A22=>04C0                 clr    0
847   >0A24=>C060 >F7CE           mov    @vscrnx, 1
848   >0A28=>D0A0 >F7A2           movb   @vbsize, 2
849   >0A2C=>0982                 srl    2, 8
850   >0A2E=>3C02                 div    2, 0
851   >0A30=>C800 >F7B4           mov    0, @vwidth
853   >0A34=>04C0                 clr    0
854   >0A36=>C060 >F7D0           mov    @vscrny, 1
855   >0A3A=>D0A0 >F7A3           movb   @vbsize+1, 2
856   >0A3E=>0982                 srl    2, 8
857   >0A40=>3C02                 div    2, 0
858                               
859                               ; add extra row if we can see at least half the character (slack for 212-line modes)
860   >0A42=>A041                 a      1, 1
861   >0A44=>8081                 c      1, 2
862   >0A46=>1A01                 jl     vsetfont1b
863   >0A48=>0580                 inc    0
864   >0A4A                   vsetfont1b    
865   >0A4A=>06C0                 swpb   0
866   >0A4C=>D800 >F7B3           movb   0, @vheight
867                               
868   >0A50=>06A0 >1A3A           bl      @treset
870   >0A54                   vsetfont2:    
871                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0A54=>C2FA                     mov *SP+,  11
*** video.i
872   >0A56=>045B                 rt
874                               
883   >0A58                   vcursoroff
884   >0A58=>9820 >F7AA >0019 	cb	   @vcurs,#00
885   >0A5E=>1306             	jeq	   vcursisoff
886   >0A60=>064A             	dect   SP
887   >0A62=>C680             	mov	   0,*SP
888                           	;movb   #>80,@vcurs		; force an "off" next time
889   >0A64=>C020 >F7A8       	mov	   @vcursor,0
890   >0A68=>0410             	blwp   *0
891   >0A6A=>C03A             	mov	   *SP+,0
892   >0A6C                   vcursisoff	rt
      >0A6C=>045B             
899                            Vector pixel, vidws
*** <expansion of vector>
1     >0A6E                   pixel  data vidws, pixel_entry
      >0A6E=>FC60 >0A72       
2     >0A72                   pixel_entry:    
*** video.i
900   >0A72=>0300 >0000           limi    0
901   >0A76=>020A >F740           li      SP,vstack + vstacksize
903   >0A7A=>C32D >0018           mov     @24(13), 12
904                               
905   >0A7E=>06A0 >0A84           bl      @vpixel
906                               
907   >0A82=>0380                 rtwp
908                               
910   >0A84                   vpixel:
911                               PUSH    SP,4,9,11
*** <expansion of push>
1     >0A84=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0A88=>CA84 >0004               mov  4 , @(3-0-1)*2(SP)
2     >0A8C=>CA89 >0002               mov  9 , @(3-1-1)*2(SP)
3     >0A90=>C68B                     mov  11, @(3-2-1)*2(SP)
*** video.i
912                               
913   >0A92=>9820 >0014 >F7CD     cb      #M_bit4,@vidmode
914   >0A98=>130F                 jeq     vbpcont4
915                               
916   >0A9A=>9820 >0018 >F7CD     cb      #M_bit,@vidmode
917   >0AA0=>1624                 jne     vbpout
919   >0AA2                   vbpcont:
920                               PUSH    SP, 12
*** <expansion of push>
1     >0AA2=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0AA4=>C68C                     mov  12, @(1-0-1)*2(SP)
*** video.i
921   >0AA6=>C0AC >0002           mov     @2(12), 2
922   >0AAA=>C06C >0004           mov     @4(12), 1
923   >0AAE=>C31C                 mov     *12, 12
924                               
925   >0AB0=>06A0 >126A           bl      @vbl_drawpixel
927                               POP     SP, 12
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0AB4=>C33A                     mov *SP+,  12
*** video.i
928   >0AB6=>1019                 jmp     vbpout
930   >0AB8                   vbpcont4:
931   >0AB8=>06A0 >16A2           bl      @vcmdsetup
932   >0ABC=>0024                 data    >24             ; -> DX
933                               
934   >0ABE=>C02C >0004           mov     @4(12), 0
935   >0AC2=>06A0 >1698           bl      @vcoordsend
936   >0AC6=>C02C >0002           mov     @2(12), 0
937   >0ACA=>06A0 >1698           bl      @vcoordsend
938                               
939   >0ACE=>06A0 >0494           bl      @vwregnext
940   >0AD2=>112C                 data    >112c        ; -> CLR
941   >0AD4=>D52C >0001           movb    @1(12), *4     ; CLR
943   >0AD8=>D520 >0019           movb    #00, *4         ; ARG 
945   >0ADC=>0209 >5000           li      9, >5000        ; PSET
946   >0AE0=>5720 >0255           szcb    #>f0, *12
947   >0AE4=>F25C                 socb    *12, 9           ; OP
948   >0AE6=>06A0 >173E           bl      @vbit4xsetupMMMcommand
950   >0AEA                   vbpout:    
951                               POP     SP,4,9,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0AEA=>C2FA                     mov *SP+,  11
2     >0AEC=>C27A                     mov *SP+,  9 
3     >0AEE=>C13A                     mov *SP+,  4 
*** video.i
952   >0AF0=>045B                 rt
953                               
958                            Vector fillrect, vidws
*** <expansion of vector>
1     >0AF2                   fillrect  data vidws, fillrect_entry
      >0AF2=>FC60 >0AF6       
2     >0AF6                   fillrect_entry:    
*** video.i
959   >0AF6=>0300 >0000           limi    0
960   >0AFA=>020A >F740           li      SP,vstack + vstacksize
962   >0AFE=>C2AD >0018           mov     @24(13), 10
963                               
964   >0B02=>9820 >F7CD >0014     cb      @vidmode, #M_bit4
965   >0B08=>131B                 jeq     fr4x
966                               
967   >0B0A=>9820 >F7CD >0018     cb      @vidmode, #M_bit
968   >0B10=>162C                 jne     frout
970   >0B12=>C0AA >0006           mov     @6(10), 2       ; Y
971   >0B16=>C06A >0008           mov     @8(10), 1       ; X
972   >0B1A=>06A0 >1230           bl      @vbl_getaddr    ; R0= addr, R1=shift
973                               
974   >0B1E=>C22A >0002           mov     @2(10), 8       ; H
975   >0B22=>C0AA >0004           mov     @4(10), 2       ; W
976                               
977                               ; only fg honored, not op
978   >0B26=>C31A                 mov     *10, 12         ; op|c 
979   >0B28=>0ACC                 sla     12, 12
980   >0B2A=>F320 >F7BF           socb    @vfgbg+1, 12
981                               
982   >0B2E=>06CC                 swpb    12
983   >0B30=>D320 >0467           movb    #>FF,12
985   >0B34=>C100                 mov     0,4
986   >0B36=>0241 >0007           andi    1,7
988   >0B3A=>06A0 >1482           bl      @vbitfillrect
989   >0B3E=>0380                 rtwp
990                               
991   >0B40                   fr4x:
992   >0B40=>06A0 >16A2           bl      @vcmdsetup
993   >0B44=>0024                 data    >24
994                               
995   >0B46=>C04A                 mov     10, 1
996   >0B48=>05C1                 inct    1               ; skip color
997   >0B4A=>0611                 dec     *1              ; convert end-coord relative offset to real width/height
998   >0B4C=>0621 >0002           dec     @2(1)           ; ... again
999   >0B50=>04C2                 clr     2
1000  >0B52=>06A0 >1850           bl      @vbitsetupDXDYNXNYsigned
1002  >0B56=>D52A >0001           movb    @1(10), *4      ; CLR
1004  >0B5A=>D502                 movb    2, *4           ; ARG (dix=0, diy=0, mxc=0)
1006  >0B5C=>0209 >8000           li      9, >8000        ; LMMV
1007  >0B60=>56A0 >0255           szcb    #>f0, *10
1008  >0B64=>F25A                 socb    *10, 9          ; OP
1009  >0B66=>06A0 >173E           bl      @vbit4xsetupMMMcommand
1010                              
1011  >0B6A                   frout:    
1012  >0B6A=>0380                 rtwp
1019                           Vector line, vidws
*** <expansion of vector>
1     >0B6C                   line  data vidws, line_entry
      >0B6C=>FC60 >0B70       
2     >0B70                   line_entry:    
*** video.i
1020  >0B70=>0300 >0000           limi    0
1021  >0B74=>020A >F740           li      SP,vstack + vstacksize
1023  >0B78=>C32D >0018           mov     @24(13), 12
1024                              
1025  >0B7C=>9820 >F7CD >0014     cb     @vidmode, #M_bit4
1026  >0B82=>1306                 jeq     ln4x
1027                              
1028  >0B84=>9820 >F7CD >0018     cb     @vidmode, #M_bit
1029  >0B8A=>161A                 jne     lnout
1030                              
1031  >0B8C=>0460 >10F2           b       @vbitline
1032                              
1033  >0B90                   ln4x:
1034  >0B90=>06A0 >16A2           bl      @vcmdsetup
1035  >0B94=>0024                 data    >24
1036                              
1037  >0B96=>C04C                 mov     12, 1
1038  >0B98=>05C1                 inct    1       ; skip color
1039  >0B9A=>0202 >8000           li      2, >8000    ; LINE mode
1040                              
1041                              ; convert X2,Y2 to X2-X1, Y2-Y1
1042  >0B9E=>6461 >0004           s       @4(1), *1
1043  >0BA2=>6861 >0006 >0002     s       @6(1), @2(1)
1044  >0BA8=>06A0 >1850           bl      @vbitsetupDXDYNXNYsigned
1046  >0BAC=>D52C >0001           movb    @1(12), *4     ; CLR
1048  >0BB0=>D502                 movb    2, *4           ; ARG (dix=0, diy=0, mxc=0)
1050  >0BB2=>0209 >7000           li      9, >7000        ; LINE
1051  >0BB6=>5720 >0255           szcb    #>f0, *12
1052  >0BBA=>F25C                 socb    *12, 9          ; OP
1053  >0BBC=>06A0 >173E           bl      @vbit4xsetupMMMcommand
1054                              
1055  >0BC0                   lnout:    
1056  >0BC0=>0380                 rtwp
1062                           Vector circle, vidws
*** <expansion of vector>
1     >0BC2                   circle  data vidws, circle_entry
      >0BC2=>FC60 >0BC6       
2     >0BC6                   circle_entry:    
*** video.i
1063  >0BC6=>0300 >0000           limi    0
1064  >0BCA=>020A >F740           li      SP,vstack + vstacksize
1066  >0BCE=>C32D >0018           mov     @24(13), 12
1067                              
1068  >0BD2=>C04C                 mov     12, 1
1069                              
1070  >0BD4=>C23C                 mov     *12+, 8     ; color
1071  >0BD6=>C1FC                 mov     *12+, 7     ; R / p / y
1072  >0BD8=>C17C                 mov     *12+, 5     ; cy
1073  >0BDA=>C13C                 mov     *12+, 4     ; cx
1074                              
1075  >0BDC=>0209 >0005           li      9, 5
1076  >0BE0=>0A27                 sla     7, 2
1077  >0BE2=>6247                 s       7, 9
1078  >0BE4=>0829                 sra     9, 2        ; P = (5/4) R
1079  >0BE6=>0827                 sra     7, 2
1080                              
1081  >0BE8=>04C6                 clr     6           ; x
1083  >0BEA=>06A0 >0C12           bl      @circlePoints
1084                              
1085  >0BEE                   ccloop:
1086  >0BEE=>81C6                 c       6, 7
1087  >0BF0=>140F                 jhe     ccout
1089  >0BF2=>0586                 inc     6
1090  >0BF4=>C249                 mov     9, 9
1091  >0BF6=>1106                 jlt     ccneg
1092                              
1093  >0BF8=>0607                 dec     7
1094                              
1095  >0BFA=>C006                 mov     6, 0
1096  >0BFC=>6007                 s       7, 0
1097  >0BFE=>A000                 a       0, 0
1098  >0C00=>A240                 a       0, 9
1099                              
1100  >0C02=>1002                 jmp     ccnext
1102  >0C04                   ccneg:
1103  >0C04=>A246                 a       6, 9
1104  >0C06=>A246                 a       6, 9
1106  >0C08                   ccnext:
1107  >0C08=>0589                 inc     9
1108                              
1109  >0C0A=>06A0 >0C12           bl      @circlePoints
1110  >0C0E=>10EF                 jmp     ccloop
1111                              
1112  >0C10                   ccout:
1113  >0C10=>0380                 rtwp    
1121  >0C12                   circlePoints 
1122                              PUSH    SP,11,12,13,14,15
*** <expansion of push>
1     >0C12=>022A >FFF6           ai SP, -5*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0C16=>CA8B >0008               mov  11 , @(5-0-1)*2(SP)
2     >0C1A=>CA8C >0006               mov  12 , @(5-1-1)*2(SP)
3     >0C1E=>CA8D >0004               mov  13 , @(5-2-1)*2(SP)
4     >0C22=>CA8E >0002               mov  14 , @(5-3-1)*2(SP)
5     >0C26=>C68F                     mov  15, @(5-4-1)*2(SP)
*** video.i
1123                              
1124  >0C28=>02AC                 STWP    12 
1125  >0C2A=>022C >001A           ai      12, 13*2
1127  >0C2E=>C348                 mov     8, 13       ; R13=color, R14=Y, R15=X    
1134  >0C30=>C3C4                 mov     4, 15
1135  >0C32=>A3C6                 a       6, 15
1136  >0C34=>C385                 mov     5, 14
1137  >0C36=>A387                 a       7, 14
1138  >0C38=>06A0 >0A84           bl      @vpixel     ; cx+x, cy+y        ; 0 0
1140  >0C3C=>C3C4                 mov     4, 15
1141  >0C3E=>63C6                 s       6, 15
1142  >0C40=>C385                 mov     5, 14
1143  >0C42=>6387                 s       7, 14
1144  >0C44=>06A0 >0A84           bl      @vpixel     ; cx-x, cy-y        ; 1 1
1146  >0C48=>81C6                 c       6, 7
1147  >0C4A=>131A                 jeq     cptseq     ; x == y    
1148                              
1149  >0C4C=>C3C4                 mov     4, 15
1150  >0C4E=>A3C7                 a       7, 15
1151  >0C50=>C385                 mov     5, 14
1152  >0C52=>A386                 a       6, 14
1153  >0C54=>06A0 >0A84           bl      @vpixel     ; cx+y, cy+x        ; 0 0
1154                              
1155  >0C58=>C3C4                 mov     4, 15
1156  >0C5A=>63C7                 s       7, 15
1157  >0C5C=>C385                 mov     5, 14
1158  >0C5E=>6386                 s       6, 14
1159  >0C60=>06A0 >0A84           bl      @vpixel     ; cx-y, cy-x        ; 1 1
1160                              
1161  >0C64=>C186                 mov     6, 6
1162  >0C66=>1318                 jeq     cptsout     ; x == 0
1163                              
1164  >0C68=>C3C4                 mov     4, 15
1165  >0C6A=>A3C7                 a       7, 15
1166  >0C6C=>C385                 mov     5, 14
1167  >0C6E=>6386                 s       6, 14
1168  >0C70=>06A0 >0A84           bl      @vpixel     ; cx+y, cy-x        ; 0 1
1169                              
1170  >0C74=>C3C4                 mov     4, 15
1171  >0C76=>63C7                 s       7, 15
1172  >0C78=>C385                 mov     5, 14
1173  >0C7A=>A386                 a       6, 14
1174  >0C7C=>06A0 >0A84           bl      @vpixel     ; cx-y, cy+x        ; 1 0
1176  >0C80                   cptseq:
1177                              
1178  >0C80=>C3C4                 mov     4, 15
1179  >0C82=>A3C6                 a       6, 15
1180  >0C84=>C385                 mov     5, 14
1181  >0C86=>6387                 s       7, 14
1182  >0C88=>06A0 >0A84           bl      @vpixel     ; cx+x, cy-y        ; 0 1
1184  >0C8C=>C3C4                 mov     4, 15
1185  >0C8E=>63C6                 s       6, 15
1186  >0C90=>C385                 mov     5, 14
1187  >0C92=>A387                 a       7, 14
1188  >0C94=>06A0 >0A84           bl      @vpixel     ; cx-x, cy+y        ; 1 0
1189                              
1190  >0C98                   cptsout:    
1191                              POP     SP,11,12,13,14,15
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0C98=>C3FA                     mov *SP+,  15
2     >0C9A=>C3BA                     mov *SP+,  14 
3     >0C9C=>C37A                     mov *SP+,  13 
4     >0C9E=>C33A                     mov *SP+,  12 
5     >0CA0=>C2FA                     mov *SP+,  11 
*** video.i
1192  >0CA2=>045B                 rt
1211                           Vector  vspritemotion, vidws
*** <expansion of vector>
1     >0CA4                   vspritemotion  data vidws, vspritemotion_entry
      >0CA4=>FC60 >0CA8       
2     >0CA8                   vspritemotion_entry:    
*** video.i
1212  >0CA8=>020A >F740           li     SP,vstack + vstacksize 
1214  >0CAC=>D160 >FF66           movb    @nsprmot, 5
1215  >0CB0=>1601                 jne     $1+
1216                              
1217  >0CB2=>0380                 rtwp
1219  >0CB4                   $1:    
1220  >0CB4=>0985                 srl     5, 8
1221                              
1222  >0CB6=>C020 >F798           mov     @vsprmot, 0
1223  >0CBA=>C180                 mov     0, 6
1224  >0CBC=>61A0 >F792           s       @vsprites, 6    ; R6 = delta to sprites
1225                              
1226  >0CC0=>06A0 >178C           bl      @vsetbank
1227                              
1228  >0CC4=>C100                 mov     0, 4
1229                              
1230  >0CC6=>020C >FF80           li      12, VDPRD
1231  >0CCA=>0209 >FF8A           li      9, VDPWA
1232  >0CCE=>0208 >D000           li      8, >D000        ; boundary Y coord
1233                              
1234  >0CD2=>C020 >F7B6           mov     @vbit4stride, 0
1235  >0CD6=>1302                 jeq     vsm_loop
1236                              
1237  >0CD8=>0208 >D800           li      8, >D800        ; ... for V9938 modes
1238                              
1239  >0CDC                   vsm_loop:
1240  >0CDC=>D660 >FC69           movb    @vidws+9, *9
1241  >0CE0=>D644                 movb    4, *9       ; get sprite motion entry
1242                              
1243  >0CE2=>D05C                 movb    *12, 1      ; Y-motion
1244  >0CE4=>06C1                 swpb    1
1245  >0CE6=>D05C                 movb    *12, 1      ; X-motion
1246                              
1247  >0CE8=>C041                 mov     1, 1        ; any motion?
1248  >0CEA=>1330                 jeq     vsm_next
1249                              
1250  >0CEC=>D0DC                 movb    *12, 3      ; Y-frac
1251  >0CEE=>D09C                 movb    *12, 2      ; X-frac
1253  >0CF0=>C004                 mov     4, 0
1254  >0CF2=>6006                 s       6, 0
1255  >0CF4=>D660 >FC61           movb    @vidws+1, *9
1256  >0CF8=>D640                 movb    0, *9       ; get sprite coords
1257                              
1258  >0CFA=>06C3                 swpb    3
1259  >0CFC=>D0DC                 movb    *12, 3      ; Y|y
1260  >0CFE=>06C2                 swpb    2
1261  >0D00=>D09C                 movb    *12, 2      ; X|x
1262                              
1263                              ; R2 = X|x coord, R3 = Y|y coord, R1 = x|y motion
1264                              
1265  >0D02=>D1C1                 movb    1, 7
1266  >0D04=>0887                 sra     7, 8        ; sign extend
1267  >0D06=>0A47                 sla     7, 4        ; 1/16 pixel per 1/60 second        
1268  >0D08=>A087                 a       7, 2        ; add motion for X
1270  >0D0A=>06C1                 swpb    1
1271  >0D0C=>0881                 sra     1, 8        ; sign extend
1272  >0D0E=>0A41                 sla     1, 4        ; 1/16 pixel per 1/60 second        
1273  >0D10=>A0C1                 a       1, 3        ; add motion for Y
1274                              
1275                              ; Check for Y coordinate in bad range.
1276                              ;
1277                              ; The original idea was:
1278                              ;
1279                              ;   If we moved down to $D0 (or more), then bump by $10.
1280                              ;   If we moved up to $DF (or less), then bump by -$10.
1281                              ;   
1282                              ; We need to apply consistent movement, though, so we
1283                              ; can't just notice when a sprite happens to be in the
1284                              ; range -- we may have a kind of movement that sometimes
1285                              ; hits this range and sometimes doesn't.  Moving a whole 16
1286                              ; pixels in some cases and not others would be too noticeable.
1287                              ;
1288                              ; Instead, just check for the same coordinate and 
1289                              ; bump one pixel in the intended direction.
1290                              ;
1291                              ; TODO: further tweaks with the fraction
1292                              
1293  >0D12=>90C8                 cb      8, 3     
1294  >0D14=>1607                 jne     $2+         ; at delete coordinate? 
1295                              
1296  >0D16=>C041                 mov     1, 1        ; which direction?
1297  >0D18=>1103                 jlt     $1+
1298                              
1299  >0D1A=>B0E0 >01BB           ab      #>1, 3      ; moved down, go further 
1300  >0D1E=>1002                 jmp     $2+
1301                              
1302  >0D20                   $1:
1303  >0D20=>70E0 >01BB           sb      #>1, 3      ; moved up, go further
1304                              
1305  >0D24                   $2:
1306  >0D24=>0260 >4000           ori     0, >4000
1307  >0D28=>D660 >FC61           movb    @vidws+1, *9
1308  >0D2C=>D640                 movb    0, *9       ; update sprite coord 
1309                              
1310  >0D2E=>DA43 >FFFE           movb    3, @-2(9)
1311  >0D32=>DA42 >FFFE           movb    2, @-2(9)
1312                              
1313  >0D36=>A006                 a       6, 0
1314  >0D38=>05C0                 inct    0
1315  >0D3A=>D660 >FC61           movb    @vidws+1, *9
1316  >0D3E=>D640                 movb    0, *9        ; update motion fractions
1317                              
1318  >0D40=>06C3                 swpb    3
1319  >0D42=>DA43 >FFFE           movb    3, @-2(9)
1320  >0D46=>06C2                 swpb    2
1321  >0D48=>DA42 >FFFE           movb    2, @-2(9)
1322                              
1323  >0D4C                   vsm_next:
1324  >0D4C=>0224 >0004           ai      4, 4
1325  >0D50=>0605                 dec     5
1326  >0D52=>15C4                 jgt     vsm_loop
1328  >0D54=>0380                 rtwp
1329                              
*** nforth.tsm
510                           	incl	video_text.i
*** video_text.i
21                              
22    >0D56                   vtextsetup
23                                PUSH    SP,11
*** <expansion of push>
1     >0D56=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0D58=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_text.i
24    >0D5A=>0201 >0516           li      1,vtxt
25    >0D5E=>D820 >0019 >F7CD     movb    #M_text,@vidmode
26    >0D64=>06A0 >096A           bl      @vstdmode
27    >0D68                   vtextsetup0:
28    >0D68=>06A0 >0766       	bl	    @vsetupregs
29    >0D6C=>06A0 >079A       	bl	    @vsetupaddrs
30    >0D70=>C801 >F7C8       	mov    1,@vtermptr
31                                
32                            	POP    SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0D74=>C2FA                     mov *SP+,  11
*** video_text.i
33    >0D76=>045B             	rt
34                            	
35    >0D78                   vtext2setup
36                                PUSH    SP,11
*** <expansion of push>
1     >0D78=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0D7A=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_text.i
37    >0D7C=>06A0 >15C8           bl      @venhmode
38    >0D80=>D820 >0226 >F7CD     movb    #M_text2,@vidmode
39                                
40                                ; set inverted bg/fg for blink color
41    >0D86=>04C0                 clr     0
42    >0D88=>D020 >F7BE           movb    @vfgbg,0
43    >0D8C=>06C0                 swpb    0
44    >0D8E=>D020 >F7BE           movb    @vfgbg,0
45    >0D92=>0B05                 src     5, 0
46    >0D94=>D020 >04A5           movb    #>C,0
47    >0D98=>06A0 >046A           bl      @vwreg
48                                
49    >0D9C=>0201 >06A4           li      1,vtxt2
50    >0DA0=>10E3                 jmp     vtextsetup0
53    >0DA2                   vgraphsetup
54    >0DA2=>D820 >01BB >F7CD     movb    #M_graph,@vidmode
55    >0DA8=>0201 >0540       	li	1,vgfx
56    >0DAC                   vgraphsetup0:	
57                                PUSH    SP,11
*** <expansion of push>
1     >0DAC=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0DAE=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_text.i
58    >0DB0=>06A0 >0766       	bl	@vsetupregs
59    >0DB4=>06A0 >079A       	bl	@vsetupaddrs
60    >0DB8=>C801 >F7C8       	mov 1,@vtermptr
61                                ;bl  @vtermsetup
62    >0DBC=>06A0 >096A           bl  @vstdmode
63                                POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0DC0=>C2FA                     mov *SP+,  11
*** video_text.i
64    >0DC2=>045B             	rt
66    >0DC4                   vmultisetup
67    >0DC4=>D820 >0078 >F7CD     movb    #M_multi,@vidmode
68    >0DCA=>0201 >0704           li  1,vmulti
69    >0DCE=>10EE                 jmp vgraphsetup0
70                                
80    >0DD0                   vtextaddr PUSH SP, 2
*** <expansion of push>
1     >0DD0=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0DD2=>C682                     mov  2, @(1-0-1)*2(SP)
*** video_text.i
81                                
82    >0DD4=>C080                 mov     0,2              ; save X
83    >0DD6=>06C0                 swpb    0
85    >0DD8=>B020 >F7C3           ab      @vwy,0
86    >0DDC=>0980                 srl     0,8
87    >0DDE=>3820 >F7B4           mpy     @vwidth,0        ; get row offset in R1
88                                
89    >0DE2=>D002                 movb    2,0
90    >0DE4=>B020 >F7C2           ab      @vwx,0
91    >0DE8=>0980                 srl     0,8              ; get column offset
93    >0DEA=>A001                 a       1,0                ; column+row
94    >0DEC=>A020 >F786           a       @vscreen,0         ; R0=addr
95    >0DF0=>A020 >FF70           a       @vtextpage,0
97                                POP     SP, 2
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0DF4=>C0BA                     mov *SP+,  2
*** video_text.i
98    >0DF6=>045B                 rt
110   >0DF8                   vgraphaddr PUSH SP, 2
*** <expansion of push>
1     >0DF8=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0DFA=>C682                     mov  2, @(1-0-1)*2(SP)
*** video_text.i
111   >0DFC=>C080                 mov     0,2             ; save X
112   >0DFE=>06C0                 swpb    0
114   >0E00=>B020 >F7C3           ab      @vwy,0
115   >0E04=>0980                 srl     0,8
116   >0E06=>0A50                 sla     0,5
118   >0E08=>D042                 movb    2,1
119   >0E0A=>B060 >F7C2           ab      @vwx,1
120   >0E0E=>0981                 srl     1,8                 ; get column offset
122   >0E10=>A001                 a       1,0             ; column+row
123   >0E12=>A020 >F786           a       @vscreen,0          ; R0=addr
125                               POP     SP, 2
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0E16=>C0BA                     mov *SP+,  2
*** video_text.i
126   >0E18=>045B                 rt
136   >0E1A                   vtextclearline
137                               PUSH    SP,0,3,11
*** <expansion of push>
1     >0E1A=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0E1E=>CA80 >0004               mov  0 , @(3-0-1)*2(SP)
2     >0E22=>CA83 >0002               mov  3 , @(3-1-1)*2(SP)
3     >0E26=>C68B                     mov  11, @(3-2-1)*2(SP)
*** video_text.i
139   >0E28=>C0E0 >F7A4           mov     @vcoordaddr,3
140   >0E2C=>0693                 bl      *3
141   >0E2E=>06A0 >178C           bl      @vsetbank
142   >0E32=>0201 >2000           li      1,>2000
143                               ;movb    @vwxs, 2
144                               ;srl     2,8 
145   >0E36=>06A0 >04C6           bl      @vclr               ; clear out line
146                               
147   >0E3A=>9820 >0226 >F7CD     cb      #M_text2, @vidmode
148   >0E40=>160A                 jne     vtextclearlineout
149                               
150                               ; clear blinks
151   >0E42=>04C1                 clr     1
152   >0E44=>D0E0 >FF6D           movb    @vblinkflag, 3
153   >0E48=>1301                 jeq     vtextclearline0
154   >0E4A=>0701                 seto    1    
155   >0E4C                   vtextclearline0:
156   >0E4C=>0932                 srl     2, 3                ; NOTE: only works on 8-char aligned windows
157   >0E4E=>06A0 >0EB8           bl      @vtxt2blink
158   >0E52=>06A0 >04C6           bl      @vclr               ; set blink 
160   >0E56                   vtextclearlineout:         
161                               POP     SP,0,3,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0E56=>C2FA                     mov *SP+,  11
2     >0E58=>C0FA                     mov *SP+,  3 
3     >0E5A=>C03A                     mov *SP+,  0 
*** video_text.i
162   >0E5C=>045B                 rt
178                            Vector vtextchar, vidws
*** <expansion of vector>
1     >0E5E                   vtextchar  data vidws, vtextchar_entry
      >0E5E=>FC60 >0E62       
2     >0E62                   vtextchar_entry:    
*** video_text.i
179   >0E62=>0300 >0000       	limi   0
180   >0E66=>020A >F740       	li	   SP,vstack + vstacksize
182   >0E6A=>C020 >F7CA       	mov	   @vx,0
183   >0E6E=>C060 >F7A4       	mov	   @vcoordaddr,1
184   >0E72=>0691             	bl	   *1				; get address
185                               
186   >0E74=>06A0 >178C           bl     @vsetbank            ; set bank / page
187   >0E78=>06A0 >0454       	bl	   @vwaddr				; set VDP addr
188   >0E7C=>D820 >F7C0 >FF88 	movb   @vch,@VDPWD			; draw
190   >0E82=>9820 >0226 >F7CD     cb     #M_text2, @vidmode	
191   >0E88=>1301             	jeq    vtextchar0
192   >0E8A=>0380             	rtwp
193                           	
194   >0E8C                   vtextchar0:
195                               ; set blink flag
196   >0E8C=>06A0 >0EB8           bl     @vtxt2blink
197   >0E90=>06A0 >0458       	bl     @vraddr
198   >0E94=>D0A0 >FF80       	movb   @VDPRD, 2
199   >0E98=>06A0 >0454       	bl     @vwaddr
200   >0E9C=>0201 >8000       	li     1, >8000
201   >0EA0=>0240 >0007           andi   0, 7
202   >0EA4=>1301                 jeq    vtextchar1
203   >0EA6=>0901             	srl    1, 0
204   >0EA8                   vtextchar1:	
205   >0EA8=>5081             	szcb   1, 2
206   >0EAA=>D020 >FF6D       	movb   @vblinkflag, 0     
207   >0EAE=>1301             	jeq    vtextchar2
208   >0EB0=>F081             	socb   1, 2
209   >0EB2                   vtextchar2:	   
210   >0EB2=>D802 >FF88           movb   2, @VDPWD
211   >0EB6=>0380             	rtwp
213   >0EB8                   vtxt2blink
214   >0EB8=>6020 >F786           s      @vscreen, 0
215   >0EBC=>0930                 srl    0, 3
216   >0EBE=>0240 >01FF           andi   0, >1ff
217   >0EC2=>A020 >FF70           a       @vtextpage, 0
218   >0EC6=>A020 >F78E           a      @vcolors, 0
219   >0ECA=>0240 >3FFF           andi   0, >3fff
220   >0ECE=>045B                 rt
229                             Vector vtextcursor, vidws
*** <expansion of vector>
1     >0ED0                   vtextcursor  data vidws, vtextcursor_entry
      >0ED0=>FC60 >0ED4       
2     >0ED4                   vtextcursor_entry:    
*** video_text.i
230   >0ED4=>0300 >0000       	limi	0
231   >0ED8=>020A >F740       	li	    SP,vstack+  vstacksize
233   >0EDC=>C020 >F7CA       	mov	   @vx,0
234   >0EE0=>C060 >F7A4       	mov	   @vcoordaddr,1
235   >0EE4=>0691             	bl	    *1
236                           	
237   >0EE6=>06A0 >178C       	bl     @vsetbank
238   >0EEA=>B820 >005F >F7AA 	ab	    #>80,@vcurs
239   >0EF0=>130B             	jeq	   vtcoff
241   >0EF2=>06A0 >0458       	bl	    @vraddr			; read char under cursor
242   >0EF6=>D820 >FF80 >F7AB 	movb	@VDPRD,@vcursunder
244   >0EFC=>06A0 >0454       	bl	    @vwaddr
245   >0F00=>D820 >F7C1 >FF88 	movb	@vcurschar,@VDPWD		; draw cursor
247   >0F06=>1005             	jmp	vtcout
249   >0F08                   vtcoff:
250   >0F08=>06A0 >0454       	bl	    @vwaddr
251   >0F0C=>D820 >F7AB >FF88 	movb	@vcursunder,@VDPWD		; restore char under cursor
253   >0F12                   vtcout:
254   >0F12=>0380             	rtwp
257   >0F14                   vnopchar:
258   >0F14                   vnopcursor:
259   >0F14=>FC60 >0F12           data vidws, vtcout
260   >0F18                   vnopclearline:
261   >0F18=>045B                 rt    
*** nforth.tsm
511                           	incl	video_bit.i
*** video_bit.i
23    >0F1A                   vbitmapsetup
24    >0F1A=>D820 >0019 >F7CC 	movb	#00,@vmono
25    >0F20=>0201 >0570       	li 	   1, vbit
26    >0F24                   vbitsentr:
27                                PUSH    SP,11
*** <expansion of push>
1     >0F24=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0F26=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit.i
28    >0F28=>D820 >0018 >F7CD     movb    #M_bit,@vidmode
30    >0F2E=>06A0 >0766       	bl	    @vsetupregs
31    >0F32=>06A0 >079A       	bl	    @vsetupaddrs
32    >0F36=>C801 >F7C8       	mov    1,@vtermptr
33    >0F3A=>06A0 >096A           bl      @vstdmode
34                                
35                                POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0F3E=>C2FA                     mov *SP+,  11
*** video_bit.i
36    >0F40=>045B             	rt
38    >0F42                   vmonosetup
39    >0F42=>D820 >01BB >F7CC 	movb	#1,@vmono
40    >0F48=>0201 >06D4       	li     1, vmonobit
41    >0F4C=>10EB             	jmp	   vbitsentr
43    >0F4E                   vbitmap3setup
44    >0F4E=>0201 >05A0           li      1, vbit3
45    >0F52=>10E8                 jmp     vbitsentr
55    >0F54                   vbitpixeladdr
56    >0F54=>C040                 mov    0,1
57    >0F56=>0A50                 sla    0,5              ; R0=Y offset (row8) ++
58    >0F58=>E001                 soc    1,0              ; R0=Y offset (row) ++
59    >0F5A=>0240 >FF07           andi   0,>ff07          ; R0=complete Y offset
61    >0F5E=>C042                 mov    2,1              ; copy of X
62    >0F60=>0241 >0007           andi   1,7              ; complete X bit offs
63    >0F64=>A002                 a      2,0              ; Y-X offset ++
64    >0F66=>6001                 s      1,0              ; complete Y-X offset
65    >0F68=>045B                 rt
66                                
77    >0F6A                   vbitaddr 
78                                PUSH    SP,2,11
*** <expansion of push>
1     >0F6A=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0F6E=>CA82 >0002               mov  2 , @(2-0-1)*2(SP)
2     >0F72=>C68B                     mov  11, @(2-1-1)*2(SP)
*** video_bit.i
80    >0F74=>A020 >F7C2           a       @vwx, 0
81                                
82                                ; scale by vbsize
83    >0F78=>04C1                 clr     1
84    >0F7A=>D060 >F7A2           movb    @vbsize,1       ; X size (hi)
85    >0F7E=>04C2                 clr     2
86    >0F80=>D080                 movb    0,2             ; X (hi)
87    >0F82=>3881                 mpy     1,2             ; R2=col #  (3 = 0)
88                                
89    >0F84=>0A80                 sla     0,8             ; Y
90    >0F86=>D0E0 >F7A3           movb    @vbsize+1,3
91    >0F8A=>38C0                 mpy     0,3             ; 3=row#
92                                
93    >0F8C=>C003                 mov     3,0
94    >0F8E=>7000                 sb      0,0             ; R0=Y
96    >0F90=>06A0 >0F54           bl      @vbitpixeladdr
97                                
98                                POP     SP,2,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0F94=>C2FA                     mov *SP+,  11
2     >0F96=>C0BA                     mov *SP+,  2 
*** video_bit.i
99    >0F98=>045B                 rt
109   >0F9A                   vbitclearline
110                               PUSH    SP,0,3,11
*** <expansion of push>
1     >0F9A=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0F9E=>CA80 >0004               mov  0 , @(3-0-1)*2(SP)
2     >0FA2=>CA83 >0002               mov  3 , @(3-1-1)*2(SP)
3     >0FA6=>C68B                     mov  11, @(3-2-1)*2(SP)
*** video_bit.i
112                               ; get start address and shift in R0/R1
113   >0FA8=>C0E0 >F7A4           mov     @vcoordaddr,3
114   >0FAC=>0693                 bl      *3
115   >0FAE=>C100                 mov     0,4
117                               ; scale width by vbsize
118   >0FB0=>C201                 mov     1,8
119                               
120   >0FB2=>04C1                 clr     1
121   >0FB4=>D060 >F7A2           movb    @vbsize,1       ; X size (hi)
122                               ;clr     2
123                               ;movb    @vwxs,2         ; X (hi)
124   >0FB8=>0A82                 sla     2,8
125   >0FBA=>3881                 mpy     1,2             ; 2=col #  (3 = 0)
126                               
127   >0FBC=>C048                 mov     8,1
128                               
129                               ; height is vbsize
130   >0FBE=>D220 >F7A3           movb    @vbsize+1,8
131   >0FC2=>0988                 srl     8,8      
133   >0FC4=>06A0 >0398           bl      @vgetcolorbyte
134   >0FC8=>D300                 movb    0,12
135   >0FCA=>098C                 srl     12,8
136                               
137   >0FCC=>06A0 >1482           bl      @vbitfillrect
139                               POP     SP,0,3,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0FD0=>C2FA                     mov *SP+,  11
2     >0FD2=>C0FA                     mov *SP+,  3 
3     >0FD4=>C03A                     mov *SP+,  0 
*** video_bit.i
140   >0FD6=>045B                 rt
151   >0FD8                   vfetchfontchar
152                               PUSH    SP,11,0
*** <expansion of push>
1     >0FD8=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0FDC=>CA8B >0002               mov  11 , @(2-0-1)*2(SP)
2     >0FE0=>C680                     mov  0, @(2-1-1)*2(SP)
*** video_bit.i
153   >0FE2=>D020 >F7C0           movb    @vch,0
154   >0FE6=>0980                 srl     0,8
155   >0FE8=>0A30                 sla     0,3
156   >0FEA=>A020 >F7BC           a       @vfont,0
157   >0FEE=>06A0 >0446           bl      @gwaddr             ; set GROM addr
158                               
159   >0FF2=>D2E0 >F7A3           movb    @vbsize+1,11
160   >0FF6=>098B                 srl     11,8
161                               
162   >0FF8=>C04A                 mov     SP, 1
163   >0FFA=>604B                 s       11, 1               ; get space on stack for char
164   >0FFC=>C001                 mov     1, 0
165   >0FFE                   $1:
166   >0FFE=>DC20 >FF90           movb    @GPLRD, *0+
167   >1002=>DC20 >FF90           movb    @GPLRD, *0+
168   >1006=>064B                 dect    11
169   >1008=>15FA                 jgt     $1-
170                                    
171                               POP     SP,11,0
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >100A=>C03A                     mov *SP+,  0
2     >100C=>C2FA                     mov *SP+,  11 
*** video_bit.i
172   >100E=>045B                 rt
182                            Vector vbitchar, vidws
*** <expansion of vector>
1     >1010                   vbitchar  data vidws, vbitchar_entry
      >1010=>FC60 >1014       
2     >1014                   vbitchar_entry:    
*** video_bit.i
183   >1014=>0300 >0000       	limi	0
184   >1018=>020A >F740       	li		SP,vstack + vstacksize
186   >101C=>8820 >F7A2 >29B0 	c       @vbsize,#>0808
187   >1022=>1302             	jeq		vbitfast
188   >1024=>0460 >12FC       	b		@vbitcharsmall+4
190   >1028                   vbitfast:
191   >1028=>C020 >F7CA           mov     @vx,0
192   >102C=>C060 >F7A4       	mov		@vcoordaddr,1
193   >1030=>0691             	bl		*1				; get address in 0, shift in 1
195   >1032=>C100             	mov		0,4              
196                           	
197   >1034=>06A0 >0FD8       	bl      @vfetchfontchar
198                           	
199   >1038=>A020 >F78A       	a		@vpatts,0
200   >103C=>06A0 >0454       	bl		@vwaddr				; set VDP addr for patt
202   >1040=>0203 >FF88       	li		3,VDPWD
203   >1044=>0202 >0008           li      2, 8
204   >1048                   $1: movb    *1+,*3
      >1048=>D4F1             
205   >104A=>0602                 dec     2
206   >104C=>15FD                 jgt     $1-
207                           	
208   >104E=>D820 >F7CC >F7CC 	movb	@vmono,@vmono
209   >1054=>160D             	jne		vbcnocol
211   >1056=>C004             	mov		4,0
212   >1058=>A020 >F78E       	a		@vcolors,0			; draw color
213   >105C=>06A0 >0454       	bl		@vwaddr
215   >1060=>06A0 >0398           bl      @vgetcolorbyte
216   >1064=>D040                 movb    0,1
218   >1066=>0202 >0008           li      2, 8
219   >106A                   $1: movb    1,*3
      >106A=>D4C1             
220   >106C=>0602                 dec     2
221   >106E=>15FD                 jgt     $1-    
223   >1070                   vbcnocol:
224   >1070=>0380             	rtwp
227   >1072                   vbitcursorset
228   >1072=>C28B                 mov     11,10 
229   >1074=>06A0 >0458           bl     @vraddr
230   >1078=>D060 >FF80           movb   @VDPRD, 1
231   >107C=>DD81                 movb    1,*6+
232   >107E=>F043                 socb   3,1
233   >1080=>045A                 b       *10
234                               
235   >1082                   vbitcursorreset 
236   >1082=>D076                 movb *6+,1
237   >1084=>045B                 rt
238                            
242                            Vector vbitcursor, vidws
*** <expansion of vector>
1     >1086                   vbitcursor  data vidws, vbitcursor_entry
      >1086=>FC60 >108A       
2     >108A                   vbitcursor_entry:    
*** video_bit.i
244   >108A=>0300 >0000       	limi   0
245   >108E=>020A >F740       	li	   SP,vstack + vstacksize
247   >1092=>C020 >F7CA       	mov    @vx,0
248   >1096=>C060 >F7A4       	mov	   @vcoordaddr,1
249   >109A=>0691             	bl	   *1
250                           	
251   >109C=>A020 >F78A       	a	   @vpatts,0		; only change patt
252   >10A0=>06A0 >178C           bl     @vsetbank
253   >10A4=>C100             	mov    0,4
254                               
255   >10A6=>C001                 mov    1,0
256   >10A8=>0203 >C0C0           li     3,>c0c0
257   >10AC=>0B03                 src    3,0
258                               
259                               ; based on the cursor mode, we either save + modify or restore the bits under the cursor
260   >10AE=>0205 >1072           li      5,vbitcursorset
261   >10B2=>B820 >005F >F7AA     ab      #>80,@vcurs
262   >10B8=>1602                 jne     vbc1
263   >10BA=>0205 >1082           li      5,vbitcursorreset
264   >10BE                   vbc1:    
265   >10BE=>0206 >F7AB           li     6,vcursunder
266   >10C2=>D0A0 >F7A3           movb   @vbsize+1, 2
267   >10C6=>0982                 srl    2,8
268                               
269   >10C8=>0207 >0007           li      7, 7
270   >10CC=>020C >0001           li      12, 1
271   >10D0                   vbc0:
272   >10D0=>C004                 mov     4,0
273   >10D2=>0695                 bl      *5      ; read or write pixel
274   >10D4=>06A0 >0454           bl      @vwaddr
275   >10D8=>D801 >FF88           movb    1,@VDPWD
276                               
277   >10DC=>A10C                 a       12,4    ; next row
278   >10DE=>2507                 czc     7,4     ; end of block?
279   >10E0=>1604                 jne     vbc2
280   >10E2=>0224 >00FF           ai      4,>ff   
281   >10E6=>0244 >3FF8           andi    4,>3ff8
282   >10EA                   vbc2:
283   >10EA=>0602                 dec     2
284   >10EC=>15F1                 jgt     vbc0
285                               
286   >10EE=>0380             	rtwp
294   >10F0                   h14         data 14
      >10F0=>000E             
296   >10F2                   vbitline
297                               PUSH   SP, 13, 14
*** <expansion of push>
1     >10F2=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >10F6=>CA8D >0002               mov  13 , @(2-0-1)*2(SP)
2     >10FA=>C68E                     mov  14, @(2-1-1)*2(SP)
*** video_bit.i
298                               
299   >10FC=>C06C >0008           mov    @8(12), 1   ; X
300   >1100=>C0AC >0006           mov    @6(12), 2   ; Y
301   >1104=>C0EC >0004           mov    @4(12), 3   ; X2
302   >1108=>C12C >0002           mov    @2(12), 4   ; Y2
303                               
304   >110C=>60C1             	s	   1,3          ; X direction = R3-R1
305   >110E=>C1C3             	mov    3,7        
306   >1110=>0747             	abs	   7            ; X distance 
308   >1112=>6102             	s	   2,4          ; Y direction = R4-R2
309   >1114=>C204             	mov    4,8        
310   >1116=>0748             	abs	   8            ; Y distance
312   >1118=>8207             	c	   7,8			; which axis is longer?
313                           						; R6>=0 means Y is longer
314                           						; R6<0  means X is longer
315   >111A=>150A             	jgt	   vbl_x
321   >111C=>020E >11A2           li      14, vbl_ymajor
322                               
323   >1120=>C104                 mov     4, 4        ; going up?
324   >1122=>1505                 jgt     $1+
325                              
326   >1124=>A084                 a       4, 2
327   >1126=>0504                 neg     4           ; make it go the other way
328                               
329   >1128=>C06C >0004           mov     @4(12), 1
330   >112C=>0503                 neg     3           ; minor direction swapped too
331                                
332   >112E                   $1:    
333                               
334   >112E=>100C                 jmp     vbl_plotline
335                               
336   >1130                   vbl_x:
341   >1130=>020E >11D2           li      14, vbl_xmajor
343   >1134=>C0C3                 mov     3, 3        ; going up/left?
344   >1136=>1505                 jgt     $1+
345                              
346   >1138=>A043                 a       3, 1        ; make it go the other way
347   >113A=>0503                 neg     3           
348                               
349   >113C=>C0AC >0002           mov     @2(12), 2
350   >1140=>0504                 neg     4           ; minor direction swapped too
351                               
352                                
353   >1142                   $1:    
354                               
355                               ; Swap major and minor
356   >1142=>C2C3                 mov     3, 11
357   >1144=>C0C4                 mov     4, 3
358   >1146=>C10B                 mov     11, 4
359                               
360   >1148                   vbl_plotline:    
361   >1148=>0584                 inc     4
362                               
363   >114A=>C31C                 mov    *12, 12
364                               
365                               ; get op
366   >114C=>06A0 >1254           bl      @vbitgetdrawfuncandcolor
367                               
369   >1150=>06A0 >1230           bl      @vbl_getaddr       ; get start addr (R1, R2) -> (R0, R1)
370   >1154=>A020 >F78A           a       @vpatts, 0
371                               
372   >1158=>06A0 >1212           bl      @vbl_getfracmags
373                               
374                               ; R7=minor increment
375                               ; R6=minor fraction 
376                               ; R3=minor magnitude
378   >115C=>04C2                 clr    2                ; so we have a clean check for COC
379                               
380   >115E=>020D >2420           li     13, >2420        ; CZC <addr>, 0
381   >1162=>C243                 mov    3, 9
382                               
383   >1164=>1502                 jgt    $2+
384   >1166=>020D >2020           li     13, >2020        ; COC <addr>, 0
385   >116A                   $2:    
386   >116A=>028E >11A2           ci     14, vbl_ymajor
387   >116E=>1605                 jne    $3+
388                               
389   >1170=>022D >0040           ai     13, >40          ; COC|CZC ..., 1
390   >1174=>A0C3                 a      3, 3             ; X shift change is in increments of 2
391   >1176=>0A39                 sla    9, 3             ; adjust direction for X byte change (8 bytes)
392   >1178=>1004                 jmp    vbl_linepixel
394   >117A                   $3:
395   >117A=>C2C9                 mov    9, 11
396   >117C=>0A3B                 sla    11, 3
397   >117E=>0A89                 sla    9, 8
398   >1180=>624B                 s      11, 9             ; adjust direction for Y block change (256-8)    
399                               
400   >1182                   vbl_linepixel:    
412   >1182=>04C2                 clr     2
413   >1184=>0208 >FF8A           li      8, VDPWA
415   >1188=>06A0 >129E           bl      @vbitreadpixel_
416                                   
417   >118C                   vbl_lineloop:
418   >118C=>0241 >000E           andi   1, >E            ; keep shift in range
419                              ;bl     @vbitdrawpixel_
420                               
421   >1190=>045E                 b      *14              ; next major 
423   >1192                   vbl_lineloopret:    
424   >1192=>0604                 dec    4                ; one pixel consumed
425   >1194=>15FB                 jgt    vbl_lineloop
427   >1196=>06A0 >12AA           bl     @vbitwritepixel_
428                                    
429   >119A=>04CF             	clr    15               ; clr out what we did
430                           	POP    SP, 13, 14
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >119C=>C3BA                     mov *SP+,  14
2     >119E=>C37A                     mov *SP+,  13 
*** video_bit.i
431   >11A0=>0380             	rtwp
436   >11A2                   vbl_ymajor:
437   >11A2=>0485                  x       5
438   >11A4=>12E8                  data    vbl_shifts
439                                
440   >11A6=>06A0 >12AA            bl     @vbitwritepixel_
441                               
442   >11AA=>0580                 inc    0                ; new Y
443   >11AC=>2420 >0B38           czc    #7, 0            ; new block?
444   >11B0=>1604                 jne    $1+              ; nope
446   >11B2=>0220 >00F8           ai     0,256-8          ; next block
447   >11B6=>0240 >1FFF           andi   0, >1fff         ; keep in range
449   >11BA                   $1:    
450   >11BA=>A1C6                 a      6, 7
451   >11BC=>1707                 jnc    $1+              ; new X yet?
452                               
453   >11BE=>A043                 a      3, 1             ; yup, adjust shift
454   >11C0=>048D                 x      13               ; test for going left or right and crossing the byte
455   >11C2=>10F0                 data   h14
456                               
457   >11C4=>1603                 jne    $1+              ; not yet
458                               
459   >11C6=>C080                 mov    0, 2
460   >11C8=>A009                 a      9, 0             ; move across a row (8 bytes)
461   >11CA=>D002                 movb   2, 0             ; keep in range
462   >11CC                   $1:    
463   >11CC=>06A0 >129E           bl     @vbitreadpixel_
464   >11D0=>10E0                 jmp     vbl_lineloopret
465                               
469   >11D2                   vbl_xmajor: 
470   >11D2=>0485                 x       5
471   >11D4=>12E8                 data    vbl_shifts
472                               
473   >11D6=>05C1                 inct   1                ; adjust shift
474   >11D8=>2460 >10F0           czc    @h14, 1          ; test for going right and crossing the byte
475                               
476   >11DC=>1607                 jne    $1+              ; not yet
477                               
478   >11DE=>06A0 >12AA           bl     @vbitwritepixel_
479                               
480   >11E2=>B820 >0A14 >FC61     ab     #8, @vidws+1     ; move across a row (8 bytes), keeping in range
481                               
482   >11E8=>06A0 >129E           bl     @vbitreadpixel_
483                               
484   >11EC                   $1:
485                               
486   >11EC=>A1C6                 a      6, 7
487   >11EE=>17D1                 jnc    vbl_lineloopret   ; new Y yet?
489   >11F0=>06A0 >12AA           bl     @vbitwritepixel_
490                               
491   >11F4=>C080                 mov    0, 2             ; remember original address
492                               
493   >11F6=>A003                 a      3, 0             ; yup
494   >11F8=>048D                 x      13               ; new block?
495   >11FA=>0326                 data   h07
496   >11FC=>1601                 jne    $2+              ; nope
498   >11FE=>A009                 a      9, 0             ; next/previous block
500   >1200                   $2:    
501   >1200=>2880                 xor    0, 2             ; check if wrapped
502   >1202=>1504                 jgt    $3+
503                               
504   >1204=>0240 >1FFF           andi   0, >1fff         ; keep in range
505   >1208=>0220 >F800           ai     0, ->800
506   >120C                   $3:
507   >120C=>06A0 >129E           bl     @vbitreadpixel_
508   >1210=>10C0                 jmp    vbl_lineloopret
512   >1212                   vbl_getfracmags:
513   >1212=>C183                 mov     3, 6       
514   >1214=>0746                 abs     6         
515   >1216=>04C7                 clr     7
516   >1218=>3D84                 div     4, 6            ; R6=minor increment
517   >121A=>04C7                 clr     7               ; R7=minor fraction 
518   >121C=>1902                 jno     $1+
519                               
520   >121E=>0706                 seto    6               ; close enough to straight
521   >1220=>0707                 seto    7               ; force immediate carry    
522   >1222                   $1:    
523                               
524                               ; Convert R3 to the magnitude for shift adjust (-2, 0, 2)
526   >1222=>C0C3                 mov     3, 3
527   >1224=>0703                 seto    3
528   >1226=>1103                 jlt     $1+
529   >1228=>04C3                 clr     3
530   >122A=>1301                 jeq     $1+
531   >122C=>0583                 inc     3
532                               
533   >122E                   $1:
534   >122E=>045B                 rt
543   >1230                   vbl_getaddr
544                               PUSH    SP, 2, 11
*** <expansion of push>
1     >1230=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1234=>CA82 >0002               mov  2 , @(2-0-1)*2(SP)
2     >1238=>C68B                     mov  11, @(2-1-1)*2(SP)
*** video_bit.i
546   >123A=>7041             	sb      1,1    				; scale down X
547   >123C=>C2C1                 mov     1, 11
548                               
549   >123E=>04C1                 clr     1
550   >1240=>3C60 >29B4           div     #192, 1              ; scale down Y (R2=mod)
551   >1244=>C002                 mov     2, 0
553                               ; R0=Y R2=X
554   >1246=>C08B                 mov     11, 2
555   >1248=>06A0 >0F54           bl     @vbitpixeladdr
556                               
557   >124C=>A041                 a      1,1                ; shift in increments of 2 
558                           	
559                               POP    SP,2,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >124E=>C2FA                     mov *SP+,  11
2     >1250=>C0BA                     mov *SP+,  2 
*** video_bit.i
560   >1252=>045B             	rt
569   >1254                   vbitgetdrawfuncandcolor
570                               
571   >1254=>04C5                 clr     5
572   >1256=>D14C                 movb    12, 5
573   >1258=>0245 >0F00           andi    5, >F00 
574   >125C=>0975                 srl     5, 7
575   >125E=>C165 >12D8           mov     @vdrawops(5), 5    ; R5 = pattern operation
577   >1262=>0ACC                 sla     12, 12
578   >1264=>F320 >F7BF           socb    @vfgbg+1, 12 ; R12 = color
579                               
580   >1268=>045B                 rt
581                               
587   >126A                   vbl_drawpixel PUSH SP, 5, 8, 11, 12
*** <expansion of push>
1     >126A=>022A >FFF8           ai SP, -4*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >126E=>CA85 >0006               mov  5 , @(4-0-1)*2(SP)
2     >1272=>CA88 >0004               mov  8 , @(4-1-1)*2(SP)
3     >1276=>CA8B >0002               mov  11 , @(4-2-1)*2(SP)
4     >127A=>C68C                     mov  12, @(4-3-1)*2(SP)
*** video_bit.i
588   >127C=>06A0 >1254           bl     @vbitgetdrawfuncandcolor
590   >1280=>06A0 >1230           bl     @vbl_getaddr
592   >1284=>0208 >FF8A           li     8,VDPWA    
593   >1288=>06A0 >129E           bl     @vbitreadpixel_
594                               
595   >128C=>0485                 x      5
596   >128E=>12E8                 data   vbl_shifts
597                            
598   >1290=>06A0 >12AA           bl     @vbitwritepixel_ 
599                               
600                               POP    SP, 5, 8, 11, 12
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1294=>C33A                     mov *SP+,  12
2     >1296=>C2FA                     mov *SP+,  11 
3     >1298=>C23A                     mov *SP+,  8 
4     >129A=>C17A                     mov *SP+,  5 
*** video_bit.i
601   >129C=>045B                 rt
608   >129E                   vbitreadpixel_ 
609   >129E=>D620 >FC61           movb   @vidws+1, *8
610   >12A2=>D600                 movb   0, *8
611                               
612   >12A4=>D0A0 >FF80           movb   @VDPRD, 2            ; get patt byte
613   >12A8=>045B                 rt
621   >12AA                   vbitwritepixel_ 
622   >12AA=>0260 >4000           ori    0, >4000
623   >12AE=>D620 >FC61           movb   @vidws+1, *8
624   >12B2=>D600                 movb   0, *8
625                               
626   >12B4=>D802 >FF88           movb   2, @VDPWD            ; put patt byte
628   >12B8=>D820 >F7CC >F7CC     movb   @vmono,@vmono
629   >12BE=>1609                 jne    $1+
630                                   
631   >12C0=>2820 >07D2           xor    #>2000, 0            ; pattern -> color table
633   >12C4=>D620 >FC61           movb   @vidws+1, *8
634   >12C8=>D600                 movb   0, *8
635                               
636   >12CA=>D80C >FF88           movb   12, @VDPWD          ; put color byte
637                               
638   >12CE=>2820 >07D2           xor    #>2000, 0            ; pattern -> color table
639   >12D2                   $1:
640   >12D2=>0240 >3FFF           andi   0, >3fff            ; turn off write bit    
641   >12D6=>045B                 rt
642                               
644   >12D8                   vdrawops: 
645   >12D8=>F0A1 >F0A1           dw  >F0A1, >F0A1
646   >12DC=>50A1 >28A1           dw  >50A1, >28A1            ; nop is CB
647   >12E0=>90A1 >90A1 >90A1     dw  >90A1, >90A1, >90A1, >90A1
      >12E6=>90A1             
649   >12E8                   vbl_shifts byte >80,0,>40,0,>20,0,>10,0,>8,0,>4,0,>2,0,>1,0
      >12E8=>8000 >4000 >2000 
      >12EE=>1000 >0800 >0400 
      >12F4=>0200 >0100       
660                            Vector vbitcharsmall, vidws
*** <expansion of vector>
1     >12F8                   vbitcharsmall  data vidws, vbitcharsmall_entry
      >12F8=>FC60 >12FC       
2     >12FC                   vbitcharsmall_entry:    
*** video_bit.i
661   >12FC=>0300 >0000       	limi	0
662   >1300=>020A >F740       	li		SP,vstack + vstacksize
664   >1304=>C020 >F7CA       	mov		@vx,0
665   >1308=>C060 >F7A4       	mov		@vcoordaddr,1
666   >130C=>0691             	bl		*1				; get address in 0, shift in 1
668   >130E=>C0C0             	mov		0,3
669   >1310=>0243 >0007       	andi	3,7
670   >1314=>0503             	neg		3
671   >1316=>0223 >0008       	ai		3,8				; R3=# pixels before row block
674   >131A=>C100             	mov		0, 4
676                           	; first, draw with R0 shift and the left 8-shift bit
677                           	
678   >131C=>0705             	seto	5
679   >131E=>D020 >F7A2       	movb	@vbsize, 0
680   >1322=>0980             	srl		0,8
681   >1324=>1301             	jeq		vbscs0				; avoid losing all bits (=16)
682   >1326=>0905             	srl		5, 0				; bitmask
683   >1328                   vbscs0:
684   >1328=>0545             	inv		5				; e.g. FF00 or FC00
686   >132A=>C001             	mov		1,0
687   >132C=>0B05             	src		5,0				; e.g. 03F0
688   >132E=>06A0 >134A       	bl		@vbitcharstrip
690                           	; then draw the next strip over one block
691   >1332=>0201 >0008       	li		1,8
692   >1336=>A001             	a		1,0
693   >1338=>0280 >0008       	ci		0,8
694   >133C=>1205             	jle		vbcsout
695   >133E=>0224 >0008       	ai		4,8
696   >1342=>06C5             	swpb	5
697   >1344=>06A0 >134A       	bl		@vbitcharstrip
698   >1348                   vbcsout:
700   >1348=>0380             	rtwp
702                           	
712   >134A                   vbitcharstrip
713                               PUSH    SP, 0, 1, 3, 4, 7, 8, 9, 11, 12
*** <expansion of push>
1     >134A=>022A >FFEE           ai SP, -9*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >134E=>CA80 >0010               mov  0 , @(9-0-1)*2(SP)
2     >1352=>CA81 >000E               mov  1 , @(9-1-1)*2(SP)
3     >1356=>CA83 >000C               mov  3 , @(9-2-1)*2(SP)
4     >135A=>CA84 >000A               mov  4 , @(9-3-1)*2(SP)
5     >135E=>CA87 >0008               mov  7 , @(9-4-1)*2(SP)
6     >1362=>CA88 >0006               mov  8 , @(9-5-1)*2(SP)
7     >1366=>CA89 >0004               mov  9 , @(9-6-1)*2(SP)
8     >136A=>CA8B >0002               mov  11 , @(9-7-1)*2(SP)
9     >136E=>C68C                     mov  12, @(9-8-1)*2(SP)
*** video_bit.i
714   >1370=>C240             	mov		0,9
716                           	; read video memory into RAM
717   >1372=>0202 >F7E6       	li		2,vbitbuf
719                           	; read all the current char bytes and mask off bits to modify
720   >1376=>D220 >F7A3       	movb 	@vbsize+1, 8
721   >137A=>0988             	srl		8,8
723   >137C=>A120 >F78A       	a		@vpatts,4
724   >1380=>C1C4             	mov		4,7
726   >1382=>06A0 >13F8       	bl		@vbitreadstrip
728   >1386=>06A0 >0FD8           bl      @vfetchfontchar
730   >138A=>C107             	mov		7,4
731   >138C=>C004             	mov		4,0
732   >138E=>06A0 >0454       	bl		@vwaddr				; set VDP addr for patt
734   >1392=>C009             	mov		9,0
735   >1394=>C0C8             	mov		8,3
736   >1396                   vbsblit:
737   >1396=>04CC             	clr		12
738   >1398=>D331             	movb	*1+,12
739   >139A=>0B0C             	src		12,0
740   >139C=>F332             	socb	*2+,12
741   >139E=>D80C >FF88       	movb	12,@VDPWD
742   >13A2=>0603             	dec		3
743   >13A4=>130A             	jeq 	vbsblit_0
744   >13A6=>0584             	inc		4
745   >13A8=>2520 >0326       	czc		@h07,4
746   >13AC=>16F4             	jne		vbsblit
747   >13AE=>0604             	dec		4
748   >13B0=>06A0 >13DA       	bl		@vbsnextblock
749   >13B4=>0454             	data	vwaddr
750   >13B6=>C009             	mov		9,0
751   >13B8=>10EE             	jmp		vbsblit
753   >13BA                   vbsblit_0:
754   >13BA=>06A0 >0398           bl      @vgetcolorbyte
755   >13BE=>D040                 movb    0,1
756   >13C0=>C107             	mov		7,4
757   >13C2=>06A0 >143C       	bl		@vbitsetcolorstrip
759                               POP     SP, 0, 1, 3, 4, 7, 8, 9, 11, 12
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >13C6=>C33A                     mov *SP+,  12
2     >13C8=>C2FA                     mov *SP+,  11 
3     >13CA=>C27A                     mov *SP+,  9 
4     >13CC=>C23A                     mov *SP+,  8 
5     >13CE=>C1FA                     mov *SP+,  7 
6     >13D0=>C13A                     mov *SP+,  4 
7     >13D2=>C0FA                     mov *SP+,  3 
8     >13D4=>C07A                     mov *SP+,  1 
9     >13D6=>C03A                     mov *SP+,  0 
*** video_bit.i
760   >13D8=>045B             	rt
768   >13DA                   vbsnextblock ; PUSH   SP, 1, 11
769   >13DA=>022A >FFFC       	ai 		SP,-4
770   >13DE=>CA81 >0002       	mov		1,@2(SP)
771   >13E2=>C07B             	mov		*11+,1
772   >13E4=>C68B             	mov 	11,*SP
773   >13E6=>0224 >0100       	ai		4,>100
774   >13EA=>0244 >3FF8       	andi	4,>3ff8
775   >13EE=>C004             	mov		4,0
776   >13F0=>0691             	bl		*1
777   >13F2=>C2FA             	mov 	*SP+, 11
778   >13F4=>C07A             	mov 	*SP+, 1
779   >13F6=>045B             	rt
792   >13F8                   vbitreadstrip PUSH  SP,4, 6, 9, 11
*** <expansion of push>
1     >13F8=>022A >FFF8           ai SP, -4*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >13FC=>CA84 >0006               mov  4 , @(4-0-1)*2(SP)
2     >1400=>CA86 >0004               mov  6 , @(4-1-1)*2(SP)
3     >1404=>CA89 >0002               mov  9 , @(4-2-1)*2(SP)
4     >1408=>C68B                     mov  11, @(4-3-1)*2(SP)
*** video_bit.i
793   >140A=>C004             	mov		4,0
794   >140C=>06A0 >0458       	bl		@vraddr				; set VDP addr for patt
796                           	; read video memory into RAM
798                           	; read all the current char bytes and mask off bits to modify
800   >1410=>C248             	mov 	8,9
801   >1412                   vbrsrd:
802   >1412=>D1A0 >FF80       	movb 	@VDPRD,6
803   >1416=>5185             	szcb 	5, 6
804   >1418=>DC86             	movb 	6,*2+
805   >141A=>0609             	dec 	9
806   >141C=>1309             	jeq 	vbrsrd_1
807   >141E=>0580             	inc		0
808   >1420=>2420 >0326       	czc		@h07,0
809   >1424=>16F6             	jne		vbrsrd
810   >1426=>0600             	dec		0
811   >1428=>06A0 >13DA       	bl		@vbsnextblock
812   >142C=>0458             	data	vraddr
813   >142E=>10F1             	jmp		vbrsrd
814   >1430                   vbrsrd_1:
815                           	
816   >1430=>6088             	s 		8, 2			; reset buf ptr
818                               POP     SP, 4, 6, 9, 11 
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1432=>C2FA                     mov *SP+,  11
2     >1434=>C27A                     mov *SP+,  9 
3     >1436=>C1BA                     mov *SP+,  6 
4     >1438=>C13A                     mov *SP+,  4 
*** video_bit.i
819   >143A=>045B             	rt
829   >143C                   vbitsetcolorstrip
830                               PUSH    SP, 4, 8, 11
*** <expansion of push>
1     >143C=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1440=>CA84 >0004               mov  4 , @(3-0-1)*2(SP)
2     >1444=>CA88 >0002               mov  8 , @(3-1-1)*2(SP)
3     >1448=>C68B                     mov  11, @(3-2-1)*2(SP)
*** video_bit.i
832   >144A=>D820 >F7CC >F7CC 	movb	@vmono,@vmono
833   >1450=>1614             	jne	vbcsnocol
835   >1452=>6120 >F78A       	s		@vpatts,4
836   >1456=>A120 >F78E       	a		@vcolors,4
838   >145A=>C004             	mov		4,0				; draw color
839   >145C=>06A0 >0454       	bl		@vwaddr
841   >1460                   vbsclr:
842   >1460=>D801 >FF88       	movb	1,@VDPWD
843   >1464=>0608             	dec		8
844   >1466=>1309             	jeq		vbcsnocol
845   >1468=>0580             	inc		0
846   >146A=>2420 >0326       	czc		@h07,0
847   >146E=>16F8             	jne		vbsclr
848   >1470=>0600             	dec		0
849   >1472=>06A0 >13DA       	bl		@vbsnextblock
850   >1476=>0454             	data	vwaddr
851   >1478=>10F3             	jmp		vbsclr
853   >147A                   vbcsnocol:
854                               POP     SP, 4, 8, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >147A=>C2FA                     mov *SP+,  11
2     >147C=>C23A                     mov *SP+,  8 
3     >147E=>C13A                     mov *SP+,  4 
*** video_bit.i
855   >1480=>045B             	rt
865   >1482                   vbitfillrect
866                               PUSH    SP,11
*** <expansion of push>
1     >1482=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1484=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit.i
868                           	; check for a work in the right part of an 8x8 column
870   >1486=>C041             	mov		1,1			; any shift?
871   >1488=>1317             	jeq		vbfr_mid
873   >148A                   vbfr_left:
874                           	; calc the shift right (for left side)
875   >148A=>0205 >FF00       	li		5,>FF00
877   >148E=>0282 >0008       	ci		2,8
878   >1492=>1405             	jhe		vbfr_fulltoleft
880                           	; not full to the left of the next 8x8 block
881   >1494=>C002             	mov    	2,0
882   >1496=>0240 >0007       	andi	0,7
883   >149A=>0A05             	sla		5,0
885   >149C=>6082             	s		2,2				; full width taken care of
887   >149E                   vbfr_fulltoleft:
889   >149E=>C001             	mov		1,0
890   >14A0=>0240 >0007       	andi	0,7
891   >14A4=>0905             	srl		5,0				; bitmask
893   >14A6=>06A0 >14E8       	bl		@vbitunalignedfill
895   >14AA=>0224 >0008       	ai		4,8				; skip that partial column
897   >14AE=>C082             	mov    	2,2				; already done?
898   >14B0=>1319             	jeq		vbfr_out
900   >14B2=>0222 >0008       	ai		2,8
901   >14B6=>6081             	s		1,2				; remove lhs strip from width to use
905   >14B8                   vbfr_mid:
906   >14B8=>0282 >0008       	ci		2,8
907   >14BC=>1A07             	jl		vbfr_right
909                           	; fill a column of 8xR8 blocks
910   >14BE=>06A0 >154A       	bl		@vbitalignedfill
911   >14C2=>0224 >0008       	ai		4,8
912   >14C6=>0222 >FFF8       	ai		2,-8
913   >14CA=>10F6             	jmp		vbfr_mid
917   >14CC                   vbfr_right:
918   >14CC=>C042             	mov		2,1           	; # pixels remaining
919   >14CE=>0241 >0007       	andi	1,7				; # pixels on right
920   >14D2=>1308             	jeq		vbfr_out
922   >14D4=>0705             	seto	5
924   >14D6=>0200 >0007       	li		0,7
925   >14DA=>6001             	s		1,0
926   >14DC=>1301             	jeq		vbfr_r1
927   >14DE=>0905             	srl		5,0				; bitmask
928   >14E0                   vbfr_r1:
930                           	; adjust patt addr
931                           	
932   >14E0=>06A0 >14E8       	bl		@vbitunalignedfill
934   >14E4                   vbfr_out:
936                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >14E4=>C2FA                     mov *SP+,  11
*** video_bit.i
937   >14E6=>045B             	rt
949   >14E8                   vbitunalignedfill
950                               PUSH    SP, 1, 2, 7, 9, 11, 12
*** <expansion of push>
1     >14E8=>022A >FFF4           ai SP, -6*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >14EC=>CA81 >000A               mov  1 , @(6-0-1)*2(SP)
2     >14F0=>CA82 >0008               mov  2 , @(6-1-1)*2(SP)
3     >14F4=>CA87 >0006               mov  7 , @(6-2-1)*2(SP)
4     >14F8=>CA89 >0004               mov  9 , @(6-3-1)*2(SP)
5     >14FC=>CA8B >0002               mov  11 , @(6-4-1)*2(SP)
6     >1500=>C68C                     mov  12, @(6-5-1)*2(SP)
*** video_bit.i
952   >1502=>C1C4             	mov		4,7
953                           	; read video memory into RAM
954   >1504=>0202 >F7E6       	li		2,vbitbuf
956   >1508=>06A0 >13F8       	bl		@vbitreadstrip
958   >150C=>C107             	mov		7,4
959   >150E=>C004             	mov		4,0
960   >1510=>06A0 >0454       	bl		@vwaddr				; set VDP addr for patt
962   >1514=>C248             	mov		8,9
963   >1516                   vbufblit:
964   >1516=>F48C             	socb	12,*2
965   >1518=>D832 >FF88       	movb	*2+,@VDPWD
966   >151C=>0609             	dec		9
967   >151E=>1309             	jeq 	vbufblit_0
968   >1520=>0584             	inc		4
969   >1522=>2520 >0326       	czc		@h07,4
970   >1526=>16F7             	jne		vbufblit
971   >1528=>0604             	dec		4
972   >152A=>06A0 >13DA       	bl		@vbsnextblock
973   >152E=>0454             	data	vwaddr
974   >1530=>10F2             	jmp		vbufblit
976   >1532                   vbufblit_0:
977   >1532=>C04C             	mov		12,1
978   >1534=>06C1             	swpb	1
979   >1536=>C107             	mov		7,4
980   >1538=>06A0 >143C       	bl		@vbitsetcolorstrip
982                               POP     SP, 1, 2, 7, 9, 11, 12
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >153C=>C33A                     mov *SP+,  12
2     >153E=>C2FA                     mov *SP+,  11 
3     >1540=>C27A                     mov *SP+,  9 
4     >1542=>C1FA                     mov *SP+,  7 
5     >1544=>C0BA                     mov *SP+,  2 
6     >1546=>C07A                     mov *SP+,  1 
*** video_bit.i
983   >1548=>045B             	rt
994   >154A                   vbitalignedfill
995                               PUSH    SP, 1, 2, 7, 9, 11    
*** <expansion of push>
1     >154A=>022A >FFF6           ai SP, -5*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >154E=>CA81 >0008               mov  1 , @(5-0-1)*2(SP)
2     >1552=>CA82 >0006               mov  2 , @(5-1-1)*2(SP)
3     >1556=>CA87 >0004               mov  7 , @(5-2-1)*2(SP)
4     >155A=>CA89 >0002               mov  9 , @(5-3-1)*2(SP)
5     >155E=>C68B                     mov  11, @(5-4-1)*2(SP)
*** video_bit.i
997   >1560=>C1C4             	mov		4,7
998   >1562=>C004             	mov		4,0
999   >1564=>06A0 >0454       	bl		@vwaddr				; set VDP addr for patt
1001  >1568=>C248             	mov		8,9
1002  >156A=>0201 >0007       	li		1,7
1003  >156E                   vbafblit:
1004  >156E=>D80C >FF88       	movb	12,@VDPWD
1005  >1572=>0609             	dec		9
1006  >1574=>1307             	jeq 	vbafblit_0
1007  >1576=>0580             	inc		0
1008  >1578=>2401             	czc		1,0
1009  >157A=>16F9             	jne		vbafblit
1010  >157C=>06A0 >13DA       	bl		@vbsnextblock
1011  >1580=>0454             	data	vwaddr
1012  >1582=>10F5             	jmp		vbafblit
1014  >1584                   vbafblit_0:
1015  >1584=>C04C             	mov		12,1
1016  >1586=>06C1             	swpb	1
1017  >1588=>C107             	mov		7,4
1018  >158A=>06A0 >143C       	bl		@vbitsetcolorstrip
1020                              POP     SP, 1, 2, 7, 9, 11    
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >158E=>C2FA                     mov *SP+,  11
2     >1590=>C27A                     mov *SP+,  9 
3     >1592=>C1FA                     mov *SP+,  7 
4     >1594=>C0BA                     mov *SP+,  2 
5     >1596=>C07A                     mov *SP+,  1 
*** video_bit.i
1021  >1598=>045B             	rt
*** nforth.tsm
512                           	incl	video_bit4.i
*** video_bit4.i
26    >159A                   vstdpalette
27    >159A=>0000                 db >00, >00 ;0
28    >159C=>0000                 db >00, >00 ;1
29    >159E=>1106                 db >11, >06 ;2
30    >15A0=>3307                 db >33, >07 ;3
31    >15A2=>1701                 db >17, >01 ;4
32    >15A4=>2703                 db >27, >03 ;5
33    >15A6=>5101                 db >51, >01 ;6
34    >15A8=>2706                 db >27, >06 ;7
35    >15AA=>7101                 db >71, >01 ;8
36    >15AC=>7303                 db >73, >03 ;9
37    >15AE=>6106                 db >61, >06 ;A
38    >15B0=>6406                 db >64, >06 ;B
39    >15B2=>1104                 db >11, >04 ;C
40    >15B4=>6502                 db >65, >02 ;D
41    >15B6=>5505                 db >55, >05 ;E
42    >15B8=>7707                 db >77, >07 ;F
43                                
45    >15BA                   venhregs    
46    >15BA=>0808                 dw  >808        ; 64 kvideo RAM
47    >15BC=>0E00                 dw  >e00        ; set bank 0, page 0, etc
48    >15BE=>0980                 dw  >980        ; 212-line mode, color, etc
49    >15C0=>0C00                 dw  >c00        ; turn off alt colors
50    >15C2=>0D00                 dw  >d00        ; turn off blink/pageswap
51    >15C4=>0F00                 dw  >f00        ; point to sr0
52    >15C6=>0000                 dw  0
53                                         
56    >15C8                   venhmode
57                                push SP,R0,R1,R11
*** <expansion of push>
1     >15C8=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >15CC=>CA80 >0004               mov  R0 , @(3-0-1)*2(SP)
2     >15D0=>CA81 >0002               mov  R1 , @(3-1-1)*2(SP)
3     >15D4=>C68B                     mov  R11, @(3-2-1)*2(SP)
*** video_bit4.i
58                                
59    >15D6=>0201 >15BA           li      1, venhregs
60    >15DA                   venhmode0:  mov *1+, 0
      >15DA=>C031             
61    >15DC=>1303                 jeq     venhmode1
62    >15DE=>06A0 >046A           bl      @vwreg
63    >15E2=>10FB                 jmp     venhmode0
64    >15E4                   venhmode1:    
65                                pop     SP,R0,R1,R11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >15E4=>C2FA                     mov *SP+,  R11
2     >15E6=>C07A                     mov *SP+,  R1 
3     >15E8=>C03A                     mov *SP+,  R0 
*** video_bit4.i
66    >15EA=>045B                 rt
70    >15EC                   vstatus0
71    >15EC=>0200 >0F00           li      0, >f00
72    >15F0=>0460 >046A           b       @vwreg
73                                
74    >15F4                   vsetpalette
75                                push    SP,R0,R11
*** <expansion of push>
1     >15F4=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >15F8=>CA80 >0002               mov  R0 , @(2-0-1)*2(SP)
2     >15FC=>C68B                     mov  R11, @(2-1-1)*2(SP)
*** video_bit4.i
76                                ; set std palette
77    >15FE=>06A0 >0494           bl      @vwregnext
78    >1602=>1000                 data    >1000
79    >1604=>0200 >159A           li      0, vstdpalette
80    >1608                   vsetpal1 movb *0+, @VDPCL
      >1608=>D830 >FF8C       
81    >160C=>0280 >15BA           ci      0, vstdpalette + 16*2
82    >1610=>16FB                 jne     vsetpal1
83                                pop     SP,R0,R11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1612=>C2FA                     mov *SP+,  R11
2     >1614=>C03A                     mov *SP+,  R0 
*** video_bit4.i
84    >1616=>045B                 rt
89    >1618                   vbitmap4setup
90    >1618=>0201 >05D2           li  1, vbit4
91    >161C                   vbit4sentr:
92                                PUSH    SP,11
*** <expansion of push>
1     >161C=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >161E=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
93    >1620=>D820 >0014 >F7CD     movb    #M_bit4,@vidmode
95    >1626=>06A0 >0766           bl  @vsetupregs
96    >162A=>06A0 >079A           bl  @vsetupaddrs
97    >162E=>06A0 >15C8           bl  @venhmode
98                                
99    >1632=>C831 >F7B6           mov *1+,@vbit4stride
100   >1636=>C831 >F7B8           mov *1+,@vbit4shift
101   >163A=>C831 >F7BA           mov *1+,@vbit4mask
103   >163E=>C801 >F7C8           mov 1,@vtermptr
104   >1642=>06A0 >15F4           bl  @vsetpalette
105                               
106                               POP SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1646=>C2FA                     mov *SP+,  11
*** video_bit4.i
107   >1648=>045B                 rt
109   >164A                   vbitmap5setup
110   >164A=>0201 >0606           li  1, vbit5
111   >164E=>10E6                 jmp vbit4sentr
113   >1650                   vbitmap6setup
114   >1650=>0201 >063C           li  1, vbit6
115   >1654=>10E3                 jmp vbit4sentr
117   >1656                   vbitmap7setup
118   >1656=>0201 >0670           li  1, vbit7
119   >165A=>10E0                 jmp vbit4sentr
131   >165C                   vbit4xaddr 
132                               PUSH    SP,2
*** <expansion of push>
1     >165C=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >165E=>C682                     mov  2, @(1-0-1)*2(SP)
*** video_bit4.i
134   >1660=>A020 >F7C2           a       @vwx, 0
135                               
136                               ; scale Y by vbsize
137   >1664=>C040                 mov     0,1
138   >1666=>7041                 sb      1,1
139   >1668=>D0A0 >F7A3           movb    @vbsize+1,2
140   >166C=>0982                 srl     2,8
141   >166E=>3881                 mpy     1,2             ; 2=xxx, 3=row#
142                               
143   >1670=>C043                 mov     3,1
144   >1672=>3860 >F7B6           mpy     @vbit4stride, 1 ; 2=addr
145                               
146                               ; scale X by vbsize
147   >1676=>0980                 srl     0,8
148   >1678=>D060 >F7A2           movb    @vbsize,1
149   >167C=>0981                 srl     1,8    
150   >167E=>3801                 mpy     1,0             ; 0=xxx, 1=X scaled 
151                               
152   >1680=>C0C1                 mov     1,3
153   >1682=>C020 >F7B8           mov     @vbit4shift,0
154   >1686=>1301                 jeq     vb4xnoshift
155   >1688=>0901                 srl     1,0             ; R1=offset
156   >168A                   vb4xnoshift:
157   >168A=>A081                 a       1,2             ; R2=full addr
158   >168C=>C002                 mov     2,0             ; R0=full addr
159                               
160   >168E=>C043                 mov     3,1             ; preshifted X
161   >1690=>4060 >F7BA           szc     @vbit4mask,1    ; R1=portion
162                               
163                               POP     SP,2
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1694=>C0BA                     mov *SP+,  2
*** video_bit4.i
164   >1696=>045B                 rt
172   >1698                   vcoordsend:
173   >1698=>06C0             	swpb	0
174   >169A=>D500             	movb	0, *4
175   >169C=>06C0             	swpb	0
176   >169E=>D500             	movb	0, *4
177   >16A0=>045B             	rt
183   >16A2                   vcmdsetup
184   >16A2=>C03B                 mov     *11+, 0  
185                               PUSH    SP, 11
*** <expansion of push>
1     >16A4=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >16A6=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
186                               
187   >16A8=>0260 >1100           ori     0,>1100
188   >16AC=>06A0 >046A           bl      @vwreg
189                               
190   >16B0=>0204 >FF8E           li      4, VDPWI
191                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >16B4=>C2FA                     mov *SP+,  11
*** video_bit4.i
192   >16B6=>045B                 rt
201   >16B8                   vbit4xsetupcursorDXDY
202                               PUSH    SP, 11
*** <expansion of push>
1     >16B8=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >16BA=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
203   >16BC=>A020 >F7C2           a       @vwx, 0
204                               
205                               ; scale Y by vbsize
206   >16C0=>C040                 mov     0,1
207   >16C2=>7041                 sb      1,1
208   >16C4=>D0A0 >F7A3           movb    @vbsize+1,2
209   >16C8=>0982                 srl     2,8
210   >16CA=>3881                 mpy     1,2             ; 2=xxx, 3=row#
211                               
212                               ; account for the "big page"
213   >16CC=>A0E0 >FF6E           a       @vpgrow, 3
214                               
215   >16D0=>0980                 srl     0,8
216   >16D2=>D060 >F7A2           movb    @vbsize,1
217   >16D6=>0981                 srl     1,8    
218   >16D8=>3801                 mpy     1,0             ; 0=xxx, 1=X scaled 
220   >16DA=>06A0 >16A2           bl      @vcmdsetup
221   >16DE=>0024                 data    >24
222                               
223   >16E0=>C001                 mov     1, 0
224   >16E2=>06A0 >1698           bl      @vcoordsend     ; send DX
225   >16E6=>C003                 mov     3, 0
226   >16E8=>06A0 >1698           bl      @vcoordsend     ; send DY
227                               
228                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >16EC=>C2FA                     mov *SP+,  11
*** video_bit4.i
229   >16EE=>045B                 rt
230                               
237   >16F0                   vbit4xsetupwindowlineNXNY
238                               push    SP, 11
*** <expansion of push>
1     >16F0=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >16F2=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
239                               
240   >16F4=>04C1                 clr     1
241   >16F6=>D060 >F7A2           movb    @vbsize,1       ; X size (hi)
242   >16FA=>04C2                 clr     2
243   >16FC=>D0A0 >F7C4           movb    @vwxs,2         ; X (hi)
244   >1700=>3881                 mpy     1,2             ; 2=col #  (3 = 0)
245   >1702=>C002                 mov     2, 0
246   >1704=>0600                 dec     0
247   >1706=>06A0 >1698           bl      @vcoordsend     ; NX
248                               
249                               ; height is vbsize
250   >170A=>D020 >F7A3           movb    @vbsize+1,0
251   >170E=>0980                 srl     0,8
252   >1710=>0600                 dec     0      
253   >1712=>06A0 >1698           bl      @vcoordsend     ; NY
254                               
255                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1716=>C2FA                     mov *SP+,  11
*** video_bit4.i
256   >1718=>045B                 rt
265   >171A                   vbit4xsetupwindowcharNXNY
266                               push    SP, 11
*** <expansion of push>
1     >171A=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >171C=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
267                               
268   >171E=>D0A0 >F7A2           movb    @vbsize,2      
269   >1722=>0982                 srl     2,8
270   >1724=>C002                 mov     2,0
271   >1726=>0600                 dec     0
272   >1728=>06A0 >1698           bl      @vcoordsend     ; NX
273                               
274   >172C=>D0E0 >F7A3           movb    @vbsize+1,3
275   >1730=>0983                 srl     3,8
276   >1732=>C003                 mov     3,0
277   >1734=>0600                 dec     0
278   >1736=>06A0 >1698           bl      @vcoordsend     ; NY
279                               
280                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >173A=>C2FA                     mov *SP+,  11
*** video_bit4.i
281   >173C=>045B                 rt
282                               
296   >173E                   vbit4xsetupMMMcommand
297                               push    SP,11
*** <expansion of push>
1     >173E=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1740=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
298                               
299   >1742=>06A0 >0494           bl      @vwregnext
300   >1746=>0F02                 data    >0f02        ; set status reg for testing command finished & transfer ready
301                               
302                               ; wait for ready
303   >1748                   vb4xclr:
304   >1748=>D020 >FF82           movb    @VDPST,0
305   >174C=>0240 >0100           andi    0, >0100
306   >1750=>16FB                 jne     vb4xclr
308                               ; write the command
309   >1752=>D509                 movb    9, *4 
310                               
311                               ; back to the CLR reg, no autoincrement
312   >1754=>06A0 >0494           bl      @vwregnext
313   >1758=>11AC                 data    >11AC
314                               
315                               pop     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >175A=>C2FA                     mov *SP+,  11
*** video_bit4.i
316   >175C=>045B                 rt
317                               
318                               
330   >175E                   vbit4xclearline
331                               PUSH    SP,0,3,11
*** <expansion of push>
1     >175E=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1762=>CA80 >0004               mov  0 , @(3-0-1)*2(SP)
2     >1766=>CA83 >0002               mov  3 , @(3-1-1)*2(SP)
3     >176A=>C68B                     mov  11, @(3-2-1)*2(SP)
*** video_bit4.i
333   >176C=>06A0 >16B8           bl      @vbit4xsetupcursorDXDY
334   >1770=>06A0 >16F0           bl      @vbit4xsetupwindowlineNXNY
336   >1774=>D520 >F7BF           movb    @vfgbg+1, *4    ; CLR
338   >1778=>D520 >0019           movb    #>00, *4        ; ARG (dix=0, diy=0, mxc=0)
340   >177C=>0209 >8000           li      9, >8000        ; HMMV  (terminal is usually aligned)
341   >1780=>06A0 >173E           bl      @vbit4xsetupMMMcommand
342                               
343                               ; don't wait :)
344                               ;li      2, >0100
345                               ;li      3, VDPST
347                           	; see if done
348                           	;movb	*3,0
349                           	;coc		2, 0
350                           	;jeq		vb4xcl
352   >1784                   vb4xclout:			
353                               POP		SP,0,3,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1784=>C2FA                     mov *SP+,  11
2     >1786=>C0FA                     mov *SP+,  3 
3     >1788=>C03A                     mov *SP+,  0 
*** video_bit4.i
354   >178A=>045B             	rt
355                           	
363   >178C                   vsetbank
364   >178C=>064A                 dect    SP
365   >178E=>C680                 mov     0,*SP
366   >1790=>0960                 srl     0, 6
367   >1792=>B020 >FF6C           ab      @vpob, 0
368   >1796=>D800 >FF8A           movb    0, @VDPWA
369   >179A=>C03A                 mov     *SP+,0
370   >179C=>D820 >0C23 >FF8A     movb    #>8e,@VDPWA
371   >17A2=>0240 >3FFF           andi    0,>3fff
372   >17A6=>045B                 rt
377                               
378   >17A8                   vbit4xsendcharpixel
379   >17A8=>0A17                 sla     7,1
380   >17AA=>1703                 jnc     vbit4xscpon
381   >17AC=>D520 >FC79           movb    @vidws+25, *4       ; CLR
382   >17B0=>045B                 rt
383   >17B2                   vbit4xscpon:    
384   >17B2=>D50C                 movb    12, *4              ; CLR
385   >17B4=>045B                 rt
386                               
394                            Vector vbit4xchar, vidws
*** <expansion of vector>
1     >17B6                   vbit4xchar  data vidws, vbit4xchar_entry
      >17B6=>FC60 >17BA       
2     >17BA                   vbit4xchar_entry:    
*** video_bit4.i
395   >17BA=>0300 >0000           limi    0
396   >17BE=>020A >F740           li      SP,vstack + vstacksize
398   >17C2=>C020 >F7CA           mov     @vx, 0
399   >17C6=>06A0 >16B8           bl      @vbit4xsetupcursorDXDY
400                               ; R4 = VDPWI
401                               
402   >17CA=>06A0 >171A           bl      @vbit4xsetupwindowcharNXNY
403                               ; R2 = X size, R3 = Y size
404                               
405   >17CE=>06A0 >0FD8           bl      @vfetchfontchar
407   >17D2=>C320 >F7BE           mov     @vfgbg,12
408   >17D6=>06CC                 swpb    12
409   >17D8=>D1F1                 movb    *1+, 7               ; fetch first row
410   >17DA=>06A0 >17A8           bl      @vbit4xsendcharpixel  ; send first CLR
412   >17DE=>D520 >0019           movb    #0, *4              ; ARG (dix=0, diy=0, mxc=0)
413                               
414   >17E2=>0209 >B800           li      9, >B800            ; LMMC + TINP
415   >17E6=>06A0 >173E           bl      @vbit4xsetupMMMcommand
417   >17EA=>C202                 mov     2, 8                ; R8 = ctr for column
418   >17EC=>0608                 dec     8                   ; from first pixel above
419                               
420   >17EE                   vbit4xchar_row
421                               ; R7 holds char, R8 is column ctr
422                               
423   >17EE                   vb4xchp:
424                               ; see if ready
425   >17EE=>D020 >FF82           movb    @VDPST,0
426   >17F2=>1101                 jlt     vbit4xchar_pixel
427   >17F4=>10FC                 jmp     vb4xchp
429   >17F6                   vbit4xchar_pixel:    
430   >17F6=>06A0 >17A8           bl      @vbit4xsendcharpixel
431                               
432   >17FA=>0608                 dec     8
433   >17FC=>15F8                 jgt     vb4xchp
434                               
435   >17FE=>C202                 mov     2, 8
436   >1800=>D1F1                 movb    *1+, 7
437   >1802=>0603                 dec     3
438   >1804=>15F4                 jgt     vbit4xchar_row
439                                   
440   >1806=>06A0 >15EC           bl      @vstatus0
441   >180A=>0380                 rtwp
449                            Vector vbit4xcursor, vidws
*** <expansion of vector>
1     >180C                   vbit4xcursor  data vidws, vbit4xcursor_entry
      >180C=>FC60 >1810       
2     >1810                   vbit4xcursor_entry:    
*** video_bit4.i
451   >1810=>0300 >0000           limi   0
452   >1814=>020A >F740           li     SP,vstack + vstacksize
454   >1818=>C020 >F7CA           mov     @vx, 0
455   >181C=>06A0 >16B8           bl      @vbit4xsetupcursorDXDY
456                               ; R4 = VDPWI
457                               
458   >1820=>0200 >0001           li      0, 1            ; two cols
459   >1824=>06A0 >1698           bl      @vcoordsend         ; NX
460                               
461   >1828=>D020 >F7A3           movb    @vbsize+1, 0
462   >182C=>0980                 srl     0,8
463   >182E=>0600                 dec     0
464   >1830=>06A0 >1698           bl      @vcoordsend         ; NY
466   >1834=>D520 >0467           movb    #>ff, *4            ; CLR
468   >1838=>D520 >0019           movb    #0, *4              ; ARG (dix=0, diy=0, mxc=0)
469                               
470   >183C=>0209 >8300           li      9, >8300            ; LMMV + EOR
471   >1840=>06A0 >173E           bl      @vbit4xsetupMMMcommand
473   >1844=>B820 >005F >F7AA     ab  #>80,@vcurs
475   >184A=>06A0 >15EC           bl      @vstatus0
476                               ; no need to wait!
477                               
478   >184E=>0380                 rtwp
498   >1850                   vbitsetupDXDYNXNYsigned
499                               PUSH    SP,11
*** <expansion of push>
1     >1850=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1852=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
500                               
501                               ; R2 is original ARG byte, but has $8000 mask for LINE
502                               
503                               ; adjust dx and dix
504   >1854=>C021 >0002           mov @2(1) , r0   ; nx
505   >1858=>1503                 jgt vbsdns0
506                               
507   >185A=>0262 >0004           ori R2 , 4     ; DIX
508   >185E=>0740                 abs r0
509   >1860                   vbsdns0:
510                               
511                               ; adjust dy and diy
512                               
513   >1860=>C0D1                 mov *1 , r3     ; ny
514   >1862=>1503                 jgt vbsdns1
515                               
516   >1864=>0262 >0008           ori R2 , 8     ; DIY
517   >1868=>0743                 abs r3
518   >186A                   vbsdns1:
519                               
520                               ; -------------
521                               
522   >186A=>C082                 mov R2 , R2       ; is this a LINE command?
523   >186C=>1508                 jgt vbsdns2
524   >186E=>1307                 jeq vbsdns2
525                               
526   >1870=>80C0                 c r0 , r3           ; compare X and Y lengths
527   >1872=>1B05                 jh vbsdns2
528   >1874=>0262 >0001           ori R2 , 1          ; Y is major
529                               
530   >1878=>C2C3                 mov r3 , 11         ; swap DX / DY
531   >187A=>C0C0                 mov r0 , r3
532   >187C=>C00B                 mov 11 , r0
533                               
534                               ; -------------
536   >187E                   vbsdns2:    
537   >187E=>C840 >0002           mov r0 , @2(1)
538   >1882=>C443                 mov r3 , *1
540   >1884=>1002                 jmp vbsdn0
554   >1886                   vbitsetupDXDYNXNY:
555                               PUSH    SP, 11
*** <expansion of push>
1     >1886=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1888=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
556                               
557   >188A                   vbsdn0:
558   >188A=>0203 >1698           li      3, vcoordsend
559                               
560   >188E=>C021 >0006           mov     @6(1) , 0
561   >1892=>0693                 bl      *3        ; DX
563   >1894=>C021 >0004           mov     @4(1) , 0
564   >1898=>A020 >FF6E           a       @vpgrow , 0
565   >189C=>0693                 bl      *3         ; DY
567   >189E=>C021 >0002           mov     @2(1) , 0
568   >18A2=>0693                 bl      *3         ; NX
570   >18A4=>C011                 mov     *1 , 0
571   >18A6=>0693                 bl      *3        ; NY
573   >18A8=>06C2                 swpb    2
574                               
575                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >18AA=>C2FA                     mov *SP+,  11
*** video_bit4.i
576   >18AC=>045B                 rt
*** nforth.tsm
513                           	incl	kbd.i
*** kbd.i
24    >18AE                   kinit
25                                ;   reset clears all memory
27    >18AE=>C820 >29B6 >F90C     mov    #>1e03,@kbdlimit  ; 1/2 s before repeat, 1/20 s delay between repeat
28                            	
29    >18B4=>045B             	rt
45    >18B6                   scankbd	mov	11,10
      >18B6=>C28B             
47    >18B8=>04CC             	clr		12
48    >18BA=>1D15             	sbo		21		 	; clear alpha lock line
50    >18BC=>04C1             	clr		1		 	; read char
52    >18BE=>020C >0024       	li		12,>24	 	; kbd select
53    >18C2=>04C3             	clr		3			; row * >100
54    >18C4=>30C3             	ldcr	3,3		 	; set
56    >18C6=>020C >0006       	li		12,>6	 	; kbd matrix
57    >18CA=>3604             	stcr	4,8		 	; get row 0
58    >18CC=>0544             	inv		4			; 0=off 1=on
59                            	
60    >18CE=>04C5             	clr     5
61    >18D0=>9120 >03C9       	cb      #>72, 4     ; ctrl+fctn+shift+space (abort)?
62    >18D4=>1601             	jne     sknobreak
63                            	
64    >18D6=>0705             	seto    5           ; remember for later
65                            	
66    >18D8                   sknobreak:	
67    >18D8=>C084             	mov		4,2			; copy to R2=shifts
68    >18DA=>0242 >7000       	andi	2,>7000		; save 0=off 1=on (shifts)
69    >18DE=>D802 >F8E9       	movb	2,@kbdshft	; save shift
70    >18E2=>0244 >0700       	andi	4,>0700		; mask =, space, enter
71    >18E6=>1003             	jmp		skloop0
73    >18E8                   skloop:
74    >18E8=>0704             	seto	4		 	; set low bits too	
75    >18EA=>3604             	stcr	4,8		 	; read 8 bits
76    >18EC=>0544               	inv		4		 	; 0=off 1=on
77    >18EE                   skloop0:
78    >18EE=>160B             	jne		skgotsome	; any bits set?
79    >18F0=>0223 >0100       	ai		3,>100
80    >18F4=>0283 >0600       	ci		3,>600		; stop at joystick
81    >18F8=>130C             	jeq		skblank
83    >18FA=>020C >0024       	li		12,>24		; point to kbd select
84    >18FE=>30C3             	ldcr	3,3		 	; set new row #
85    >1900=>020C >0006       	li		12,>6	 	; point to matrix
86    >1904=>10F1             	jmp		skloop
88    >1906                   skgotsome:
89    >1906=>0953             	srl		3,5		 	; entry into table
90    >1908=>06C4             	swpb	4		 	; move to low byte so we can
91    >190A                   skwhich:
92    >190A=>0914             	srl		4,1			; roll down
93    >190C=>1808             	joc		skdone	 	; this bit?
94    >190E=>0583             	inc		3			; next
95    >1910=>10FC             	jmp		skwhich
97    >1912                   skblank:
98    >1912=>D801 >F8E8       	movb	1,@kbdscan	; no key whatsoever
100   >1916=>D0E0 >F8E9       	movb	@kbdshft,3	; shifts?
101   >191A=>130A             	jeq		sknone
103   >191C=>1002             	jmp		sknone0
105   >191E                   skdone:	
106   >191E=>06A0 >193A       	bl		@kbdhandle
107   >1922                   sknone0:
108   >1922=>A820 >F784 >F910     a       @timeout,@randnoise
109   >1928=>04E0 >F784           clr     @timeout
110   >192C=>06A0 >04E8       	bl     	@vscreenon
112   >1930                   sknone:
113   >1930=>D801 >F8E6       	movb	1,@kbdlast	   	; update last char
114   >1934=>A801 >F910       	a		1,@randnoise
116   >1938=>045A             	b		*10
120   >193A                   kbdhandle
131   >193A=>09B2             	srl		2,11		 	; get shift state
132                           	ai		2,grom_kbdlist	
134   >193C=>0209 >FF92           li      9,GPLRA
135   >1940=>D219             	movb	*9,8	      ; save GROM addr in R8
136   >1942=>06C8             	swpb    8
137   >1944=>D219             	movb	*9,8
138   >1946=>06C8             	swpb    8
139   >1948=>0608             	dec		8
141   >194A=>020C >FF96       	li		12,GPLWA
142   >194E=>D702             	movb	2,*12			; point to grom kbd list
143   >1950=>06C2             	swpb	2
144   >1952=>D702             	movb	2,*12
146   >1954=>0649                 dect    9
147   >1956=>D099             	movb	*9,2		   ; get table entry
148   >1958=>06C2             	swpb	2
149   >195A=>D099             	movb	*9,2		   ; it's flipped in GROM
150   >195C=>06C2             	swpb	2				
152   >195E=>A083             	a		3,2		 		; get offset
154   >1960=>D702             	movb	2,*12			; point to char
155   >1962=>06C2             	swpb	2
156   >1964=>D702             	movb	2,*12
157                           	
158   >1966=>D059             	movb	*9,1      	 	; R1=key code, 0-255
160   >1968=>D708             	movb	8,*12	    	; restore GROM addr
161   >196A=>06C8             	swpb    8
162   >196C=>D708             	movb	8,*12
164   >196E=>04CC             	clr		12
165   >1970=>1E15             	sbz		21		 	; turn on alpha lock line
166   >1972=>1F07             	tb		7
167   >1974=>1308             	jeq		khnoalpha
168                           		
169   >1976=>0281 >6100       	ci		1,>6100		; alpha lock on; 
170   >197A=>1A05             	jl		khnoalpha	; test 'a'-'z'
171   >197C=>0281 >7B00       	ci		1,>7b00
172   >1980=>1402             	jhe		khnoalpha
173   >1982=>0221 >E000       	ai		1,->2000	; uppercase
175   >1986                   khnoalpha:
176   >1986=>1D15             	sbo		21
177   >1988=>0583             	inc     3
178   >198A=>06C3             	swpb	3			; put scancode in hi byte
180   >198C                   khtestbuffer:
181   >198C=>0A14             	sla		4,1		 	; kbd_poll set?
182   >198E=>183E             	joc		khnone
184                           	; HACK!  Fctn-Shift-S is treated as Ctrl-H
185   >1990=>9060 >0B30       	cb		#211, 1
186   >1994=>1606             	jne		$0+
187   >1996=>9820 >03F9 >F8E9 	cb		#>30, @kbdshft
188   >199C=>1602             	jne		$0
189                           	
190   >199E=>0201 >0800       	li		1,>0800
191                           	
192   >19A2                   $0:
193   >19A2=>F041             	socb	1,1
194   >19A4=>1601             	jne		khbuffer   	; got something
196   >19A6=>1032             	jmp		khnone
202   >19A8                   khbuffer:	
203   >19A8=>9803 >F8E8       	cb		3,@kbdscan 	       ; scancode the same?
204   >19AC=>1611             	jne		khnew
206   >19AE=>D0A0 >F90E       	movb	@kbdflag, 2      	; get flags
207   >19B2=>B082             	ab      2,2
208   >19B4=>1705             	jnc		khb4repeat          ; repeating yet?
210   >19B6=>9820 >F8E7 >F90D 	cb		@kbdtimer,@kbddelay ; time for new repeat?
211   >19BC=>1A27             	jl		khnone
212   >19BE=>100D             	jmp		khstuff
214   >19C0                   khb4repeat:
215   >19C0=>9820 >F8E7 >F90C 	cb		@kbdtimer,@kbdlimit ; repeated long enough yet?
216   >19C6=>1A22             	jl		khnone		     	; no
217                           	
218   >19C8=>F820 >005F >F90E     socb    #>80,@kbdflag       ; set repeat flag
219                           	
220   >19CE=>1005             	jmp		khstuff
222   >19D0                   khnew:
223   >19D0=>5820 >005F >F90E 	szcb	#>80,@kbdflag	    ; clear repeat flag
224   >19D6=>D803 >F8E8       	movb	3,@kbdscan			; save new scancode
226   >19DA                   khstuff:
227   >19DA=>7820 >F8E7 >F8E7 	sb		@kbdtimer,@kbdtimer ; restart timer
229   >19E0=>C145                 mov     5,5                 ; check abort flag
230   >19E2=>1306                 jeq     khstuffit
231                               
232   >19E4=>04E0 >F8EA           clr     @kbdhead
233   >19E8=>04E0 >F90E           clr     @kbdflag
234   >19EC=>0460 >0070           b       @ABORT
236   >19F0                   khstuffit:
237   >19F0=>D0A0 >F8EB       	movb	@kbdtail,2	       	; get current pos in ring
238   >19F4=>0982                 srl     2,8
239   >19F6=>D881 >F8EC       	movb	1,@kbdbuf(2)	    ; buffer it
240   >19FA=>0582             	inc		2		     		; inc...
241   >19FC=>0242 >001F       	andi	2,kbdbufsize-1	    ; roll over if necc
242   >1A00=>06C2             	swpb	2
243   >1A02=>9802 >F8EA       	cb		2,@kbdhead	     	; overflow if equal!
244   >1A06=>1302             	jeq		khnone		     	; eeeer... don't update ptrs
246   >1A08=>D802 >F8EB       	movb	2,@kbdtail	     	; update
248   >1A0C                   khnone:
250   >1A0C                   khout:
251   >1A0C=>045B             	rt
263   >1A0E                   kbdavail 
272   >1A0E=>9820 >F8EA >F8EB 	cb		@kbdhead,@kbdtail	; EQ=1 means none
273   >1A14=>045B             	rt
285   >1A16                   kbdread	   
295   >1A16=>04C1             	clr		1
296   >1A18=>9820 >F8EA >F8EB 	cb		@kbdhead,@kbdtail
297   >1A1E=>130C             	jeq		krbempty
298   >1A20=>D060 >F8EA       	movb	@kbdhead,1			; get head ptr
299   >1A24=>B820 >01BB >F8EA 	ab		#1,@kbdhead		; and inc...
300   >1A2A=>5820 >0079 >F8EA 	szcb	#-kbdbufsize,@kbdhead	; mask...
301   >1A30=>06C1             	swpb	1					; and make offset
302   >1A32=>D021 >F8EC       	movb	@kbdbuf(1),0		; and retrieve!
303   >1A36=>0980             	srl		0,8
304   >1A38                   krbempty:
305   >1A38=>045B             	rt
*** nforth.tsm
514                           	
515                           	incl	term.i
*** term.i
30    >1A3A                   treset  	
31    >1A3A=>04E0 >F7CA       	clr	   @vx			    ; upper-left corner
32    >1A3E=>04E0 >F7C2       	clr	   @vwx			    ; window starts upper-left
33    >1A42=>D820 >F7B5 >F7C4 	movb   @vwidth+1,@vwxs	; set dims to screen size
34    >1A48=>D820 >F7B3 >F7C5 	movb   @vheight,@vwys	; set dims to screen size
35    >1A4E=>045B             	rt
55    >1A50                   window	PUSH    SP,11
*** <expansion of push>
1     >1A50=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1A52=>C68B                     mov  11, @(1-0-1)*2(SP)
*** term.i
57    >1A54=>06A0 >0A58       	bl	    @vcursoroff			; clear cursor stuff
59    >1A58=>D0A0 >F7B5       	movb   @vwidth+1,2
60    >1A5C=>9080             	cb     0,2				; check left coord
61    >1A5E=>1A01             	jl     wxlookay			; lower, okay
62    >1A60=>7000             	sb     0,0				; fix to edge
63    >1A62                   wxlookay:
64    >1A62=>D800 >F7C2       	movb   0,@vwx			; save 
65    >1A66=>B001             	ab	   1,0				; get right coord
66    >1A68=>1802             	jc	   wxxover
67    >1A6A=>9080             	cb	   0,2				; lower or equal, okay
68    >1A6C=>1203             	jle    wxhiokay			
69    >1A6E                   wxxover:
70    >1A6E=>D042             	movb	2,1
71    >1A70=>7060 >F7C2       	sb	    @vwx,1			; fix R1 to that width
72    >1A74                   wxhiokay:
73    >1A74=>D801 >F7C4       	movb	1,@vwxs
75    >1A78=>06C0             	swpb	0				; point to Y 
76    >1A7A=>06C1             	swpb	1				; coordinates
77    >1A7C=>D0A0 >F7B3       	movb   @vheight, 2
79    >1A80=>9080             	cb     0,2				; check top coord
80    >1A82=>1201             	jle    wylookay			; lower, okay
81    >1A84=>7000             	sb     0,0				; fix to edge
82    >1A86                   wylookay:
83    >1A86=>D800 >F7C3       	movb   0,@vwy		    ; save 
84    >1A8A=>B001             	ab     1,0				; get bottom coord
85    >1A8C=>1802             	jc     wyyover
86    >1A8E=>9080             	cb     0,2				; lower or equal, okay
87    >1A90=>1203             	jle    wyhiokay			
88    >1A92                   wyyover:
89    >1A92=>D042             	movb   2,1
90    >1A94=>7060 >F7C3       	sb     @vwy,1				; fix R1 to that height
91    >1A98                   wyhiokay:
92    >1A98=>D801 >F7C5       	movb   1,@vwys
94    >1A9C=>04E0 >F7CA       	clr	   @vx				; clear coords
96                                POP    SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1AA0=>C2FA                     mov *SP+,  11
*** term.i
97    >1AA2=>045B             	rt
106   >1AA4                   printchar PUSH  SP, 11
*** <expansion of push>
1     >1AA4=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1AA6=>C68B                     mov  11, @(1-0-1)*2(SP)
*** term.i
107   >1AA8=>06A0 >0A58       	bl	    @vcursoroff			; we're movin', buddy!
109   >1AAC=>D801 >F7C0       	movb	1,@vch
110   >1AB0=>C060 >F79C       	mov	    @vdrawchar,1
111   >1AB4=>0411             	blwp	*1  				; print char
113   >1AB6=>B820 >01BB >F7CA 	ab	    #1,@vx	     		; add a space
114   >1ABC=>1804             	jc	    prchwr				; carried, thus wrapped
115   >1ABE=>9820 >F7CA >F7C4 	cb	    @vx,@vwxs			; edge of window?
116   >1AC4=>1A02             	jl	    prchout				; no, we're okay
117   >1AC6                   prchwr:
118   >1AC6=>06A0 >1BB8       	bl	    @crlf
120   >1ACA                   prchout:
121                               POP SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1ACA=>C2FA                     mov *SP+,  11
*** term.i
122   >1ACC=>045B             	rt
132   >1ACE                   gotoxy	PUSH SP, 11
*** <expansion of push>
1     >1ACE=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1AD0=>C68B                     mov  11, @(1-0-1)*2(SP)
*** term.i
134   >1AD2=>06A0 >0A58       	bl	    @vcursoroff			; we're moving it!
136   >1AD6=>9800 >F7C4       	cb	    0,@vwxs
137   >1ADA=>1A04             	jl	    gxyokayx
138   >1ADC=>D020 >F7C4       	movb	@vwxs,0
139   >1AE0=>7020 >01BB       	sb 	    #1,0
140   >1AE4                   gxyokayx:
141   >1AE4=>06C0             	swpb	0
142   >1AE6=>9800 >F7C5       	cb	    0,@vwys
143   >1AEA=>1A04             	jl	    gxyokayy
144   >1AEC=>D020 >F7C5       	movb	@vwys,0
145   >1AF0=>7020 >01BB       	sb	    #1,0
146   >1AF4                   gxyokayy:
147   >1AF4=>06C0             	swpb	0
148   >1AF6=>C800 >F7CA       	mov	    0,@vx
150                               POP     SP, 11    
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1AFA=>C2FA                     mov *SP+,  11
*** term.i
151   >1AFC=>045B             	rt
164   >1AFE                   termscroll
165                               PUSH    SP,11
*** <expansion of push>
1     >1AFE=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1B00=>C68B                     mov  11, @(1-0-1)*2(SP)
*** term.i
166                               
167   >1B02=>C0E0 >F7A0           mov     @vclearline, 3
169   >1B06=>D0A0 >F7C4           movb    @vwxs,2             ; length
170   >1B0A=>0982                 srl     2,8
172   >1B0C=>C020 >F7CA           mov     @vx,0
173   >1B10=>7000                 sb      0,0                 ; get coord for lower-left
174                               
175   >1B12=>064A                 dect    SP
176   >1B14=>C682                 mov     2,*SP
177   >1B16=>0693                 bl      *3
178                               
179   >1B18=>0580                 inc     0
180   >1B1A=>06C0                 swpb    0
181   >1B1C=>9800 >F7C5           cb      0,@vwys
182   >1B20=>1A01                 jl      termscroll1
183   >1B22=>7000                 sb      0,0
184   >1B24                   termscroll1
185   >1B24=>06C0                 swpb    0
186   >1B26=>C0BA                 mov     *SP+,2     
187   >1B28=>0693                 bl      *3
189                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1B2A=>C2FA                     mov *SP+,  11
*** term.i
190   >1B2C=>045B                 rt
193   >1B2E                   termclear
194                               PUSH    SP,0,2,3,11
*** <expansion of push>
1     >1B2E=>022A >FFF8           ai SP, -4*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1B32=>CA80 >0006               mov  0 , @(4-0-1)*2(SP)
2     >1B36=>CA82 >0004               mov  2 , @(4-1-1)*2(SP)
3     >1B3A=>CA83 >0002               mov  3 , @(4-2-1)*2(SP)
4     >1B3E=>C68B                     mov  11, @(4-3-1)*2(SP)
*** term.i
195   >1B40=>04C0                 clr     0
196   >1B42=>C0E0 >F7A0           mov     @vclearline,3
197   >1B46=>064A                 dect    SP
198   >1B48=>D0A0 >F7C4           movb    @vwxs,2             ; length
199   >1B4C=>0982                 srl     2,8
200   >1B4E                   termclear0
201   >1B4E=>C682                 mov     2,*SP
202   >1B50=>0693                 bl      *3
203   >1B52=>C09A                 mov     *SP,2
204   >1B54=>0580                 inc     0
205   >1B56=>06C0                 swpb    0
206   >1B58=>9800 >F7C5           cb      0,@vwys
207   >1B5C=>1302                 jeq     termclear1
208   >1B5E=>06C0                 swpb    0
209   >1B60=>10F6                 jmp     termclear0
210   >1B62                   termclear1
211   >1B62=>04E0 >F7CA           clr     @vx
212   >1B66=>05CA                 inct    SP
213                               POP     SP,0,2,3,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1B68=>C2FA                     mov *SP+,  11
2     >1B6A=>C0FA                     mov *SP+,  3 
3     >1B6C=>C0BA                     mov *SP+,  2 
4     >1B6E=>C03A                     mov *SP+,  0 
*** term.i
214   >1B70=>045B                 rt        
215                               
221   >1B72                   bksp	PUSH   SP, 1, 2, 11
*** <expansion of push>
1     >1B72=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1B76=>CA81 >0004               mov  1 , @(3-0-1)*2(SP)
2     >1B7A=>CA82 >0002               mov  2 , @(3-1-1)*2(SP)
3     >1B7E=>C68B                     mov  11, @(3-2-1)*2(SP)
*** term.i
223   >1B80=>06A0 >0A58       	bl	@vcursoroff
225   >1B84=>D060 >F7CA       	movb	@vx,1				; get x
226   >1B88=>7060 >01BB       	sb	    #1,1				; decrement
227   >1B8C=>180F             	jc	    bksp0				; 0 -> -1?
229   >1B8E=>D060 >F7C4       	movb	@vwxs,1				; yup, move to other edge
230   >1B92=>7060 >01BB       	sb	    #1,1			
231   >1B96=>D0A0 >F7CB       	movb	@vy,2				; and decrement
232   >1B9A=>70A0 >01BB       	sb	    #1,2				; Y
233   >1B9E=>1804             	jc	    bksp1				; 0 -> -1?
234   >1BA0=>D0A0 >F7C5       	movb	@vwys,2				; move to bottom
235   >1BA4=>70A0 >01BB       	sb	    #1,2
236   >1BA8                   bksp1	movb	2,@vy				; save
      >1BA8=>D802 >F7CB       
237   >1BAC                   bksp0	movb	1,@vx				; save
      >1BAC=>D801 >F7CA       
239                               POP SP, 1, 2, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1BB0=>C2FA                     mov *SP+,  11
2     >1BB2=>C0BA                     mov *SP+,  2 
3     >1BB4=>C07A                     mov *SP+,  1 
*** term.i
240   >1BB6=>045B             	rt
247   >1BB8                   crlf    PUSH    SP, 1, 11
*** <expansion of push>
1     >1BB8=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1BBC=>CA81 >0002               mov  1 , @(2-0-1)*2(SP)
2     >1BC0=>C68B                     mov  11, @(2-1-1)*2(SP)
*** term.i
249   >1BC2=>06A0 >0A58           bl      @vcursoroff         ; we're moving cursor
251   >1BC6=>7820 >F7CA >F7CA     sb      @vx,@vx             ; reset X coord
252   >1BCC=>B820 >01BB >F7CB     ab      #1,@vy               ; next line
253   >1BD2=>1804                 jc      crlfc               ; wrapped?
254   >1BD4=>9820 >F7CB >F7C5     cb      @vy,@vwys           ; bottom of window?
255   >1BDA=>1A03                 jl      crlf0
256   >1BDC                   crlfc:
257   >1BDC=>7820 >F7CB >F7CB     sb      @vy,@vy
259   >1BE2                   crlf0:
261   >1BE2=>9820 >F7CB >F7C6     cb      @vy,@vwcy
262   >1BE8=>1305                 je      crlf1
263   >1BEA=>D820 >F7CB >F7C6     movb    @vy,@vwcy
264   >1BF0=>06A0 >1AFE           bl      @termscroll
266   >1BF4                   crlf1:
267                               POP     SP, 1, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1BF4=>C2FA                     mov *SP+,  11
2     >1BF6=>C07A                     mov *SP+,  1 
*** term.i
268   >1BF8=>045B                 rt
276   >1BFA                   tab	PUSH    SP, 1, 11
*** <expansion of push>
1     >1BFA=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1BFE=>CA81 >0002               mov  1 , @(2-0-1)*2(SP)
2     >1C02=>C68B                     mov  11, @(2-1-1)*2(SP)
*** term.i
277   >1C04=>CA81 >0002       	mov	1,@2(SP)
278   >1C08=>C68B             	mov	11,*SP
280   >1C0A                   tab0	li	1,>2000
      >1C0A=>0201 >2000       
281   >1C0E=>06A0 >1AA4       	bl	@printchar  			; print a space
282   >1C12=>D060 >F7CA       	movb	@vx,1
283   >1C16=>0241 >0700       	andi	1,>0700				; if not on 8-char boundary
284   >1C1A=>16F7             	jne	tab0				; repeat
286                               POP     SP, 1, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1C1C=>C2FA                     mov *SP+,  11
2     >1C1E=>C07A                     mov *SP+,  1 
*** term.i
287   >1C20=>045B             	rt
290   >1C22                   clreol  PUSH    SP, 0, 2, 3, 11
*** <expansion of push>
1     >1C22=>022A >FFF8           ai SP, -4*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1C26=>CA80 >0006               mov  0 , @(4-0-1)*2(SP)
2     >1C2A=>CA82 >0004               mov  2 , @(4-1-1)*2(SP)
3     >1C2E=>CA83 >0002               mov  3 , @(4-2-1)*2(SP)
4     >1C32=>C68B                     mov  11, @(4-3-1)*2(SP)
*** term.i
292   >1C34=>C0E0 >F7A0           mov     @vclearline, 3
294   >1C38=>D0A0 >F7C4           movb    @vwxs,2             ; length
295   >1C3C=>0982                 srl     2,8
297   >1C3E=>C020 >F7CA           mov     @vx,0
298   >1C42=>7000                 sb      0,0                 ; get coord for lower-left
299                               
300   >1C44=>0693                 bl      *3
301                               
302                               POP     SP, 0, 2, 3, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1C46=>C2FA                     mov *SP+,  11
2     >1C48=>C0FA                     mov *SP+,  3 
3     >1C4A=>C0BA                     mov *SP+,  2 
4     >1C4C=>C03A                     mov *SP+,  0 
*** term.i
303   >1C4E=>045B                 rt
304                               
311   >1C50                   emit
312   >1C50=>9801 >115F           cb      1,#>0d           ; enter?
313   >1C54=>13B1                 jeq     crlf
315   >1C56                   $1:  cb     1,#>07          ; bell?
      >1C56=>9801 >004E       
316   >1C5A=>130B                 jeq     bell
318   >1C5C                   $1:  cb     1,#>08          ; backspace?
      >1C5C=>9801 >0A14       
319   >1C60=>1388                 jeq     bksp
321   >1C62                   $1:  cb     1,#>09          ; tab?
      >1C62=>9801 >0220       
322   >1C66=>13C9                 jeq     tab
323                               
324   >1C68                   $1: cb      1,#>0B          ; vertical tab ( == clear to end of line )
      >1C68=>9801 >002D       
325   >1C6C=>13DA                 jeq     clreol
326                                   
327   >1C6E=>0460 >1AA4           b       @printchar
328                               
330   >1C72                   bell:    
331   >1C72=>045B                 rt
340   >1C74                   type PUSH    SP,11
*** <expansion of push>
1     >1C74=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1C76=>C68B                     mov  11, @(1-0-1)*2(SP)
*** term.i
341   >1C78=>022A >FFFC           ai      SP,-4
342   >1C7C                   $1: mov     3,3
      >1C7C=>C0C3             
343   >1C7E=>130B                 jeq     $2+
344   >1C80=>D072                 movb    *2+,1
345   >1C82=>C682                 mov     2, *SP
346   >1C84=>CA83 >0002           mov     3, @2(SP)
347   >1C88=>06A0 >1C50           bl      @emit
348   >1C8C=>C0EA >0002           mov     @2(SP), 3
349   >1C90=>C09A                 mov     *SP, 2
350   >1C92=>0603                 dec     3
351   >1C94=>10F3                 jmp     $1-
352   >1C96                   $2: ai      SP,4
      >1C96=>022A >0004       
353                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1C9A=>C2FA                     mov *SP+,  11
*** term.i
354   >1C9C=>045B                 rt
355                           	
*** nforth.tsm
517                           	incl	dev.i
*** dev.i
29    >1C9E                   haa	byte	>aa
      >1C9E=>AA             
30    >1C9F=>00             	byte	0
32    >1CA0                   dinit	li	0,>3ffe        ; steal an extra byte to avoid having DSRs wraparound
      >1CA0=>0200 >3FFE       
33    >1CA4=>C800 >FB70       	mov	0,@vdplimit			; set up 16k VDP RAM
35    >1CA8=>02E0 >FBE0       	lwpi	cpurambase + >e0  				; be standard
36    >1CAC=>020D >FF90       	li	13,GPLRD
37    >1CB0=>020E >0100       	li	14,>100
38    >1CB4=>020F >FF8A       	li	15,VDPWA
40    >1CB8=>020C >0F00       	li	12,>0f00			; start below first DSR
41    >1CBC                   di00	sbz	0
      >1CBC=>1E00             
42    >1CBE=>B320 >01BB       	ab	#1,12				; point to next DSR
43    >1CC2=>028C >2000       	ci	12,>2000
44    >1CC6=>1410             	jhe	diout				; done
46    >1CC8=>1D00             	sbo	0					; turn on ROM
47    >1CCA=>9820 >4000 >1C9E 	cb	@>4000,@haa			; legal rom?
48    >1CD0=>16F5             	jne	di00				; nope
50    >1CD2=>C060 >4004       	mov	@>4004,1			; get init ptr
51    >1CD6=>13F2             	jeq	di00				; none
52    >1CD8                   di01	mov	@2(1),11			; get addr for init
      >1CD8=>C2E1 >0002       
53    >1CDC=>C80C >FBD0       	mov	12,@cpurambase + >d0
54    >1CE0=>069B             	bl	*11				; call powerup routine
55    >1CE2=>C051             	mov	*1,1				; get next powerup
56    >1CE4=>16F9             	jne	di01				; if it exists
57    >1CE6=>10EA             	jmp	di00
59    >1CE8                   diout	lwpi	mainws				; restore WP
      >1CE8=>02E0 >FC00       
60    >1CEC=>045B             	rt
74    >1CEE                   noemuerr db	"No emulated disk DSR found!",>ff
      >1CEE=>4E6F >2065 >6D75 
      >1CF4=>6C61 >7465 >6420 
      >1CFA=>6469 >736B >2044 
      >1D00=>5352 >2066 >6F75 
      >1D06=>6E64 >21FF       
75    >1D0A=>506C >6561 >7365 	db	"Please install the emulated disk DSR",>ff
      >1D10=>2069 >6E73 >7461 
      >1D16=>6C6C >2074 >6865 
      >1D1C=>2065 >6D75 >6C61 
      >1D22=>7465 >6420 >6469 
      >1D28=>736B >2044 >5352 
      >1D2E=>FF             
76    >1D2F=  >62 >7920 >6164 	db	"by adding 'EmuDisk' to the DSRCombo",>ff
      >1D34=>6469 >6E67 >2027 
      >1D3A=>456D >7544 >6973 
      >1D40=>6B27 >2074 >6F20 
      >1D46=>7468 >6520 >4453 
      >1D4C=>5243 >6F6D >626F 
      >1D52=>FF             
77    >1D53=  >76 >6172 >6961 	db	"variable in FORTH.CNF.",>ff,>ff
      >1D58=>626C >6520 >696E 
      >1D5E=>2046 >4F52 >5448 
      >1D64=>2E43 >4E46 >2EFF 
      >1D6A=>FF             
78    >1D6B=  >28 >5365 >6520 	db	"(See DISKS.TXT for info.)",>ff,>ff
      >1D70=>4449 >534B >532E 
      >1D76=>5458 >5420 >666F 
      >1D7C=>7220 >696E >666F 
      >1D82=>2E29 >FFFF       
79    >1D86=>5072 >6573 >7320 	db	"Press Ctrl+Break to halt."
      >1D8C=>4374 >726C >2B42 
      >1D92=>7265 >616B >2074 
      >1D98=>6F20 >6861 >6C74 
      >1D9E=>2E             
80    >1D9F=>00             	db	0
82    >1DA0                   forthdskdef db	"FORTHDSK  "
      >1DA0=>464F >5254 >4844 
      >1DA6=>534B >2020       
83    >1DAA                   	even
85    >1DAA                   diskinit dect	SP
      >1DAA=>064A             
86    >1DAC=>C68B             	mov	11,*SP
88    >1DAE=>02E0 >FBE0           lwpi    cpurambase + >E0           ; be standard and avoid having the ROM clobber our workspace ;)
89                                
90    >1DB2=>020C >1000       	li	12,>1000			; DSR base for emulated DSR
91    >1DB6=>1D00             	sbo	0				; turn on
92    >1DB8=>9820 >1C9E >4000 	cb	@haa,@>4000			; installed?
93    >1DBE=>1301             	jeq	dskiokay
95                            	;li	2,noemuerr			; print error message
96                            	;b	@dieerr
97    >1DC0=>100C             	jmp dskiignore
99    >1DC2                   dskiokay:
100   >1DC2=>1E00             	sbz	0
102   >1DC4=>02E0 >FC00           lwpi    mainws          
103                               
104   >1DC8=>0200 >1DA0       	li	0,forthdskdef
105   >1DCC=>0201 >F936       	li	1,forthdsk
106   >1DD0=>0202 >000A       	li	2,10
107   >1DD4                   dskifn	movb	*0+,*1+
      >1DD4=>DC70             
108   >1DD6=>0602             	dec	2
109   >1DD8=>15FD             	jgt	dskifn
111   >1DDA                   dskiignore:
112   >1DDA=>C2FA             	mov	*SP+,11
113   >1DDC=>045B             	rt
115   >1DDE                   vsbw	dect	SP
      >1DDE=>064A             
116   >1DE0=>C68B             	mov	11,*SP
117   >1DE2=>06A0 >0454       	bl	@vwaddr
118   >1DE6=>D801 >FF88       	movb	1,@VDPWD
119   >1DEA=>C2FA             	mov	*SP+,11
120   >1DEC=>045B             	rt
123   >1DEE                   vsbr	dect	SP
      >1DEE=>064A             
124   >1DF0=>C68B             	mov	11,*SP
125   >1DF2=>06A0 >0458       	bl	@vraddr
126   >1DF6=>D060 >FF80       	movb	@VDPRD,1
127   >1DFA=>C2FA             	mov	*SP+,11
128   >1DFC=>045B             	rt
131   >1DFE                   equals	db	>20
      >1DFE=>20             
132   >1DFF                   period	db	"."
      >1DFF=>2E             
145   >C000                   DSRVBASE equ >C000
147   >1E00                   dsrlnk	data	dskws,dsrlnk+4
      >1E00=>FC20 >1E04       
148   >1E04=>0300 >0000       	limi   0
149   >1E08=>C2A0 >FC14       	mov    @mainws + 20, SP    ; use same stack as main
151   >1E0C=>0200 >C000           li      0, DSRVBASE
152   >1E10=>D0A0 >FF6C           movb    @vpob, 2
153   >1E14=>7802 >FF6C           sb      2, @vpob
154   >1E18=>06A0 >178C           bl      @vsetbank          ; set VDP bank for DSR operations
155                               
156   >1E1C=>0208 >FB00           li      8,cpurambase         ; cpuram base
157                               
158   >1E20=>C16D >0002       	mov	   @2(13),5			; get offset
159   >1E24=>53E0 >1DFE       	szcb   @equals,15			; no error
160   >1E28=>C028 >0056       	mov	   @>56(8),0			; get ptr to name
161   >1E2C=>C240             	mov	   0,9				
162   >1E2E=>0229 >FFF8       	ai     9,-8				; point to error code
164   >1E32=>06A0 >1DEE       	bl     @vsbr				; get len
165   >1E36=>D0C1             	movb   1,3				; save
166   >1E38=>0983             	srl    3,8				
167   >1E3A=>0704             	seto   4				; # chars
169   >1E3C=>0202 >FB4A       	li     2,cpurambase + >4a				; buffer
170   >1E40                   dsr00	
171   >1E40=>0580                 inc     0    				; move device name
172   >1E42=>0584             	inc    4
173   >1E44=>80C4             	c      4,3
174   >1E46=>1306             	jeq    dsr01
175   >1E48=>06A0 >1DEE       	bl     @vsbr
176   >1E4C=>DC81             	movb   1,*2+
177   >1E4E=>9801 >1DFF       	cb	   1,@period
178   >1E52=>16F6             	jne	   dsr00
179   >1E54                   dsr01	
180   >1E54=>C104                 mov	   4,4				; any chars read?
181   >1E56=>1344             	jeq	   dsr09
182   >1E58=>0284 >0007       	ci	   4,7
183   >1E5C=>1541             	jgt	   dsr09				; too many?
184   >1E5E=>04E8 >00D0       	clr	   @>d0(8)
185   >1E62=>CA04 >0054       	mov    4,@>54(8)			; # chars in device name
186   >1E66=>0584             	inc	   4
187   >1E68=>AA04 >0056       	a      4,@>56(8)			; point to '.' in name
188   >1E6C=>02E0 >FBE0       	lwpi   cpurambase + >e0				; GPLWS
189   >1E70=>04C1             	clr    1				; init card counter
190   >1E72=>020C >0F00       	li     12,>f00
191   >1E76                   dsr03	
192   >1E76=>1E00                 sbz     0
193   >1E78=>022C >0100       	ai     12,>100				; start scan at >1000
194   >1E7C=>04E8 >00D0       	clr    @>d0(8)
195   >1E80=>028C >2000       	ci     12,>2000			; last base?
196   >1E84=>132B             	jeq    dsr08
197   >1E86=>CA0C >00D0       	mov    12,@>d0(8)			; store CRU
198   >1E8A=>1D00             	sbo    0				; turn on rom
199   >1E8C=>0202 >4000       	li     2,>4000
200   >1E90=>9812 >1C9E       	cb     *2,@haa				; legal rom?
201   >1E94=>16F0             	jne    dsr03
202   >1E96=>A0A0 >FC2A       	a      @dskws+10,2			; add offset
203   >1E9A=>1003             	jmp    dsr05
204   >1E9C                   dsr04	
205   >1E9C=>C0A8 >00D2           mov     @>d2(8),2
206   >1EA0=>1D00             	sbo    0
207   >1EA2                   dsr05	
208   >1EA2=>C092                 mov	    *2,2				; any devices?
209   >1EA4=>13E8             	jeq	   dsr03		    		; nope... next rom pleez
210   >1EA6=>CA02 >00D2       	mov    2,@>d2(8)			; save next link
211   >1EAA=>05C2             	inct   2
212   >1EAC=>C272             	mov    *2+,9				; get routine addr
213   >1EAE=>D168 >0055       	movb   @>55(8),5			; get len of caller
214   >1EB2=>1309             	jeq    dsr07				; ??? no length?
215   >1EB4=>9C85             	cb     5,*2+				; match name
216   >1EB6=>16F2             	jne    dsr04
217   >1EB8=>0985             	srl    5,8
218   >1EBA=>0206 >FB4A       	li     6,>4a + cpurambase
219   >1EBE                   dsr06	
220   >1EBE=>9CB6                 cb      *6+,*2+
221   >1EC0=>16ED             	jne    dsr04
222   >1EC2=>0605             	dec    5
223   >1EC4=>16FC             	jne    dsr06
224   >1EC6                   dsr07	
225   >1EC6=>0581                 inc     1	    			; increment card #
226   >1EC8=>0699             	bl     *9				; run it
227   >1ECA=>10E8             	jmp    dsr04				; if no error, skip this word
228   >1ECC=>1E00             	sbz    0				; turn off rom
229   >1ECE=>02E0 >FC20       	lwpi   dskws				
230   >1ED2=>C009             	mov    9,0				; get error code (cpurambase + >F2)
231   >1ED4=>06A0 >1DEE       	bl     @vsbr
232   >1ED8=>09D1             	srl    1,13				; any error?
233   >1EDA=>1003             	jmp	   dsr10
234   >1EDC                   dsr08	
235   >1EDC=>02E0 >FC20           lwpi   dskws
236   >1EE0                   dsr09
237   >1EE0=>04C1             	clr	   1
238   >1EE2                   dsr10	
239                               ;swpb   1
240   >1EE2=>C741             	mov	    1,*13
241   >1EE4=>F3E0 >1DFE       	socb	@equals,15
242                           	
243   >1EE8=>04C0                 clr     0
244   >1EEA=>06A0 >178C           bl      @vsetbank       ; back to bank 0 for std modes
245                           	
246   >1EEE=>D802 >FF6C       	movb 2, @vpob
247   >1EF2=>0380             	rtwp
250   >1EF4                   vmbw    
251   >1EF4=>064A                 dect    SP
252   >1EF6=>C68B                 mov     11,*SP
253   >1EF8=>06A0 >0454           bl      @vwaddr
254   >1EFC                   vmbw0   
255   >1EFC=>D831 >FF88           movb    *1+,@VDPWD
256   >1F00=>0602                 dec     2
257   >1F02=>15FC                 jgt     vmbw0
258   >1F04=>C2FA                 mov     *SP+,11
259   >1F06=>045B                 rt
262   >1F08                   vmbr    
263   >1F08=>064A                 dect    SP
264   >1F0A=>C68B                 mov     11,*SP
265   >1F0C=>06A0 >0458           bl      @vraddr
266   >1F10                   vmbr0   
267   >1F10=>DC60 >FF80           movb    @VDPRD,*1+
268   >1F14=>0602                 dec     2
269   >1F16=>15FC                 jgt     vmbr0
270   >1F18=>C2FA                 mov     *SP+,11
271   >1F1A=>045B                 rt
288   >1F1C                   rblockpab db    >01,>14
      >1F1C=>0114             
289   >1F1E                   wblockpab db    >01,>15
      >1F1E=>0115             
291   >1F20                   rwblock  data    dskws,rwblock + 4
      >1F20=>FC20 >1F24       
292   >1F24=>0300 >0000           limi    0
293   >1F28=>020A >F936           li      SP,dskstack + dskstacksize
295   >1F2C=>064A                 dect    SP
296   >1F2E=>D6A0 >FF6C           movb    @vpob, *SP
297                               
298   >1F32=>781A >FF6C           sb      *SP, @vpob
299   >1F36=>0200 >C000           li      0, DSRVBASE
300   >1F3A=>06A0 >178C           bl      @vsetbank          ; set VDP bank for DSR operations
302   >1F3E=>0208 >FB00           li      8, cpurambase            ; CPU RAM base
303                               
304   >1F42=>C32D >0018           mov     @24(13), 12
305                               
306   >1F46=>C028 >0070           mov     @>70(8), 0
307   >1F4A=>0220 >FC00           ai      0,-1024
308   >1F4E=>C060 >F79A           mov     @vfree, 1
309   >1F52=>0241 >3FFF           andi    1, >3FFF
310   >1F56=>8040                 c       0, 1
311   >1F58=>1403                 jhe     $0+
312                               
313   >1F5A=>D760 >0014           movb    #4, *13             ; not enough memory!
314   >1F5E=>103D                 jmp     $1+
315                                
316   >1F60                   $0:
317   >1F60=>C1C0                 mov     0, 7
318                               
319   >1F62=>0220 >FFF0           ai      0,->10
320   >1F66=>0201 >F936           li      1,forthdsk
321   >1F6A=>0202 >000A           li      2,10
322   >1F6E=>06A0 >1EF4           bl      @vmbw               ; set filename
323   >1F72=>CA00 >004E           mov     0,@>4e(8)
325   >1F76=>0203 >0004           li      3,4                 ; # secs to read/write
326   >1F7A=>C06C >0004           mov     @4(12),1            ; CPU addr
327                               
328   >1F7E=>C16C >0002           mov     @2(12),5            ; block #
329   >1F82=>0A25                 sla     5,2                 ; sector #
330                               
331   >1F84=>04C4                 clr     4
332   >1F86=>3D20 >29B8           div     #360, 4             ; sector -> disk
333   >1F8A=>0584                 inc     4                   ; 0-based to 1-based
334   >1F8C=>06C4                 swpb    4
335   >1F8E=>DA04 >004C           movb    4, @>4C(8)          ; disk #
336                               
337   >1F92=>0206 >1F1E           li      6,wblockpab
338   >1F96=>C11C                 mov     *12,4
339   >1F98=>1302                 jeq     rblks
340   >1F9A=>0206 >1F1C           li      6,rblockpab
341                               
342   >1F9E                   rblks 
343   >1F9E=>DA20 >0014 >004D     movb    #4, @>4D(8)         ; four sectors
344   >1FA4=>04E8 >0050           clr     @>50(8)              ; parms @>00 + rambase
346   >1FA8=>C607                 mov     7,*8             ; VDP buff addr 
347   >1FAA=>CA05 >0002           mov     5,@2(8)          ; sector #
349   >1FAE=>0202 >0400           li      2,1024
350                               
351   >1FB2=>C104                 mov     4,4
352   >1FB4=>1603                 jne     rblks0
354   >1FB6=>C007                 mov     7,0
355   >1FB8=>06A0 >1EF4           bl      @vmbw               ; move block to VDP for write
356                               
357   >1FBC                   rblks0:
358   >1FBC=>06A0 >1FE6           bl      @dodsr              ; do op
359                               
360   >1FC0=>04DC                 clr     *12
361   >1FC2=>DB28 >0050 >0001     movb    @>50(8),@1(12)
362   >1FC8=>1606                 jne     rwblkerr
364   >1FCA=>C104                 mov     4,4
365   >1FCC=>1303                 jeq     wblks0
366                               
367   >1FCE=>C007                 mov     7,0
368   >1FD0=>06A0 >1F08           bl      @vmbr               ; copy block from VDP for read
370   >1FD4                   wblks0:
371   >1FD4=>1002                 jmp     $1+
373   >1FD6                   rwblkerr movb @>50(8),*13
      >1FD6=>D768 >0050       
374   >1FDA                   $1:
375   >1FDA=>04C0                 clr     0
376   >1FDC=>06A0 >178C           bl      @vsetbank       ; back to bank 0 for std modes
377   >1FE0=>D83A >FF6C           movb    *SP+, @vpob
378                               
379   >1FE4=>0380                 rtwp
391   >1FE6                   dodsr   mov 6,@>e0+12(8) 
      >1FE6=>CA06 >00EC       
392   >1FEA=>02E0 >FBE0           lwpi    cpurambase + >e0               ; be standard
393   >1FEE=>020D >FF90           li      13,GPLRD
394   >1FF2=>020E >0100           li      14,>100
395   >1FF6=>020F >FF8A           li      15,VDPWA
397   >1FFA=>0208 >FB00           li      8,cpurambase             ; CPU RAM base
398   >1FFE=>020C >1000           li      12,>1000            ; our CRU base
399   >2002=>1D00                 sbo     0               ; turn it on
401   >2004=>0201 >400A           li      1,>400A             ; subprograms
402   >2008=>C051                 mov     *1,1
403   >200A=>1306                 jeq     dodsrerr
404   >200C                   dodsrfnd 
405   >200C=>C0A1 >0004           mov     @4(1),2             ; complete name
406   >2010=>8582                 c       2,*6                ; same name?
407   >2012=>1306                 jeq     dodsrrun
408   >2014=>C051                 mov     *1,1                ; get next
409   >2016=>16FA                 jne     dodsrfnd
411   >2018                   dodsrerr 
412   >2018=>DA20 >0467 >0050     movb    #>ff,@>50(8)         ; fake error
413   >201E=>1006                 jmp     dodsrout
415   >2020                   dodsrrun 
416   >2020=>C2E1 >0002           mov     @2(1),11                ; get addr
417   >2024=>CA0C >00D0           mov     12,@>d0(8)           ; save CRU addr
418   >2028=>069B                 bl      *11             ; call routine
419   >202A=>1000                 nop                 ; error 
421   >202C                   dodsrout 
422   >202C=>020C >1000           li      12,>1000 
423   >2030=>1E00                 sbz     0               ; turn off ROM
424                               
425   >2032=>02E0 >FC20           lwpi    dskws
426   >2036=>045B                 rt
427                           	
*** nforth.tsm
518                               incl    sound.i
*** sound.i
22    >2038                   sndinit
23                                PUSH    SP, 11
*** <expansion of push>
1     >2038=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >203A=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
24    >203C=>0200 >9FBF           li     0, >9FBF
25    >2040=>0202 >000A           li     2, 10
26    >2044=>0201 >FFA0           li     1, SOUND
27                                
28                                ; first iter: clear out console chip;
29                                ; next four iters: clear out extra chips
30                                ;
31                                ; on each iter, send the volume off and effect off commands for each voice 
32    >2048                   $0:    
33    >2048=>D440                 movb   0, *1
34    >204A=>D840 >0002           movb   0, @2(1)
35    >204E=>06C0                 swpb   0
36    >2050=>D440                 movb   0, *1
37    >2052=>D840 >0002           movb   0, @2(1)
38    >2056=>0200 >DFFF           li     0, >DFFF
39    >205A=>D440                 movb   0, *1
40    >205C=>D840 >0002           movb   0, @2(1)
41    >2060=>06C0                 swpb   0
42    >2062=>D440                 movb   0, *1
43    >2064=>D840 >0002           movb   0, @2(1)
44    >2068=>0642                 dect   2
45    >206A=>1703                 jnc	   $1+
46    >206C=>C062 >22CE       	mov    @snd_voice_ports(2), 1
47    >2070=>10EB             	jmp    $0    
48    >2072                   $1:    
49    >2072=>04E0 >FF68           clr     @sndlist
50    >2076=>06A0 >24E0           bl      @snd_seq_init
51                                POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >207A=>C2FA                     mov *SP+,  11
*** sound.i
52                                
53    >207C=>045B                 rt
59    >207E                   sndfetch1
60    >207E=>D0F0                 movb    *0+, 3
61    >2080=>045B                 rt
62    >2082                   sndfetchv
63    >2082=>0580                 inc     0
64    >2084=>D0D4                 movb    *4, 3
65    >2086=>045B                 rt
66                                
67                             Vector soundlist, vidws
*** <expansion of vector>
1     >2088                   soundlist  data vidws, soundlist_entry
      >2088=>FC60 >208C       
2     >208C                   soundlist_entry:    
*** sound.i
68                             
69                                ; check active duration
70    >208C=>D020 >FF6A           movb    @snddur, 0
71    >2090=>1304                 jeq     $0+
72                               
73    >2092=>7820 >01BB >FF6A     sb      #1, @snddur
74    >2098=>1623                 jne     $3+
75                                 
76    >209A                   $0:    
77                             
78    >209A=>C020 >FF68           mov     @sndlist, 0
79    >209E=>1320                 jeq     $3+
80                                
81    >20A0=>0202 >207E           li      2, sndfetch1
82                                
83    >20A4=>D060 >FF67           movb    @sndflags, 1
84    >20A8=>0A11                 sla     1, 1
85    >20AA=>1706                 jnc     $1+
86                                
87    >20AC=>06A0 >0458           bl      @vraddr
88    >20B0=>0204 >FF80           li      4, VDPRD
89    >20B4=>0202 >2082           li      2, sndfetchv
90                                 
91    >20B8                   $1: 
92    >20B8=>0692                 bl      *2
93    >20BA=>1310                 jeq     $5+         ; end of song?
94                                
95                                ; duration first
96    >20BC=>D803 >FF6A           movb    3, @snddur
98    >20C0                   $4:
99                                ; then a set of volumes or tones (noise must have a dummy $ff byte)
100   >20C0=>0692                 bl      *2
101   >20C2=>1309                 jeq     $2+         ; end of group?
102                                   
103   >20C4=>D803 >FFA0           movb    3, @SOUND
104   >20C8=>20E0 >1DB4           coc     #>1000, 3    ; volume?
105   >20CC=>13F9                 jeq     $4-         ; yup 
106                               
107   >20CE=>0692                 bl      *2          ; else it was the first byte of a two-byte tone; fetch next
108   >20D0=>D803 >FFA0           movb    3, @SOUND   
109   >20D4=>10F5                 jmp     $4-
110                               
111   >20D6                   $2:
112   >20D6=>C800 >FF68           mov     0, @sndlist
113   >20DA=>0380                 rtwp
114                               
115   >20DC                   $5:    
116   >20DC=>04E0 >FF68           clr     @sndlist
117   >20E0                   $3:
118   >20E0=>0380                 rtwp
125   >20E2                   snd_tracks_init
126                               PUSH    SP, 11
*** <expansion of push>
1     >20E2=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >20E4=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
128   >20E6=>0200 >1E00           li      r0, 30 * 256
129   >20EA=>06A0 >212E           bl      @snd_track_tempo_to_incr
130                               
131   >20EE=>0204 >FA00           li      r4, tracks
132   >20F2=>04C2                 clr     r2
133   >20F4                   $0:
134   >20F4=>06A0 >2102           bl      @snd_track_init
135   >20F8=>0284 >FA80           ci      r4, TRACKS_END
136   >20FC=>1AFB                 jl      $0
137                               
138                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >20FE=>C2FA                     mov *SP+,  11
*** sound.i
139   >2100=>045B                 rt
149   >2102                   snd_track_init
150   >2102=>CD02                 mov     r2, *r4+    ; lt_cmdptr
151   >2104=>04F4                 clr     *r4+        ; lt_clock
152   >2106=>0734                 seto    *r4+        ; lt_incr
153   >2108=>CD00                 mov     r0,*r4+     ; lt_tempoincr
154   >210A=>04F4                 clr     *r4+        ; lt_a_d, lt_s_r
155   >210C=>CD20 >047C           mov     #>0f00,*r4+     ; lt_volume, lt_sustain
156   >2110=>04F4                 clr     *r4+        ; lt_vibrato, lt_tremolo
157   >2112=>04F4                 clr     *r4+        ; lt_waveform, lt_balance
158   >2114=>045B                 rt
159                                   
164   >2116                   snd_track_reset
165   >2116=>04E4 >0008           clr     @lt_a_d(r4)  ; + s_r
166   >211A=>04C0                 clr     r0
167   >211C=>D900 >000B           movb    r0, @lt_sustain(r4)
168   >2120=>04E4 >000C           clr     @lt_vibrato(r4)  ; + lt_tremolo
169   >2124=>C900 >000E           mov     r0, @lt_waveform(r4) ; + lt_balance
170   >2128=>045B                 rt
179   >212A                   snd_track_isDone
180   >212A=>C014                 mov     @lt_cmdptr(r4), r0
181   >212C=>045B                 rt
193   >212E                   snd_track_tempo_to_incr
194   >212E=>0980                 srl     r0, 8
195   >2130=>0A20                 sla     r0, 2
196   >2132=>04C1                 clr     r1
197   >2134=>3C20 >29BA           div     #3600, r0
198   >2138=>1901                 jno     $0+
199   >213A=>0700                 seto    r0 
200   >213C                   $0:    
201   >213C=>045B                 rt    
202                               
213   >213E                   snd_track_length_to_incr
214   >213E=>C0A4 >0006           mov     @lt_tempoincr(r4), r2
215   >2142=>C042                 mov     r2, r1
216   >2144=>09C1                 srl     r1, 12
217   >2146=>0A42                 sla     r2, 4    
218   >2148=>0980                 srl     r0, 8
219   >214A=>3C40                 div     r0, r1
220   >214C=>045B                 rt
231   >214E                   snd_track_note_to_hertz_16
232   >214E=>D040                 movb    r0, r1
233   >2150=>0241 >0F00           andi    r1, >0f00
234   >2154=>0971                 srl     r1, 7           ; note offset
235   >2156=>C061 >2168           mov     @snd_scale_12_tone_octave_11(r1), r1
236                               
237   >215A=>09C0                 srl     r0, 12          ; octave
238   >215C=>0500                 neg     r0
239   >215E=>0220 >0007           ai      r0, 11 - 4      ; shift
240   >2162=>1301                 jeq     $0+
241   >2164=>0901                 srl     r1, r0    
242   >2166                   $0:    
243   >2166=>045B                 rt
244                               
248   >2168                   snd_scale_12_tone_octave_11:
249   >2168=>82D0 >8A97 >92D5     dw  33488, 35479, 37589, 39824
      >216E=>9B90             
250   >2170=>A4D0 >AE9D >B8FF     dw  42192, 44701, 47359, 50175 
      >2176=>C3FF             
251   >2178=>CFA7 >DC00 >E915     dw  53159, 56320, 59669, 63217 
      >217E=>F6F1             
252   >2180=>0000 >0000 >0000     dw  0, 0, 0, 0
      >2186=>0000             
258   >2188                   snd_tracks_tick
259                                  PUSH SP, 11
*** <expansion of push>
1     >2188=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >218A=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
260                                  
261   >218C=>0204 >FA00              li   r4, tracks
262   >2190                   $0:
263   >2190=>C014                    mov  @lt_cmdptr(r4), r0
264   >2192=>1302                    jeq  $1+
265                                  
266   >2194=>06A0 >21A6              bl   @snd_track_tick
267   >2198                   $1:
268   >2198=>0224 >0010              ai   r4, lt_size       
269   >219C=>0284 >FA80              ci   r4, TRACKS_END
270   >21A0=>1AF7                    jl   $0-
271                                  
272                                  POP  SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >21A2=>C2FA                     mov *SP+,  11
*** sound.i
273   >21A4=>045B                    rt
274                               
282   >21A6                   snd_track_tick
283   >21A6=>A924 >0004 >0002     a       @lt_incr(r4), @lt_clock(r4)
284   >21AC=>1801                 joc     $3+
285                               ;   not end of lump, continue
286   >21AE=>045B                 rt
287                                   
288   >21B0                   $3:
289                               PUSH    SP, 5, 11
*** <expansion of push>
1     >21B0=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >21B4=>CA85 >0002               mov  5 , @(2-0-1)*2(SP)
2     >21B8=>C68B                     mov  11, @(2-1-1)*2(SP)
*** sound.i
290   >21BA=>1004                 jmp     $1+
291                               
292   >21BC                   $2:
293                               ; end of track
294   >21BC=>04D4                 clr     @lt_cmdptr(r4)
295                               
296                               ; one last tick
297   >21BE=>06A0 >2428           bl      @snd_voices_tick
298   >21C2=>1014                 jmp     $0+
299                                   
300   >21C4                   $1:
301   >21C4=>C154                 mov     @lt_cmdptr(r4), r5
302   >21C6=>1312                 jeq     $0+
303                               
304   >21C8=>D035                 movb    *r5+, r0
305   >21CA=>1625                 jne     $9+            ; assertion error, should be at lump
306                               
307   >21CC=>D035                 movb    *r5+, r0        ; get lump length
308   >21CE=>13F6                 jeq     $2-             ; end of track?
309                               
310   >21D0=>06A0 >213E           bl      @snd_track_length_to_incr
311                               
312                               ; length includes this tick
313   >21D4=>C901 >0004           mov     r1, @lt_incr(r4)
314   >21D8=>C901 >0002           mov     r1, @lt_clock(r4)
315                               
316   >21DC                   $2:
317   >21DC=>D035                 movb    *r5+, r0        ; next command
318   >21DE=>D040                 movb    r0, r1          ; keep R0 in case low nybble is used
319   >21E0=>09B1                 srl     r1, 11          ; hi nybble -> word offset
320   >21E2=>C061 >21F2           mov     @snd_track_commands(r1), r1
321   >21E6=>13FA                 jeq     $2-
322   >21E8=>0691                 bl      *r1
323   >21EA=>10F8                 jmp     $2-
325   >21EC                   $0: 
326                               POP     SP, 5, 11   
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >21EC=>C2FA                     mov *SP+,  11
2     >21EE=>C17A                     mov *SP+,  5 
*** sound.i
327   >21F0=>045B                 rt
328                               
329   >21F2                   snd_track_commands
330   >21F2=>2214                 dw      snd_track_cmd_lump     ; 0
331   >21F4=>221A                 dw      snd_track_cmd_note     ; 1
332   >21F6=>2272                 dw      snd_track_cmd_volume   ; 2
333   >21F8=>2296                 dw      snd_track_cmd_adhsr    ; 3
334   >21FA=>2284                 dw      snd_track_cmd_tempo    ; 4
335   >21FC=>22AE                 dw      snd_track_cmd_vibrato  ; 5
336   >21FE=>22B4                 dw      snd_track_cmd_tremolo  ; 6
337   >2200=>22BA                 dw      snd_track_cmd_waveform  ; 7
338                               ;dw      snd_track_cmd_sweep     ; 8
339   >2202=>0000                 dw      0
340   >2204=>22C4                 dw      snd_track_cmd_balance   ; 9 
341   >2206=>0000 >0000 >0000     dw      0, 0, 0, 0, 0        ; A,B,C, D
      >220C=>0000 >0000       
342   >2210=>227C                 dw      snd_track_cmd_jump      ; E
343   >2212=>22CA                 dw      snd_track_cmd_stop      ; F
345   >2214                   snd_track_cmd_lump:
346                               ; done (reached the next lump)
347   >2214=>0605                 dec     r5
348   >2216                   $9:    
349   >2216=>C505                 mov     r5, @lt_cmdptr(r4)
350                               
351                               ;   update the voices for this tick
352                              ; bl      @snd_voices_tick
353   >2218=>10E9                 jmp     $0-
354                               
355   >221A                   snd_track_cmd_note:
356                               PUSH    SP, 11
*** <expansion of push>
1     >221A=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >221C=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
357                               
358   >221E=>0240 >0F00           andi    r0, >0F00
359   >2222=>D1C0                 movb    r0, r7              ; save flags
360                               
361   >2224=>D035                 movb    *r5+, r0
362                               
363   >2226=>06A0 >214E           bl      @snd_track_note_to_hertz_16
364   >222A=>C181                 mov     r1, r6              ; save hertz
365                               
366   >222C=>D035                 movb    *r5+, r0
367   >222E=>06A0 >213E           bl      @snd_track_length_to_incr
368   >2232=>C006                 mov     r6, r0
369                               
370                               PUSH    SP, 5
*** <expansion of push>
1     >2234=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >2236=>C685                     mov  5, @(1-0-1)*2(SP)
*** sound.i
371                                   
372   >2238=>D1C7                 movb    r7, r7
373   >223A=>1605                 jne     $3+                ; force noise? 
374                               
375   >223C=>0280 >0360           ci      r0, 54 * 16        ; too low?  (Note: enhanced chip!)
376   >2240=>1410                 jhe     $0+
378   >2242=>0207 >0400           li      r7, >0400           ; variable periodic noise (+1)
379   >2246                   $3:
380   >2246                   snd_track_note_noise:    
381   >2246=>0227 >FF00           ai      r7, ->0100
382                               
383   >224A=>21E0 >0018           coc     #>0300, r7
384   >224E=>1603                 jne     $1+
385                               
386                               ; variable pitch: need two voices
387   >2250=>06A0 >247C           bl      @snd_seq_alloc_noise_voices
388   >2254=>100B                 jmp     $2+
389                               
390   >2256                   $1:
391                               ; simple single noise channel    
392   >2256=>D007                 movb    r7, r0
393   >2258=>0202 >8888           li      r2, >8888          ; only a noise
394   >225C=>06A0 >2456           bl      @snd_seq_alloc_note  
396   >2260=>1005                 jmp     $2+
398   >2262                   $0:    
399   >2262=>0202 >7777           li      r2, >7777          ; any melodic voice  
400   >2266=>0940                 srl     r0, 4               ; scale to normal hertz
401   >2268=>06A0 >2456           bl      @snd_seq_alloc_note
403   >226C                   $2:    
404                               POP     SP, 5
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >226C=>C17A                     mov *SP+,  5
*** sound.i
405                               
406                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >226E=>C2FA                     mov *SP+,  11
*** sound.i
407   >2270=>045B                 rt
409   >2272                   snd_track_cmd_volume:
410   >2272=>0240 >0F00           andi    r0, >f00
411   >2276=>D900 >000A           movb    r0, @lt_volume(r4)
412   >227A=>045B                 rt
413                               
414   >227C                   snd_track_cmd_jump:
415   >227C=>D035                 movb    *r5+, r0
416   >227E=>0880                 sra     r0, 8
417   >2280=>A140                 a       r0, r5
418   >2282=>045B                 rt
419                               
420   >2284                   snd_track_cmd_tempo:
421                               PUSH    SP, 11
*** <expansion of push>
1     >2284=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >2286=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
422   >2288=>D035                 movb    *r5+, r0
423   >228A=>06A0 >212E           bl      @snd_track_tempo_to_incr
424   >228E=>C900 >0006           mov     r0, @lt_tempoincr(r4) 
425                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >2292=>C2FA                     mov *SP+,  11
*** sound.i
426   >2294=>045B                 rt
428   >2296                   snd_track_cmd_adhsr:
429                               PUSH    SP, 11
*** <expansion of push>
1     >2296=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >2298=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
430                               
431   >229A=>0240 >0F00           andi    r0, >F00
432   >229E=>D900 >000B           movb    r0, @lt_sustain(r4)
433                               
434   >22A2=>D935 >0008           movb    *r5+, @lt_a_d(r4)
435   >22A6=>D935 >0009           movb    *r5+, @lt_h_r(r4)
436                               
437                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >22AA=>C2FA                     mov *SP+,  11
*** sound.i
438   >22AC=>045B                 rt
439                               
440   >22AE                   snd_track_cmd_vibrato:
441   >22AE=>D935 >000C           movb    *r5+, @lt_vibrato(r4)
442   >22B2=>045B                 rt
443                                   
444   >22B4                   snd_track_cmd_tremolo:
445   >22B4=>D935 >000D           movb    *r5+, @lt_tremolo(r4)
446   >22B8=>045B                 rt
447                                   
448   >22BA                   snd_track_cmd_waveform:
449   >22BA=>0240 >0F00           andi    r0, >0f00
450   >22BE=>D900 >000E           movb    r0, @lt_waveform(r4)
451   >22C2=>045B                 rt
452                               
453   >22C4                   snd_track_cmd_balance:
454   >22C4=>D935 >000F           movb    *r5+,@lt_balance(r4)
455   >22C8=>045B                 rt    
456                               
457   >22CA                   snd_track_cmd_stop:
458   >22CA=>0460 >2116           b       @snd_track_reset
460   >22CE                   snd_voice_ports
461   >22CE=>FFA2 >FFA8 >FFAE     dw      SOUND+>2, SOUND+>8, SOUND+>E, SOUND+>14
      >22D4=>FFB4             
462                               
466   >22D6                   snd_voices_init
467   >22D6=>0201 >F940           li      r1, voices
468   >22DA=>0202 >22CE           li      r2, snd_voice_ports
469   >22DE                   $0:    
470   >22DE=>0203 >8090           li      r3, >8090
471   >22E2                   $1:
472   >22E2=>04F1                 clr     *r1+        ; pv_clock
473   >22E4=>04F1                 clr     *r1+        ; pv_incr
474   >22E6=>04F1                 clr     *r1+        ; pv_hertz
475   >22E8=>04F1                 clr     *r1+        ; pv_track
476   >22EA=>CC52                 mov     *r2, *r1+   ; pv_port
477   >22EC=>CC43                 mov     r3, *r1+    ; pv_freqmask, pv_volmask
478   >22EE=>0223 >2020           ai      r3, >2020   
479   >22F2=>17F7                 jnc     $1          ; >E0F0 -> 0110
480                               
481   >22F4=>05C2                 inct    r2          ; next port
482   >22F6=>0281 >FA00           ci      r1, VOICES_END
483   >22FA=>1AF1                 jl      $0
484                               
485   >22FC=>045B                 rt
486                               
498   >22FE                   snd_voice_alloc
499                               PUSH    SP, 11
*** <expansion of push>
1     >22FE=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >2300=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
500                               
501   >2302=>C944 >0006           mov     r4, @pv_track(r5)
502   >2306=>C940 >0004           mov     r0, @pv_hertz(r5)
503   >230A=>04D5                 clr     @pv_clock(r5)
504   >230C=>C941 >0002           mov     r1, @pv_incr(r5)
506                               ; set the effects
507   >2310=>C0E5 >0008           mov     @pv_port(r5), r3
508   >2314=>D0A5 >000B           movb    @pv_volmask(r5), r2
509                               
510   >2318=>05C3                 inct    r3                  ; point to command port
511                               
512   >231A=>D4C2                 movb    r2, *r3    ; reset
513                               
514   >231C=>D064 >000B           movb    @lt_sustain(r4), r1     ; envelope on?
515   >2320=>1314                 jeq     $0+
516                               
517   >2322=>D002                 movb    r2, r0
518   >2324=>0260 >0100           ori     r0, >0100           ; envelope/sustain command
519   >2328=>D4C0                 movb    r0, *r3
521   >232A=>D8C1 >0002           movb    r1, @2(r3)          ; sustain amount
522                                   
523   >232E=>D002                 movb    r2, r0
524   >2330=>0260 >0200           ori     r0, >0200           ; envelope attack/decay command
525   >2334=>D4C0                 movb    r0, *r3
527   >2336=>D8E4 >0008 >0002     movb    @lt_a_d(r4), @2(r3) ; values
529   >233C=>D002                 movb    r2, r0
530   >233E=>0260 >0300           ori     r0, >0300           ; envelope hold/release command
531   >2342=>D4C0                 movb    r0, *r3
533   >2344=>D8E4 >0009 >0002     movb    @lt_h_r(r4), @2(r3) ; values
535   >234A                   $0:    
536   >234A=>D024 >000C           movb    @lt_vibrato(r4), r0     ; vibrato on?
537   >234E=>1306                 jeq     $0+
538                              
539   >2350=>D042                 movb    r2, r1
540   >2352=>0261 >0400           ori     r1, >0400           ; vibrato command
541   >2356=>D4C1                 movb    r1, *r3
542                               
543   >2358=>D8C0 >0002           movb    r0, @2(r3) ; values
544                                
545   >235C                   $0:    
546   >235C=>D024 >000D           movb    @lt_tremolo(r4), r0     ; tremolo on?
547   >2360=>1306                 jeq     $0+
548                              
549   >2362=>D042                 movb    r2, r1
550   >2364=>0261 >0500           ori     r1, >0500           ; tremolo command
551   >2368=>D4C1                 movb    r1, *r3
552                               
553   >236A=>D8C0 >0002           movb    r0, @2(r3) ; values
554                                
555   >236E                   $0:    
556   >236E=>D024 >000E           movb    @lt_waveform(r4), r0     ; custom waveform
557   >2372=>1306                 jeq     $0+
558                              
559   >2374=>D042                 movb    r2, r1
560   >2376=>0261 >0600           ori     r1, >0600           ; waveform command
561   >237A=>D4C1                 movb    r1, *r3
562                               
563   >237C=>D8C0 >0002           movb    r0, @2(r3) ; values
565   >2380                   $0:    
566   >2380=>D024 >000F           movb    @lt_balance(r4), r0     ; balance
567                               
568   >2384=>D042                 movb    r2, r1
569   >2386=>0261 >0900           ori     r1, >0900
570   >238A=>D4C1                 movb    r1, *r3
571                               
572   >238C=>D8C0 >0002           movb    r0, @2(r3)  ; value
573                               
574   >2390=>06A0 >239C           bl      @snd_voice_apply2
575                               
576                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >2394=>C2FA                     mov *SP+,  11
*** sound.i
577   >2396=>045B                 rt
578                                
586   >2398                   snd_voice_apply
587   >2398=>C125 >0006           mov     @pv_track(r5), r4
588   >239C                   snd_voice_apply2
589   >239C=>D0A5 >000A           movb    @pv_freqmask(r5), r2
590   >23A0=>90A0 >0079           cb      #>E0, r2
591   >23A4=>1606                 jne     $0+
592                              
593                               ; noise
594   >23A6=>F0A5 >0004           socb    @pv_hertz(r5), r2
595   >23AA=>C065 >0008           mov     @pv_port(r5), r1
596   >23AE=>D442                 movb    r2, *r1
597   >23B0=>1010                 jmp     $1+
598                                 
599   >23B2                   $0:    
600   >23B2=>0200 >0001           li      r0, >1
601   >23B6=>0201 >B4F4           li      r1, >B4F4
602   >23BA=>3C25 >0004           div     @pv_hertz(r5), r0
603   >23BE=>C065 >0008           mov     @pv_port(r5), r1
604                               
605                               ; R0 is, say >3F9.  We write >89 >3F
606   >23C2=>C0C0                 mov     r0, r3
607   >23C4=>0A43                 sla     r3, 4       ; get lo byte
608   >23C6=>06C0                 swpb    r0
609   >23C8=>0240 >0F00           andi    r0, >0f00
610   >23CC=>F002                 socb    r2, r0
611   >23CE=>D440                 movb    r0, *r1
612   >23D0=>D443                 movb    r3, *r1
613   >23D2                   $1:    
614   >23D2=>D024 >000A           movb    @lt_volume(r4), r0
615                               
616   >23D6=>C0A5 >0002           mov     @pv_incr(r5), r2      ; tone voices for noise are silent
617   >23DA=>1609                 jne     $1+
618                               
619                               ; write pan for noise too
620   >23DC=>D024 >000F           movb    @lt_balance(r4), r0
621   >23E0=>D860 >29BC >0002     movb    #>f9, @2(r1)
622   >23E6=>D840 >0004           movb    r0, @4(r1)
623                               
624   >23EA=>0200 >0F00           li      r0, >F00
625                               
626   >23EE                   $1:  
627   >23EE=>F025 >000B           socb    @pv_volmask(r5), r0
628   >23F2=>D440                 movb    r0, *r1
629   >23F4=>045B                 rt
637   >23F6                   snd_voice_tick:
638   >23F6=>C0A5 >0002           mov     @pv_incr(r5), r2      ; do nothing if inactive (or claimed by noise)
639   >23FA=>1315                 jeq     $0+
640                               
641   >23FC=>A542                 a       r2, @pv_clock(r5)
642   >23FE=>1713                 jnc     $1+
643                               
644                               ; end of note
645                               ; write "volume off" or key release to command port
646   >2400=>0200 >0F00           li      r0, >0F00
647   >2404=>F025 >000B           socb    @pv_volmask(r5), r0
648   >2408=>C065 >0008           mov     @pv_port(r5), r1
649   >240C=>D0A4 >000B           movb    @lt_sustain(r4), r2
650   >2410=>1301                 jeq     $2+
651                               
652   >2412=>05C1                 inct    r1          ; send key off command rather than volume off
653                               
654   >2414                   $2: 
655   >2414=>D440                 movb    r0, *r1
657   >2416=>04E5 >0006           clr     @pv_track(r5)
658                               
659                               ; was it a noise?
660   >241A=>9960 >0079 >000A     cb      #>E0, @pv_freqmask(r5)
661   >2420=>1602                 jne     $0+
662                               
663                               ; if so, the previous was ours too
664   >2422=>04E5 >FFFA           clr     @pv_track - pv_size(r5)
666   >2426                   $0:
667   >2426                   $1:
668   >2426=>045B                 rt
674   >2428                   snd_voices_tick:
675                               PUSH    SP, 4, 5, 11
*** <expansion of push>
1     >2428=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >242C=>CA84 >0004               mov  4 , @(3-0-1)*2(SP)
2     >2430=>CA85 >0002               mov  5 , @(3-1-1)*2(SP)
3     >2434=>C68B                     mov  11, @(3-2-1)*2(SP)
*** sound.i
676   >2436=>0205 >F940           li      r5, voices
677   >243A                   $0:
678   >243A=>C125 >0006           mov     @pv_track(r5), r4
679   >243E=>1302                 jeq     $1+
680   >2440=>06A0 >23F6           bl      @snd_voice_tick
681   >2444                   $1:    
682   >2444=>0225 >000C           ai      r5, pv_size
683   >2448=>0285 >FA00           ci      r5, VOICES_END
684   >244C=>1AF6                 jl      $0
685                               POP     SP, 4, 5, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >244E=>C2FA                     mov *SP+,  11
2     >2450=>C17A                     mov *SP+,  5 
3     >2452=>C13A                     mov *SP+,  4 
*** sound.i
686   >2454=>045B                 rt
700   >2456                   snd_seq_alloc_note
701                               PUSH    SP, 11
*** <expansion of push>
1     >2456=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >2458=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
702   >245A=>0205 >F940           li      r5, voices
703   >245E                   $0:
704   >245E=>0912                 srl     r2, 1           ; allowed voice?
705   >2460=>1706                 jnc     $2+
706                               
707   >2462=>C2E5 >0006           mov     @pv_track(r5), r11   ; already in use?
708   >2466=>1603                 jne     $2+
710   >2468=>06A0 >22FE           bl      @snd_voice_alloc
711   >246C=>1005                 jmp     $1+
712                               
713   >246E                   $2:
714   >246E=>0225 >000C           ai      r5, pv_size
715   >2472=>0285 >FA00           ci      r5, VOICES_END
716   >2476=>1AF3                 jl      $0-
717                               
718                               ; no voice allocated
719                               
720   >2478                   $1:
721                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >2478=>C2FA                     mov *SP+,  11
*** sound.i
722   >247A=>045B                 rt
735   >247C                   snd_seq_alloc_noise_voices
736                               PUSH    SP, 11
*** <expansion of push>
1     >247C=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >247E=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
737                               
738   >2480=>C080                 mov     r0, r2
739   >2482=>0942                 srl     r2, 4              ; get pitch*15/16
740   >2484=>6002                 s       r2, r0
741   >2486=>0202 >4444           li      r2, >4444          ; only a voice 2
742   >248A=>C181                 mov     r1, r6             ; save length
743   >248C=>04C1                 clr     r1                 ; not a real note
744   >248E=>06A0 >2456           bl      @snd_seq_alloc_note  
746                               ; take the next voice for noise
747   >2492=>0225 >000C           ai      r5, pv_size
748                               
749   >2496=>D007                 movb    r7, r0
750   >2498=>C046                 mov     r6, r1             ; restore length
751   >249A=>0202 >8888           li      r2, >8888          ; only a noise 
752                               
753   >249E=>06A0 >22FE           bl      @snd_voice_alloc
754                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >24A2=>C2FA                     mov *SP+,  11
*** sound.i
755   >24A4=>045B                 rt
756                               
763   >24A6                   snd_song_tick:
764   >24A6=>C156                 mov     @ls_phrase(6), 5
765   >24A8=>1606                 jne     $0+
766                               
767                               ; moving to next phrase
768   >24AA=>C1E6 >0002           mov     @ls_phrases(6), 7
769   >24AE=>C177                 mov     *7+, 5
770   >24B0=>C585                 mov     5, @ls_phrase(6)
771   >24B2=>C987 >0002           mov     7, @ls_phrases(6)
773                               ;...
775   >24B6                   $0:
776   >24B6=>045B                  rt   
777                               
781   >24B8                   snd_seq_tick    
782                               ;dbg
783                               PUSH    SP, 11
*** <expansion of push>
1     >24B8=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >24BA=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
784                               
785   >24BC=>06A0 >2428           bl      @snd_voices_tick
786                               
787                               ; for now
788   >24C0=>06A0 >2188           bl      @snd_tracks_tick
790                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >24C4=>C2FA                     mov *SP+,  11
*** sound.i
791                               ;dbgf     
792                               
793   >24C6=>045B                 rt
796                               ; step through songs and tick them
797   >24C8=>0206 >FA80           li      6, songs
798   >24CC                   $0:
799   >24CC=>C056                 mov     *6, 1
800   >24CE=>1302                 jeq     $1+
801                               
802   >24D0=>06A0 >24A6           bl      @snd_song_tick
803   >24D4                   $1:  
804   >24D4=>05C6                 inct    6
805   >24D6=>0286 >FAA0           ci      6, SONGS_END
806   >24DA=>16F8                 jne     $0-
807                               
808                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >24DC=>C2FA                     mov *SP+,  11
*** sound.i
809                               ;dbgf     
810                               
811   >24DE=>045B                 rt
813   >24E0                   snd_seq_init
814                               ;dbg
815                               PUSH    SP, 11
*** <expansion of push>
1     >24E0=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >24E2=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
816   >24E4=>06A0 >20E2           bl      @snd_tracks_init
817   >24E8=>06A0 >22D6           bl      @snd_voices_init
818                                   
819   >24EC=>0200 >2640           li      r0, test_track
820                               ;mov     r0, @tracks + lt_cmdptr         ;;; auto start
821                               
822                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >24F0=>C2FA                     mov *SP+,  11
*** sound.i
823                               ;dbgf
824   >24F2=>045B                 rt
826                            Vector sound_sequencer, vidws
*** <expansion of vector>
1     >24F4                   sound_sequencer  data vidws, sound_sequencer_entry
      >24F4=>FC60 >24F8       
2     >24F8                   sound_sequencer_entry:    
*** sound.i
827   >24F8=>020A >F740           li      SP, vstack + vstacksize
828   >24FC=>06A0 >24B8           bl      @snd_seq_tick
829   >2500=>0380                 rtwp    
835   >2502                   xsnd_queue_track:
836                               PUSH    SP, 4, 11
*** <expansion of push>
1     >2502=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >2506=>CA84 >0002               mov  4 , @(2-0-1)*2(SP)
2     >250A=>C68B                     mov  11, @(2-1-1)*2(SP)
*** sound.i
837   >250C=>0204 >FA00           li      4, tracks
838   >2510                   $0:
839   >2510=>C514                 mov     @lt_cmdptr(4), @lt_cmdptr(4)
840   >2512=>1308                 jeq     $1+
842   >2514=>0224 >0010           ai      4, lt_size
843   >2518=>0284 >FA80           ci      4, TRACKS_END
844   >251C=>1AF9                 jl      $0
845   >251E                   $2:
846                               POP     SP, 4, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >251E=>C2FA                     mov *SP+,  11
2     >2520=>C13A                     mov *SP+,  4 
*** sound.i
847   >2522=>045B                 rt
848   >2524                   $1:
849                               ; assign
850   >2524=>0200 >1E00           li      r0, 30 * 256
851   >2528=>06A0 >212E           bl      @snd_track_tempo_to_incr
852                               
853   >252C=>06A0 >2102           bl      @snd_track_init    
854   >2530=>10F6                 jmp     $2-
855                              
856                               
857   >2532                   test_track0:
858   >2532=>0010 >28           db      >00, 16,  >28
859   >2535=  >00 >1010 >400A     db      >00, 16,  >10, >40, 10
860   >253A=>0010 >1044 >0A     db      >00, 16,  >10, >44, 10
861   >253F=  >00 >1010 >470A     db      >00, 16,  >10, >47, 10
862   >2544=>0040 >1040 >3C10     db      >00, 64,  >10, >40, 60,  >10, >44, 60,  >10, >47, 60,  >10, >50, 60
      >254A=>443C >1047 >3C10 
      >2550=>503C             
863   >2552=>0010                 db      >00, 16
864   >2554=>0001 >4028           db      >00, 1,   >40, 40
865   >2558=>000F >1000 >0F10     db      >00, 15,  >10, >00, 15,     >10, >10, 15
      >255E=>100F             
866   >2560=>000F >1003 >0F10     db      >00, 15,  >10, >03, 15,     >10, >13, 15
      >2566=>130F             
867   >2568=>000F >1005 >0F10     db      >00, 15,  >10, >05, 15,     >10, >15, 15
      >256E=>150F             
868   >2570=>000F >1007 >0F10     db      >00, 15,  >10, >07, 15,     >10, >17, 15
      >2576=>170F             
869   >2578=>000F >1009 >0F10     db      >00, 15,  >10, >09, 15,     >10, >19, 15
      >257E=>190F             
870   >2580=>000F >100B >0F10     db      >00, 15,  >10, >0B, 15,     >10, >1B, 15
      >2586=>1B0F             
871   >2588=>000F >1011 >0F10     db      >00, 15,  >10, >11, 15,     >10, >21, 15
      >258E=>210F             
872   >2590=>000F >1014 >0F10     db      >00, 15,  >10, >14, 15,     >10, >24, 15
      >2596=>240F             
873   >2598=>000F >1017 >0F10     db      >00, 15,  >10, >17, 15,     >10, >27, 15
      >259E=>270F             
874   >25A0=>000F >101A >0F10     db      >00, 15,  >10, >1A, 15,     >10, >2A, 15
      >25A6=>2A0F             
875   >25A8=>000F >1022 >0F10     db      >00, 15,  >10, >22, 15,     >10, >32, 15
      >25AE=>320F             
876   >25B0=>000F >1025 >0F10     db      >00, 15,  >10, >25, 15,     >10, >35, 15
      >25B6=>350F             
877   >25B8=>000F >1028 >0F10     db      >00, 15,  >10, >28, 15,     >10, >38, 15
      >25BE=>380F             
878   >25C0=>000F >1030 >0F10     db      >00, 15,  >10, >30, 15,     >10, >40, 15
      >25C6=>400F             
879   >25C8=>000F >1033 >0F10     db      >00, 15,  >10, >33, 15,     >10, >43, 15
      >25CE=>430F             
880   >25D0=>0000                 db      >00, 0
882   >25D2                   test_track1:
883   >25D2=>0010 >2F40 >FF     db      >00, 16, >2F, >40, 255
884   >25D7                   tt0:    
885   >25D7=  >00 >0110 >4020     db      >00, 1, >10, >40, 32,  >10, >50, 32,  >10, >60, 32 
      >25DC=>1050 >2010 >6020 
886   >25E2=>0001 >2E           db      >00, 1, >2E
887   >25E5=  >00 >012D           db      >00, 1, >2D
888   >25E8=>0001 >2C           db      >00, 1, >2C
889   >25EB=  >00 >012B           db      >00, 1, >2B
890   >25EE=>0001 >2A           db      >00, 1, >2A
891   >25F1=  >00 >0129           db      >00, 1, >29
892   >25F4=>0001 >28           db      >00, 1, >28
893   >25F7=  >00 >0127           db      >00, 1, >27
894   >25FA=>0001 >26           db      >00, 1, >26
895   >25FD=  >00 >0125           db      >00, 1, >25
896   >2600=>0001 >24           db      >00, 1, >24
897   >2603=  >00 >0123           db      >00, 1, >23
898   >2606=>0001 >22           db      >00, 1, >22
899   >2609=  >00 >0121           db      >00, 1, >21
900   >260C=>0001 >20           db      >00, 1, >20
901   >260F=  >00 >0121           db      >00, 1, >21
902   >2612=>0001 >22           db      >00, 1, >22
903   >2615=  >00 >0123           db      >00, 1, >23
904   >2618=>0001 >24           db      >00, 1, >24
905   >261B=  >00 >0125           db      >00, 1, >25
906   >261E=>0001 >26           db      >00, 1, >26
907   >2621=  >00 >0127           db      >00, 1, >27
908   >2624=>0001 >28           db      >00, 1, >28
909   >2627=  >00 >0129           db      >00, 1, >29
910   >262A=>0001 >2A           db      >00, 1, >2A
911   >262D=  >00 >012B           db      >00, 1, >2B
912   >2630=>0001 >2C           db      >00, 1, >2C
913   >2633=  >00 >012D           db      >00, 1, >2D
914   >2636=>0001 >2E           db      >00, 1, >2E
915   >2639=  >00 >012F           db      >00, 1, >2F
916   >263C=>0001 >E0           db      >00, 1, >E0
917   >263F=>99                 db      tt0 - $ + 1
918                               
919   >2640                   test_track:
920                               ; track volume = 8, ADSR = ...
921   >2640=>0010 >2840 >20     db      >00, 16 ,  >28 ,  >40, 32
922   >2645=  >38 >332D >5044     db		  	>38,  >33, >2D ,  >50, >44 , >60, >44 ;
      >264A=>6044             
923   >264C=>7110 >2004           db			>71, >10, >20, 4
924   >2650=>0010                 db      >00, 16 
925   >2652=>0010 >1030 >08     db      >00, 16, >10, >30, 8
926   >2657=  >00 >10           db      >00, 16 
927   >2659=  >00 >1010 >4010     db      >00, 16, >10, >40, 16
928   >265E=>0010                 db      >00, 16 
929   >2660=>0020 >1051 >20     db      >00, 32, >10, >51, 32
930   >2665=  >00 >10           db      >00, 16
931   >2667=  >00 >4010 >6240     db      >00, 64, >10, >62, 64
932   >266C=>0010 >9080           db      >00, 16,   >90, >80
933   >2670=>0019 >1000 >0F10     db      >00, 25,  >10, >00, 15,     >10, >10, 15,   >90, >98
      >2676=>100F >9098       
934   >267A=>0019 >1003 >0F10     db      >00, 25,  >10, >03, 15,     >10, >13, 15
      >2680=>130F             
935   >2682=>0019 >1005 >0F10     db      >00, 25,  >10, >05, 15,     >10, >15, 15,   >90, >b0
      >2688=>150F >90B0       
936   >268C=>0019 >1007 >0F10     db      >00, 25,  >10, >07, 15,     >10, >17, 15,    >40, 40
      >2692=>170F >4028       
937   >2696=>0019 >1009 >0F10     db      >00, 25,  >10, >09, 15,     >10, >19, 15,   >90, >c0
      >269C=>190F >90C0       
938   >26A0=>0019 >100B >0F10     db      >00, 25,  >10, >0B, 15,     >10, >1B, 15
      >26A6=>1B0F             
939   >26A8=>0019 >1011 >0F10     db      >00, 25,  >10, >11, 15,     >10, >21, 15,     >40, 48,   >90, >f0
      >26AE=>210F >4030 >90F0 
940   >26B4=>0019 >1014 >0F10     db      >00, 25,  >10, >14, 15,     >10, >24, 15
      >26BA=>240F             
941   >26BC=>0019 >1017 >0F10     db      >00, 25,  >10, >17, 15,     >10, >27, 15,   >90, >00
      >26C2=>270F >9000       
942   >26C6=>0019 >101A >0F10     db      >00, 25,  >10, >1A, 15,     >10, >2A, 15,    >40, 52    
      >26CC=>2A0F >4034       
943   >26D0=>0019 >1022 >0F10     db      >00, 25,  >10, >22, 15,     >10, >32, 15,   >90, >20
      >26D6=>320F >9020       
944   >26DA=>0019 >1025 >0F10     db      >00, 25,  >10, >25, 15,     >10, >35, 15
      >26E0=>350F             
945   >26E2=>0019 >1028 >0F10     db      >00, 25,  >10, >28, 15,     >10, >38, 15,    >40, 60,   >90, >30
      >26E8=>380F >403C >9030 
946   >26EE=>0019 >1030 >0F10     db      >00, 25,  >10, >30, 15,     >10, >40, 15,   >90, >40
      >26F4=>400F >9040       
947   >26F8=>0019 >1033 >0F10     db      >00, 25,  >10, >33, 15,     >10, >43, 15
      >26FE=>430F             
948   >2700=>0019 >1036 >0F10     db      >00, 25,  >10, >36, 15,     >10, >46, 15,    >40, 64,   >90, >50
      >2706=>460F >4040 >9050 
949   >270C=>0019 >1039 >0F10     db      >00, 25,  >10, >39, 15,     >10, >49, 15
      >2712=>490F             
950   >2714=>0019 >103B >0F10     db      >00, 25,  >10, >3B, 15,     >10, >4B, 15,   >90, >60
      >271A=>4B0F >9060       
951   >271E=>0019 >1042 >0F10     db      >00, 25,  >10, >42, 15,     >10, >52, 15,    >40, 68,   >90, >70
      >2724=>520F >4044 >9070 
952   >272A=>0019 >1045 >0F10     db      >00, 25,  >10, >45, 15,     >10, >55, 15,   >90, >7f
      >2730=>550F >907F       
953   >2734=>0019 >1048 >0F10     db      >00, 25,  >10, >48, 15,     >10, >58, 15
      >273A=>580F             
954   >273C=>0000                 db      >00, >00
955                               
956   >273E                   test_track4:
957                               ; track volume = 8, ADSR = ...
958   >273E=>0010 >2040 >20     db      >00, 16,  >20,  >40, 32  
959   >2743=  >38 >D42C           db       >38, >D4, >2C  
960   >2746=>5044 >6044           db       >50, >44 , >60, >44 ;
961   >274A                   tt1:    
962                              
963   >274A=>000A >7010 >350F     db      >00, 10,  >70,  >10, >35, 15  ;,     >10, >45, 15
964   >2750=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >33, 15
      >2756=>330F             
965   >2758=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
966   >275D=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
967   >2762=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
968   >2767=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
969   >276C=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
970   >2771=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
971   >2776=>0014                 db      >00, 20
973   >2778=>000A >7410 >350F      db      >00, 10,  >74,  >10, >35, 15  ;,     >10, >45, 15
974   >277E=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >53, 15
      >2784=>530F             
975   >2786=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
976   >278B=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
977   >2790=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
978   >2795=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
979   >279A=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
980   >279F=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
981   >27A4=>0014                 db      >00, 20
982                               
983                               
984                            
985   >27A6=>000A >7110 >350F       db      >00, 10,  >71,  >10, >35, 15  ;,     >10, >45, 15
986   >27AC=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >53, 15
      >27B2=>530F             
987   >27B4=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
988   >27B9=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
989   >27BE=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
990   >27C3=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
991   >27C8=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
992   >27CD=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
993   >27D2=>0014                 db      >00, 20
994                               
995                               
996                            
997   >27D4=>000A >7610 >350F    db      >00, 10,  >76,  >10, >35, 15  ;,     >10, >45, 15
998   >27DA=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >33, 15
      >27E0=>330F             
999   >27E2=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
1000  >27E7=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
1001  >27EC=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
1002  >27F1=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
1003  >27F6=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
1004  >27FB=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
1005  >2800=>0014                 db      >00, 20
1006                              
1007  >2802=>000A >7210 >350F   db      >00, 10,  >72,  >10, >35, 15  ;,     >10, >45, 15
1008  >2808=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >33, 15
      >280E=>330F             
1009  >2810=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
1010  >2815=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
1011  >281A=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
1012  >281F=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
1013  >2824=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
1014  >2829=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
1015  >282E=>0014                 db      >00, 20    
1017                           
1018                              
1019  >2830=>000A >7310 >350F     db      >00, 10,  >73,  >10, >35, 15  ;,     >10, >45, 15
1020  >2836=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >53, 15
      >283C=>530F             
1021  >283E=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
1022  >2843=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
1023  >2848=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
1024  >284D=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
1025  >2852=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
1026  >2857=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
1027  >285C=>0014                 db      >00, 20    
1028                            
1029  >285E=>000A >7510 >350F     db      >00, 10,  >75,  >10, >35, 15  ;,     >10, >45, 15
1030  >2864=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >53, 15
      >286A=>530F             
1031  >286C=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
1032  >2871=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
1033  >2876=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
1034  >287B=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
1035  >2880=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
1036  >2885=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
1037  >288A=>0014                 db      >00, 20
1038                              
1039  >288C=>000A >7710 >350F     db      >00, 10,  >77,  >10, >35, 15  ;,     >10, >45, 15
1040  >2892=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >33, 15
      >2898=>330F             
1041  >289A=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
1042  >289F=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
1043  >28A4=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
1044  >28A9=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
1045  >28AE=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
1046  >28B3=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
1047  >28B8=>0014                 db      >00, 20
1048                              
1049  >28BA=>0001 >E0           db      >00, 01, >E0
1050  >28BD=>8C                 db      tt1 - $ - 1
1051  >28BE=>0000                 db      >00, >00
1052  >28C0                       even
1053                                  
1054  >28C0                   test_track5:
1055  >28C0=>0010 >2840 >20     db      >00, 16,  >28,  >40, 32
1056                              ;db      >00, 25,  >10, >00, 15
1057                              ;db      >00, 25,  >10, >04, 15
1058                              ;db      >00, 25,  >10, >08, 15
1059                              
1060                              ;db       >60, >44
1061  >28C5=  >38 >233A           db       >38, >23, >3A
1062                              
1063  >28C8=>0008 >1413 >01     db      >00, 8,  >14, >13, 1
1064                              ;db      >00, 8,  >14, >13, 1
1065                              ;db      >00, 8,  >14, >13, 1
1066                              ;db      >00, 8,  >14, >13, 1
1067  >28CD=  >00 >0814 >2501     db      >00, 8,  >14, >25, 1
1068                              ;db      >00, 8,  >14, >25, 1
1069                              ;db      >00, 8,  >14, >25, 1
1070                              ;db      >00, 8,  >14, >25, 1
1071  >28D2=>0008 >1435 >01     db      >00, 8,  >14, >35, 1
1072                              ;db      >00, 8,  >14, >35, 1
1073                              ;db      >00, 8,  >14, >35, 1
1074                              ;db      >00, 8,  >14, >35, 1
1075  >28D7=  >00 >19           db      >00, 25
1076  >28D9=  >00 >0815 >5305     db      >00, 8,  >15, >53, 5
1077  >28DE=>0008 >1643 >05     db      >00, 8,  >16, >43, 5
1078  >28E3=  >00 >0817 >3305     db      >00, 8,  >17, >33, 5
1079                              
1080  >28E8=>0008 >1853 >01     db      >00, 8,  >18, >53, 1
1081  >28ED=  >00 >0818 >5302     db      >00, 8,  >18, >53, 2
1082  >28F2=>0008 >1853 >03     db      >00, 8,  >18, >53, 3
1083  >28F7=  >00 >0818 >5304     db      >00, 8,  >18, >53, 4
1084  >28FC=>0008 >1863 >01     db      >00, 8,  >18, >63, 1
1085  >2901=  >00 >0818 >6302     db      >00, 8,  >18, >63, 2
1086  >2906=>0008 >1863 >03     db      >00, 8,  >18, >63, 3
1087  >290B=  >00 >0818 >6304     db      >00, 8,  >18, >63, 4
1088  >2910=>0008 >1873 >01     db      >00, 8,  >18, >73, 1
1089  >2915=  >00 >0818 >7302     db      >00, 8,  >18, >73, 2
1090  >291A=>0008 >1873 >03     db      >00, 8,  >18, >73, 3
1091  >291F=  >00 >0818 >7304     db      >00, 8,  >18, >73, 4
1092  >2924=>0019                 db      >00, 25
1093  >2926=>0000                 db      >00, >00
1094  >2928                              even
1095                               
1096                               ; good snareish      
1097                              ;db       >34, >14, >88
1098                              ; db      >00, 8,  >18, >83, 2
1101                                  
*** nforth.tsm
520   >2928                   reset:   limi	0
      >2928=>0300 >0000       
521                               ;   clear memory
522   >292C=>06A0 >0250           bl      @clr
523   >2930=>F780 >0320           data    _RAMSTART, _RAMEND - _RAMSTART
524                            #if ENHANCED_MEMORY
525                            #else    
530   >2934=>06A0 >025C       	bl	@sinit			; system init
531   >2938=>06A0 >2038           bl  @sndinit        ; sound init
532   >293C=>06A0 >0328       	bl	@vinit			; video init
533   >2940=>06A0 >18AE       	bl	@kinit			; keyboard init
534   >2944=>06A0 >1CA0       	bl	@dinit			; device init
536   >2948=>06A0 >1DAA       	bl	@diskinit		; disk init
538   >294C                   boot:	clr	12
      >294C=>04CC             
539   >294E=>1E00             	sbz	0			; Interrupt mode
540   >2950=>1D01             	sbo	1			; Enable external interrupts
541   >2952=>1D02             	sbo	2			; Enable VDP interrupts
542   >2954=>1E03             	sbz	3			; Disable clock interrupts
544                            #if ENHANCED_MEMORY
545                            
546                            #else
561   >2956                   boot0:
562                           	; see if we have GROM extension
563   >2956=>0200 >6000       	li 0, >6000
564   >295A=>06A0 >0446       	bl @gwaddr
566   >295E=>06A0 >2966       	bl @copyram
568   >2962                   boot1:
569   >2962=>0460 >0060       	b	@FORTH_COLD
578   >2966                   copyram 
579   >2966=>0300 >0000           limi 0
580   >296A=>0203 >FF90           li  3, GPLRD
581   >296E                   cr0:    
582   >296E=>D013             	movb *3, 0
583   >2970=>06C0             	swpb 0
584   >2972=>D013             	movb *3, 0
585   >2974=>06C0             	swpb 0			; R1 = start addr in RAM
586   >2976=>0280 >AA55       	ci 0, >aa55
587   >297A=>1610             	jne cr1			; no GROM block
589   >297C=>D053             	movb *3, 1
590   >297E=>06C1             	swpb 1
591   >2980=>D053             	movb *3, 1
592   >2982=>06C1             	swpb 1			; R1 = start addr in RAM
594   >2984=>D093             	movb *3, 2
595   >2986=>06C2             	swpb 2
596   >2988=>D093             	movb *3, 2
597   >298A=>06C2             	swpb 2			; R2 = end addr in RAM
599   >298C=>0221 >0006       	ai 1, 6
600   >2990=>1002             	jmp cr3
602                           	;	copy data into RAM
603   >2992                   cr2:
604   >2992=>DC53             	movb *3, *1+
605   >2994=>DC53             	movb *3, *1+
606   >2996                   cr3:
607   >2996=>8081             	c 1, 2
608   >2998=>1AFC             	jl cr2
610   >299A=>10E9             	jmp cr0
612   >299C                   cr1:
613   >299C=>0300 >0001           limi 1
614   >29A0=>045B             	rt
621   >29A2                   dieerr:	bl	@type
      >29A2=>06A0 >1C74       
622   >29A6=>10FF             	jmp	$
624   >29A8=>FC40 >0070 >F786 	consttable
      >29AE=>0060 >0808 >1F00 
      >29B4=>00C0 >1E03 >0168 
      >29BA=>0E10 >F900       
626   >29BE                   the_end equ $
