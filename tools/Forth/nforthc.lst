*** nforth.tsm
90                            	incl	general.i
*** general.i
25                                #if ENHANCED_MEMORY
26    >FF80                   VDPRD   equ >FF80
27    >FF82                   VDPST   equ >FF82
28    >FF88                   VDPWD   equ >FF88
29    >FF8A                   VDPWA   equ >FF8A
30    >FF8C                   VDPCL   equ >FF8C
31    >FF8E                   VDPWI   equ >FF8E
32    >FF90                   GPLRD   equ >FF90
33    >FF92                   GPLRA   equ >FF92
34    >FF94                   GPLWD   equ >FF94
35    >FF96                   GPLWA   equ >FF96
36    >FF98                   SPCHRD  equ >FF98
37    >FF9A                   SPCHWT  equ >FF9A
38    >FFA0                   SOUND   equ >FFA0   ; 0x20!
39    >FFC0                   ROMBANK equ >FFC0
40    >FFC2                   FTHBANK equ >FFC2
41                                #else
61    >0001                   SR0	equ	1
62    >0002                   SR1	equ	2
63    >0004                   SR2	equ	4
64    >0008                   SR3	equ	8
65    >0010                   SR4	equ	16
66    >0020                   SR5	equ	32
67    >0040                   SR6	equ	64
68    >0080                   SR7	equ	128
69    >0100                   SR8	equ	256
70    >0200                   SR9	equ	512
71    >0400                   SR10	equ	1024
72    >0800                   SR11	equ	2048
73    >1000                   SR12	equ	4096
74    >2000                   SR13	equ	8192
75    >4000                   SR14	equ	16384
76    >8000                   SR15	equ	32768
82    >0001                   ST_L	equ	1
83    >0002                   ST_A	equ	2
84    >0004                   ST_E	equ	4
85    >0008                   ST_C	equ	8
86    >0010                   ST_OV	equ	16
87    >0020                   ST_OP	equ	32
88    >0040                   ST_X	equ	64
95    >0000                   grom_kbdlist		equ	>0000
96    >0130                   grom_font8x8		equ	>0130
97    >0930                   grom_font5x6		equ >0930
100   >000A                   SP	equ		10
102                            define Push SP, ... [
108                            define Pop SP, ... [
114                            define Vector label, ws [
*** nforth.tsm
91                            	incl	ram.i
*** ram.i
25                            	incl	cpuram.i
*** cpuram.i
28                             #if ENHANCED_MEMORY
30    >FC00                   mainws  equ >FC00       ; main FORTH/system workspace
31    >FC20                   dskws   equ >FC20       ; disk workspace
32    >FC40                   intws   equ >FC40       ; interrupt workspace
33    >FC40                   xopws   equ >FC40       ; XOP workspace (shared, ints off)
34    >FC60                   vidws   equ >FC60       ; video & term workspace   ; shared by interrupts!
36    >FB00                   cpurambase equ >FB00    ; CPU RAM base for DSRs
37    >FF60                   sharedvarbase equ >FF60 ; where vars shared with FORTH are seen
38    >F700                   privvarbase equ >F700   ; where ROM private vars are stored
40                             #else
60    >FB70                       aorg    cpurambase + >70
61    >FB70                   vdplimit    bss 2       ; VDP memory size (this points to a location offset from V9938 bank 3 (>C000))
66    >FB40                       aorg    cpurambase + >40
68    >0001                   int1flag    equ >1
69    >0002                   int2flag    equ >2
70    >0004                   xop1flag    equ >4
72    >FB40                   intsfromA   bss 2
77    >FF60                       aorg    sharedvarbase
78                             
81    >FF60                   vintflags   bss 1       ; VDP interrupt flags
82    >0080                   nvblnk      equ >80     ;       1: suppress blink cursor and blank screen
83    >0040                   nvkeyscan   equ >40     ;       1: suppress scan keyboard
84    >0020                   nvsprmot    equ >20     ;       1: suppress sprite motion
85    >0010                   nsoundlist  equ >10     ;       1: suppress sound list
87    >FF61                   vstatus     bss 1       ; VDP status last read during interrupt
89    >FF62                   userint     bss 2       ; user VDP interrupt handler (called when VDP interrupts)
90    >FF64                   timerisr    bss 2       ; user timer handler (called when clock ticks)
92    >FF66                   nsprmot     bss 1       ; number of sprites in motion (00 = none)
94    >FF67                   sndflags    bss 1       ; sound list flags
95                                                    ;       $00: CPU RAM, $80: VDP 
96                                                    ;       $0f: tempo adjust (signed: -4 to 3) 
97    >FF68                   sndlist     bss 2       ; address of classic sound list (0 = none), incremented on tick
98    >FF6A                   snddur      bss 1       ; duration of current group
100   >FF6C                           even
101                                   
103   >FF6C                   _CPURAMSTART equ $
105   >FF6C                   vpob        bss 1       ; VDP "page offset" bank (added to V9938 bank to select the page outside 64k)
106   >FF6D                   vblinkflag  bss 1       ; flag to set blink bit in text2 
107   >FF6E                   vpgrow      bss 2       ; VDP "page row offset" (added to V9938 commands to select the page)
108   >FF70                   vtextpage   bss 2       ; VDP text-ish page offset (screen, patterns, colors) (in addition to vpob)
110   >FF72                   vidvarstart bss 2       ; start addr of important video variables
111   >FF74                   vidvarsize  bss 2       ; size of important video variables
113   >000A                   _CPURAMSIZE  equ $ - _CPURAMSTART
*** ram.i
30                             #if ENHANCED_MEMORY
31    >F700                       aorg    privvarbase      
32                             #else
35                                 
36    >0040                   vstacksize equ  >40
37    >F700                   vstack  bss vstacksize      ; video stack is stored here for speed in slow-mode
39                             #if ENHANCED_MEMORY
40                                ; keep going
41                             #else
44                             
45    >F740                   sysstack bss    >40         ; system stack
46    >0040                   sysstacksize equ $ - sysstack
48    >F780                   _RAMSTART equ $ 
50    >F780                   uptime	bss	4			; time in 1/60 seconds
51    >F784                   timeout	bss	2			; timeout counter
53    >F786                   _VIDVARSTART equ $
55    >F786                   vscreen	bss	2			; VDP addr of screen
56    >F788                   vscreensz	bss	2			; VDP size of screen table
57    >F78A                   vpatts	bss	2			; VDP addr of patterns
58    >F78C                   vpattsz	bss	2			; VDP size of pattern table
59    >F78E                   vcolors bss	2			; VDP addr of colors
60    >F790                   vcolorsz bss	2			; VDP size of color table
61    >F792                   vsprites bss	2			; VDP addr of sprites
62    >F794                   vsprcol bss 2           ; VDP addr of sprite color table (0 if not sprite 2 mode)
63    >F796                   vsprpat bss	2			; VDP addr of sprite patterns
64    >F798                   vsprmot	bss	2			; VDP addr of sprite motion
65    >F79A                   vfree	bss	2			; usable space
67    >F79C                   vdrawchar bss	2			; draw char in window (BLWP @)
68    >F79E                   vscroll	bss	2			; scroll window up a line (BLWP @)
69    >F7A0                   vclearline	bss	2			; clear line (BL @)  [R0=window coord, R2=length; preserve 0, 3]
71    >F7A2                   vbsize	bss	2			; bitmapped font size (x/y)
73    >F7A4                   vcoordaddr bss	2			; get SIT addr of R0 coord   [R0=window coord => R0=addr, R1=shift; 
74                                                        ;                               preserve R2]
76    >F7A6                   vcrstimer bss	1			; timer for blink
77    >F7A7                   vcrsblink bss	1			; limit in 1/60 s
78    >F7A8                   vcursor	bss	2			; cursor blinker (BLWP @)
79    >F7AA                   vcurs	bss	1			; cursor blink state (0 or >80)
81    >F7AB                   vcursunder bss	8	   	; char or bits under cursor
83    >F7B3                   vheight bss 1           ; phys screen height in chars
84    >F7B4                   vwidth  bss 2           ; phys screen width in chars
85    >F7B6                       even
86                                
87    >F7B6                   vbit4stride bss 2        ; row stride  
88    >F7B8                   vbit4shift bss 2        ; shift for column # to byte
89    >F7BA                   vbit4mask bss 2        ;  mask for column # to byte portion
91    >F7BC                   vfont	bss	2			; GROM font addr
95    >F7BE                   vfgbg	bss	2			; foreground|background color
96    >F7C0                   vch	bss	1			; current char
98    >F7C1                   vcurschar bss	1			; char of cursor
100   >F7C2                   vwx	bss	1			; window left
101   >F7C3                   vwy	bss	1			; window right
102   >F7C4                   vwxs	bss	1			; width of window
103   >F7C5                   vwys	bss	1			; height of window
104   >F7C6                   vwcy	bss	1			; last cleared row
106   >F7C7                   vmode	bss	1         ; last set video mode (not M_xxx)
108   >F7C8                       even
109   >F7C8                   vtermptr bss 2          ; pointer to standard term stuff for mode
110                               
111   >F7CA                   vx	bss	1			; x-coord of cursor in window
112   >F7CB                   vy	bss	1			; y-coord of cursor in window
114   >F7CC                   vmono	bss	1
115   >F7CD                   vidmode	bss	1			; what mode are we in?  (M_xxxx)
117   >0000                   M_text	equ	0
118   >0001                   M_graph	equ	1
119   >0002                   M_multi equ 2
120   >0003                   M_bit	equ	3			; both mono and color
121   >0004                   M_bit4	equ	4			; new bitmap modes
122   >0005                   M_text2 equ 5           ; 80-column
124   >F7CE                   vscrnx  bss 2           ; res x
125   >F7D0                   vscrny  bss 2           ; res y
127   >F7D2                   vlinex	bss	2
128   >F7D4                   vliney	bss	2
130   >F7D6                   savedvregs bss 16       ; first 16 VRs set via vwreg
131   >F7D7                   vregr1    equ savedvregs + 1           ; VDP register 1
133   >0060                   _VIDVARSIZE  equ $ - _VIDVARSTART
135   >F7E6                   vbitbuf bss 256         ; buffer for bitmap font manip
139   >F8E6                   kbdlast bss 1           ; last char pressed (or 0)
140   >F8E7                   kbdtimer bss    1           ; timer (1/60 s) since last repeat
142   >F8E8                   kbdscan bss 1           ; most recent scancode     (0-47)
143   >F8E9                   kbdshft bss 1           ; most recent shift status (>70)
145   >F8EA                   kbdhead bss 1           ; head of kbd buffer
146   >F8EB                   kbdtail bss 1           ; tail of kbd buffer  
147                                               ; head==tail => empty
149   >0020                   kbdbufsize equ  32
150   >F8EC                   kbdbuf  bss kbdbufsize          
152   >F90C                   kbdlimit bss    1           ; 1/60s before repeating
153   >F90D                   kbddelay bss    1           ; delay between keyscans
155   >F90E                   kbdflag bss 1           ; keyboard state
156                                                   ; | >80 = currently repeating bit
157                                                   
158   >F910                       even
160   >F910                   randnoise bss 2			; random noise
161   >F912                   randseed1 bss 2			; random seed (lfsr)
162   >F914                   randseed2 bss 2			; random seed
166   >0020                   dskstacksize 	equ	>20
167   >F916                   dskstack bss	dskstacksize
169   >F936                   forthdsk bss	10			; filename for FORTH disk
175   >0000                   pv_clock    equ 0           ; the clock for the voice (done when > 64k)
176   >0002                   pv_incr     equ 2           ; the increment per clock (0 = owned by other voice)
177   >0004                   pv_hertz    equ 4           ; the frequency of the voice
178   >0006                   pv_track    equ 6           ; the global track owning this voice (addr)
179   >0008                   pv_port     equ 8           ; the sound port
180   >000A                   pv_freqmask equ 10          ; sound command frequency mask for the voice
181   >000B                   pv_volmask  equ 11          ; sound command volume mask for the voice
182   >000C                   pv_size     equ 12
186   >0010                   NUMVOICES   equ 16
187   >F940                   voices      bss pv_size * NUMVOICES   ; 4 sets of 3 tones + 1 noise
188   >FA00                   VOICES_END equ $
192   >0000                   lt_cmdptr   equ 0           ; pointer to next command (start of lump)
193   >0002                   lt_clock    equ 2           ; accumulator timing til next lump (when > 64k)
194   >0004                   lt_incr     equ 4           ; clock increment for lump length
195   >0006                   lt_tempoincr equ 6          ; increment for current tempo
196   >0008                   lt_a_d      equ 8           ; attack, decay (byte)
197   >0009                   lt_h_r      equ 9           ; hold, release (byte)
198   >000A                   lt_volume   equ 10          ; current volume (byte)
199   >000B                   lt_sustain  equ 11          ; sustain ratio (when adhr != 0)
200   >000C                   lt_vibrato  equ 12          ; vibrato 
201   >000D                   lt_tremolo  equ 13          ; tremolo 
202   >000E                   lt_waveform equ 14          ; waveform 
203   >000F                   lt_balance  equ 15          ; balance
204   >0010                   lt_size     equ 16
208   >0008                   NUMTRACKS   equ 8
209   >FA00                   tracks      bss lt_size * NUMTRACKS
210   >FA80                   TRACKS_END  equ $
214   >0004                   MAXTRACKSPERSONG equ 4 
216   >0000                   ls_phrase   equ 0          ; pointer to current phrase
217   >0002                   ls_phrases  equ 2           ; ptr in zero-terminated array of phrases 
218   >0004                   ls_tracks   equ 4           ; map of logical tracks to global tracks
219   >0008                   ls_size     equ 4 + MAXTRACKSPERSONG
223   >0004                   NUMSONGS    equ 4
224   >FA80                   songs       bss ls_size * NUMSONGS
225   >FAA0                   SONGS_END   equ $
227   >FAA0                   _RAMEND     equ   $
229                            
*** nforth.tsm
97    >0000                   	aorg	>0
99    >0000                   resetv	dw	mainws,INT0PC		; vector for RESET
      >0000=>FC00 >000E       
100   >0004                   int1v	dw	intws,INT1PC		; vector for INTERRUPTS
      >0004=>FC40 >0018       
104   >000C                   	aorg	>c
106   >000C=>30AA             	db		>30,>AA				; flag bytes for normal ROM
108   >000E                   INT0PC:
109   >000E=>06A0 >004A       	bl		@bankA
110   >0012=>0000             	data	0
111   >0014=>0460 >2808       	b		@reset
113   >0018                   INT1PC:	
114   >0018=>0300 >0000       	limi	0
115   >001C=>06A0 >004A       	bl		@bankA
116   >0020=>0001             	data	int1flag
117   >0022=>0460 >026C       	b		@int1
119   >0026                   XOP1PC:
120   >0026=>0300 >0000       	limi	0
121   >002A=>C07E             	mov		*14+,1				; code
122   >002C=>C00B             	mov		11,0
123   >002E=>06A0 >004A       	bl		@bankA
124   >0032=>0004             	data	xop1flag
125   >0034=>C2C0             	mov		0,11
126   >0036=>0460 >00C8       	b		@xop1_real
128   >0040                   	aorg 	>40
130   >0040                   xop0v	dw 0,0
      >0040=>0000 >0000       
131   >0044                   xop1v	dw	xopws,XOP1PC			; vector for XOP 1
      >0044=>FC40 >0026       
133   >0048=>0000             	data	0					; forth_start
136   >004A                   BANK:
138   >004A                   bankA:
139   >004A=>E83B >FB40       	soc		*11+,@intsfromA
140   >004E=>0720 >FFC0       	seto	@ROMBANK
141   >0052=>045B             	rt
142   >0054                   bankB:
143   >0054=>0720 >FFC2       	seto	@FTHBANK
144   >0058=>045B             	rt
146   >005A                   bankBrtwp:
147   >005A=>06A0 >0054       	bl		@bankB
148   >005E=>0380             	rtwp
150   >0060                   FORTH_COLD:
151   >0060=>06A0 >0054       	bl		@bankB
152   >0064=>1000             	nop
153   >0066=>1000             	nop
155   >0068                   FORTH_QUIT:
156   >0068=>06A0 >0054       	bl		@bankB
157   >006C=>1000             	nop
158   >006E=>1000             	nop
161   >0070                   ABORT:
162   >0070=>0300 >0000           limi    0
163   >0074=>0720 >FB40           seto    @intsfromA
165   >0078=>02E0 >FC00           lwpi    mainws
166   >007C=>10F5                 jmp     FORTH_QUIT         ; ctrl+fctn+shift+space breaks
167                               
168   >007E                   COMMON_END:
170   >007E                   bankrtwp:
171   >007E=>C020 >FB40       	mov		@intsfromA,0
172   >0082=>203B             	coc		*11+,0
173   >0084=>16EA             	jne		bankBrtwp
174   >0086=>0380             	rtwp
211   >0088                   xop1list dw	xop1_restore_mode,xop1_key_avail,xop1_read_key,xop1_emit,xop1_emit_raw
      >0088=>00E8 >00EE >0106 
      >008E=>010E >0118       
212   >0092=>0120 >0128 >012E 	dw		xop1_gotoxy,xop1_clear_window,xop1_set_window,xop1_get_window,xop1_set_mode
      >0098=>013A >0144       
213   >009C=>014C >0154 >015A 	dw		xop1_set_fgbg,xop1_get_fgbg,xop1_draw_line,xop1_draw_pixel,xop1_reset_screen
      >00A2=>0160 >0166       
214   >00A6=>0170 >017C >0184 	dw		xop1_set_vintflags,xop1_set_font,xop1_fill_rect,xop1_random,xop1_dsrlnk
      >00AC=>018A >0192       
215   >00B0=>019C >01A6 >01B2 	dw      xop1_get_vtab,xop1_set_vdpreg,xop1_get_vdpreg,xop1_set_vrwpage,xop1_set_vpage
      >00B6=>01BC >01C4       
216   >00BA=>01CC >01D2 >01E0 	dw      xop1_reset_palette,xop1_video_state,xop1_get_text_addr,xop1_get_xy,xop1_type
      >00C0=>01F0 >01F6       
217   >00C4=>0200 >0206       	dw      xop1_rw_block,xop1_qtrack
218   >00C8                   xop1last equ $
224   >00C8                   xop1_real:
225   >00C8=>C2AD >0014       	mov @SP+SP(13), SP			; stack ptr
226   >00CC=>064A             	dect SP
227   >00CE=>C68C             	mov 12 , *SP
228   >00D0=>C30B             	mov 11 , 12				; copy op ptr
230   >00D2=>0281 >0020       	ci	1,(xop1last - xop1list) / 2
231   >00D6=>1204             	jle	xop1_pick
232   >00D8                   xop1_out
233   >00D8=>C33A             	mov *SP+, 12
234   >00DA=>06A0 >007E       	bl	@bankrtwp
235   >00DE=>0004             	data	xop1flag
237   >00E0                   xop1_pick
238   >00E0=>A041             	a	1,1
239   >00E2=>C061 >0088       	mov	@xop1list(1),1
240   >00E6=>0451             	b	*1
242                               ;   0 = restore video mode (minimal)
243   >00E8                   xop1_restore_mode
244   >00E8=>06A0 >0496       	bl @vrestoremode
245   >00EC=>10F5             	jmp xop1_out
246                           	
247                           	;	1 = keyavail?
248   >00EE                   xop1_key_avail 
249   >00EE=>02E0 >FC60           lwpi    vidws
250   >00F2=>06A0 >1796           bl  @scankbd
251   >00F6=>02E0 >FC40           lwpi    xopws
252   >00FA=>06A0 >18EE       	bl	@kbdavail
253   >00FE=>04DC             	clr	*12
254   >0100=>1301             	jeq xop1_1_out
255   >0102=>071C             	seto *12
256   >0104                   xop1_1_out
257   >0104=>10E9             	jmp xop1_out
259                           	;	2 = readkey
260   >0106                   xop1_read_key	
261   >0106=>06A0 >18F6       	bl	@kbdread
263   >010A=>C700             	mov	0,*12
264   >010C=>10E5             	jmp xop1_out
266                           	;	3 = emit (interpreted)
267   >010E                   xop1_emit
268   >010E=>D06C >0001       	movb   @1(12),1
269   >0112=>06A0 >1B30       	bl     @emit
270   >0116=>10E0             	jmp    xop1_out
272                           	;	4 = emit, not interpreted
273   >0118                   xop1_emit_raw
274   >0118=>C05C             	mov    *12,1
275   >011A=>06A0 >1984       	bl	    @printchar
276   >011E=>10DC             	jmp    xop1_out
278                           	; 	5 = gotoxy
279   >0120                   xop1_gotoxy
280   >0120=>C01C             	mov *12,0		; hi=x, lo=y
281   >0122=>06A0 >19AE       	bl @gotoxy
282   >0126=>10D8             	jmp xop1_out
284                           	;	6 = cls (window)
285   >0128                   xop1_clear_window
286   >0128=>06A0 >1A0E           bl @termclear
287   >012C=>10D5             	jmp xop1_out
289                           	;	7 = text window
290                           	;	
291   >012E                   xop1_set_window
292   >012E=>C01C             	mov *12, 0
293   >0130=>C06C >0002       	mov @2(12), 1
294   >0134=>06A0 >1930       	bl @window
295   >0138=>10CF             	jmp xop1_out
297                           	;	8 = report text window
298   >013A                   xop1_get_window
299   >013A=>CF20 >F7C2       	mov @vwx, *12+
300   >013E=>CF20 >F7C4       	mov @vwxs, *12+
301   >0142=>10CA             	jmp xop1_out
303                           	;	9 = graphics mode (ONLY)
304   >0144                   xop1_set_mode
305   >0144=>C05C             	mov *12, 1
306   >0146=>0420 >0742       	blwp @vsetmode
307   >014A=>10C6             	jmp xop1_out
309                           	;	10 = set colors
310   >014C                   xop1_set_fgbg:
311   >014C=>C01C             	mov *12, 0
312   >014E=>06A0 >035E       	bl @vsetcolor
313   >0152=>10C2             	jmp xop1_out
315                           	;	11 = get colors
316   >0154                   xop1_get_fgbg:
317   >0154=>C720 >F7BE       	mov @vfgbg, *12
318   >0158=>10BF             	jmp xop1_out
320                           	;	12 = draw line
321   >015A                   xop1_draw_line:
322   >015A=>0420 >0B44       	blwp @line
323   >015E=>10BC             	jmp xop1_out
325                           	;	13 = draw pixel
326   >0160                   xop1_draw_pixel:
327   >0160=>0420 >0A64       	blwp @pixel
328   >0164=>10B9             	jmp xop1_out
330                           	;	14 = reset video screen
331   >0166                   xop1_reset_screen:
332   >0166=>06A0 >088A           bl  @vreset
333   >016A=>06A0 >04DE           bl  @vscreenon
334   >016E=>10B4             	jmp xop1_out
336                           	;	15 = set video int flags (see vintflags)
337   >0170                   xop1_set_vintflags:
338                               ; ensure cursor is erased (usually indicates we're drawing)
339   >0170=>06A0 >0A4E           bl     @vcursoroff
340   >0174=>D82C >0001 >FF60 	movb   @1(12), @vintflags
341   >017A=>10AE             	jmp    xop1_out
343                           	;	16 = set font
344   >017C                   xop1_set_font:
345   >017C=>C05C             	mov *12, 1
346   >017E=>06A0 >09D0       	bl @vsetfont
347   >0182=>10AA             	jmp xop1_out
349                           	;	17 = draw filled rect
350   >0184                   xop1_fill_rect:
351   >0184=>0420 >0ACA       	blwp @fillrect
352   >0188=>10A7             	jmp	xop1_out
354                           	;	18 = generate pseudorandom number
355   >018A                   xop1_random:
356   >018A=>06A0 >0210       	bl @random
357   >018E=>C700             	mov 0, *12
358   >0190=>10A3             	jmp xop1_out
360                           	;	19 = DSRLNK
361   >0192                   xop1_dsrlnk:
362   >0192=>C05C             	mov *12, 1
363   >0194=>0420 >1CE0       	blwp @dsrlnk
364   >0198=>C700             	mov 0, *12
365   >019A=>109E             	jmp xop1_out
367                               ;   20 = get video table ( # -- addr )
368   >019C                   xop1_get_vtab:
369   >019C=>C05C                 mov *12, 1
370   >019E=>06A0 >07A2           bl @vgettab
371   >01A2=>C700                 mov 0, *12
372   >01A4=>1033                 jmp xop1_out2
374                               ;   21 = set VDP reg ( newval index -- )
375   >01A6                   xop1_set_vdpreg:
376   >01A6=>C03C                 mov *12+, 0
377   >01A8=>0A80                 sla 0, 8
378   >01AA=>E01C                 soc *12, 0
379   >01AC=>06A0 >0460           bl @vwreg
380   >01B0=>102D                 jmp xop1_out2
382                               ;   22 = get VDP reg ( index -- val )
383   >01B2                   xop1_get_vdpreg:
384   >01B2=>C05C                 mov *12, 1
385   >01B4=>06A0 >048E           bl @vrreg    
386   >01B8=>C701                 mov 1, *12
387   >01BA=>1028                 jmp xop1_out2
389                               ;   23 = set r/w video page ( 0|1|2|3 -- val )
390   >01BC                   xop1_set_vrwpage:
391   >01BC=>C05C                 mov *12, 1
392   >01BE=>06A0 >03A6           bl @vrwpage
393   >01C2=>1024                 jmp xop1_out2
394                               
395                               ;   24 = set visible video page ( 0|1|2|3 -- val )
396   >01C4                   xop1_set_vpage:
397   >01C4=>C05C                 mov *12, 1
398   >01C6=>06A0 >03DE           bl @vpage
399   >01CA=>1020                 jmp xop1_out2
401                               ;   25 = reset palette
402   >01CC                   xop1_reset_palette:
403   >01CC=>06A0 >14D4           bl      @vsetpalette
404   >01D0=>101D                 jmp     xop1_out2
405                              
406                               ;   26 = save/restore/query video state   ( ... req -- ... )
407   >01D2                   xop1_video_state:
408   >01D2=>C05C                 mov     *12, 1
409   >01D4=>C0AC >0002           mov     @2(12), 2  ; if used
410   >01D8=>06A0 >096C           bl      @vsaverestore
411   >01DC=>C701                 mov     1, *12
412   >01DE=>1016                 jmp     xop1_out2
414                               ;   27 = get address of X/Y in window   ( x|y -- addr shift )
415   >01E0                   xop1_get_text_addr:
416   >01E0=>C01C                 mov     *12, 0
417   >01E2=>C060 >F7A4           mov     @vcoordaddr, 1
418   >01E6=>0691                 bl      *1
419   >01E8=>C700                 mov     0, *12
420   >01EA=>CB01 >0002           mov     1, @2(12)
421   >01EE=>100E                 jmp     xop1_out2
422                              
423                              ;    28 = get X/Y coords ( -- x|y )
424   >01F0                   xop1_get_xy:
425   >01F0=>C720 >F7CA           mov     @vx, *12
426   >01F4=>100B                 jmp     xop1_out2
427                              
428                              ;    29 = type (interpreted) ( caddr u -- )
429   >01F6                   xop1_type:
430   >01F6=>C0BC                 mov     *12+, 2
431   >01F8=>C0DC                 mov     *12, 3
432   >01FA=>06A0 >1B54           bl      @type
433   >01FE=>1006                 jmp     xop1_out2
434                                  
435                               ;   30 = read/write disk block ( block# addr r/w -- err )
436   >0200                   xop1_rw_block:
437   >0200=>0420 >1E00           blwp @rwblock
438   >0204=>1003                 jmp xop1_out2
440                               ;   31 = queue sound track ( track -- )
441   >0206                   xop1_qtrack:
442   >0206=>C09C                 mov     *12, 2
443   >0208=>06A0 >23E2           bl      @xsnd_queue_track
444                               ;jmp     xop1_out2
445                               
446   >020C                   xop1_out2:
447   >020C=>0460 >00D8           b   @xop1_out
448   >0210                   random:
449   >0210=>C020 >F912       	mov    @randseed1, 0
450   >0214=>C040             	mov    0, 1
451   >0216=>0910             	srl    0, 1
452   >0218=>0241 >0001       	andi   1, 1
453   >021C=>0501             	neg    1
454   >021E=>0241 >B400       	andi   1, >B400
455   >0222=>2801             	xor    1, 0
456   >0224=>C800 >F912       	mov    0, @randseed1
458   >0228=>0202 >6FE5       	li     2, >6fe5
459   >022C=>38A0 >F914       	mpy    @randseed2, 2
460   >0230=>0225 >7AB9       	ai     5, >7ab9
461   >0234=>C805 >F914       	mov    5, @randseed2
463   >0238=>A020 >F780       	a	   @uptime, 0
464   >023C=>0B05             	src    5, 0
465   >023E=>2805             	xor    5, 0
466   >0240=>2820 >F910       	xor    @randnoise, 0
467   >0244=>045B             	rt
473   >0246                   clr mov     *11+, 0
      >0246=>C03B             
474   >0248=>C07B                 mov     *11+, 1
475   >024A                   $1: clr     *0+
      >024A=>04F0             
476   >024C=>0641                 dect    1
477   >024E=>15FD                 jgt     $1-
478   >0250=>045B                 rt
479                               
480   >0252                   sinit	
481   >0252=>020A >F780       	li SP,sysstack + sysstacksize
482                           	
483                           	; setup NMI interrupt
484   >0256=>C820 >2888 >FFFC 	mov    #intws, @>fffc
485   >025C=>C820 >288A >FFFE 	mov    #abort, @>fffe
487   >0262=>0200 >ACE1       	li     0, >ACE1
488   >0266=>C800 >F912       	mov    0,@randseed1
489                           	
490                               ;   reset clears all memory
491                           	;clr	   @uptime
492                           	;clr	   @uptime + 2
493                           	;clr	   @timeout
494                           	;clr	   @userint
495                           	;clr    @randseed2
496                           	;clr    @randnoise
498   >026A=>045B             	rt
501                           	incl	int.i
*** int.i
31    >026C                   int1 limi	0			; disable interrupts 
      >026C=>0300 >0000       
33    >0270=>04CC             	clr		r12			; point to 9901
34    >0272=>1F02             	tb		2			; VDP interrupt?
35    >0274=>160D             	jne		intvdp		; yup.
37    >0276=>1F03                 tb      3           ; timer interrupt?
38    >0278=>1306                 jeq     $1+         ; nope, must be device
40    >027A=>1D03                 sbo     3           ; acknowledge
41                                
42    >027C=>C0E0 >FF64           mov     @timerisr, 3 ; does user hook the timer?
43    >0280=>1302                 jeq     $1+
44                                
45    >0282=>0693                 bl      *3          ; call user handler
46    >0284=>1044                 jmp     int1out
48    >0286                   $1:     
49                                ; device interrupt (some other bit)
50                                  	
51    >0286=>02E0 >83E0       	lwpi	>83e0		; they require this...
52    >028A=>02E0 >FC40       	lwpi	intws
53    >028E=>103F             	jmp		int1out		; don't handle device interrupts yet
55    >0290                   intvdp:
56    >0290=>1D02             	sbo	    2			; acknowledge VDP interrupt
57                                
58    >0292=>05A0 >F782       	inc		@uptime + 2	; time in 1/60 seconds
59    >0296=>1702             	jnc		intv00		; overflow?
60    >0298=>05A0 >F780          	inc		@uptime	 	; more time accuracy
62    >029C                   intv00:	
63    >029C=>D0E0 >FF60           movb    @vintflags,3    ; check our commands
64    >02A0=>0A13                 sla     3,1             ; suppress blinking/blanking?
65    >02A2=>1810                 joc     intv01
67                                ; ----------------------- blink/blank
68                                    
69    >02A4=>05E0 >F784       	inct	@timeout	    ; blank screen?
70    >02A8=>1602             	jne		intv00b
72    >02AA=>06A0 >04D6       	bl     	@vscreenoff 
74    >02AE                   intv00b:
75    >02AE=>0200 >F7A6       	li		0,vcrstimer
76    >02B2=>B420 >01B9       	ab		#1,*0			; cursor timer
77    >02B6=>9810 >F7A7       	cb		*0,@vcrsblink	; to blink or not to blink?
78    >02BA=>1A04             	jl		intv01
80    >02BC=>7410             	sb		*0,*0			; clear
81    >02BE=>C020 >F7A8       	mov		@vcursor,0		; get ptr
82    >02C2=>0410             	blwp	*0				; blink it
84    >02C4                   intv01:
85    >02C4=>0A13                 sla     3,1             ; suppress keyboard scan?
86    >02C6=>1805                 joc     intv02
88                                ; ----------------------- keyboard scan
89                                
90    >02C8=>B820 >01B9 >F8E7     ab      #1,@kbdtimer    ; inc repeat delay
91    >02CE=>06A0 >1796           bl      @scankbd        ; get keyboard, save char       TRASHES REGS
93    >02D2                   intv02:
94    >02D2=>D0E0 >FF60           movb    @vintflags, 3   ; kbd trashed, so reread
95    >02D6=>0A33                 sla     3,3
96    >02D8=>1808                 joc     intv03          ; suppress sprite motion?
97                                
98    >02DA=>C020 >F798           mov     @vsprmot, 0
99    >02DE=>1305                 jeq     intv03          ; skip if no sprite motion table
100                               
101   >02E0=>D020 >FF66           movb    @nsprmot, 0     ; or no sprites
102   >02E4=>1302                 jeq     intv03
103                               
104   >02E6=>0420 >0B9A           blwp    @vspritemotion
105                               
106   >02EA                   intv03:
107   >02EA=>0A13                 sla     3,1
108   >02EC=>1805                 joc     intv04          ; sound list?
110                               ; ------------------------ play sound list
111                               
112   >02EE=>C020 >FF68           mov     @sndlist, 0
113   >02F2=>1302                 jeq     intv04
114                               
115   >02F4=>0420 >1F68           blwp    @soundlist
116                               
117   >02F8                   intv04:    
118   >02F8=>0420 >23D4          blwp    @sound_sequencer
119                               
120                               ; ----------------------- user interrupt?
121                               
122   >02FC=>C020 >FF62       	mov		@userint,0		
123   >0300=>1303             	jeq		intv05
125   >0302=>0690             	bl		*0				; execute user interrupt routine
126   >0304=>02E0 >FC40       	lwpi	intws
128   >0308                   intv05:
129                               ;movb    #>00, @VDPWA    ; point to SR0     ; the client must guarantee this
130                               ;movb    #>8f, @VDPWA
131   >0308=>D820 >FF82 >FF61 	movb	@VDPST, @vstatus ; clear interrupt
133   >030E                   int1out:
135   >030E=>06A0 >007E       	bl		@bankrtwp
136   >0312=>0001             	data	int1flag
138   >0314                   int2
139   >0314=>06A0 >007E       	bl		@bankrtwp
140   >0318=>0002             	data	int2flag
*** nforth.tsm
503                           	incl	video.i
*** video.i
30    >031A                   h08	byte	8
      >031A=>08             
31    >031B                   hunder	byte	"_"
      >031B=>5F             
32    >031C                   h07	data	7
      >031C=>0007             
33    >031E                   	even
38    >031E                   vinit	  PUSH    SP, 0, 11
*** <expansion of push>
1     >031E=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0322=>CA80 >0002               mov  0 , @(2-0-1)*2(SP)
2     >0326=>C68B                     mov  11, @(2-1-1)*2(SP)
*** video.i
39                            	
40    >0328=>C820 >288C >FF72 	mov    #_VIDVARSTART, @vidvarstart
41    >032E=>C820 >288E >FF74 	mov    #_VIDVARSIZE, @vidvarsize
43    >0334=>0200 >000F       	li	   0,15
44    >0338=>C800 >F7A6       	mov	   0,@vcrstimer			 ; set up standard blink
45                            	;sb	   @vcurs,@vcurs		 ; it's off
47    >033C=>0201 >0107       	li	   1,>0107
48    >0340=>C801 >F7BE       	mov	   1,@vfgbg
50    >0344=>C820 >2890 >F7A2     mov    #>808, @vbsize          ; set in case we lazily switch to bitmap mode
52    >034A=>04C1                 clr     1
53    >034C=>0420 >0742       	blwp   @vsetmode
54    >0350=>06A0 >088A       	bl     @vreset
55                            	;bl    @vrestoremode
56    >0354=>06A0 >04DE       	bl     @vscreenon
58                            	POP    SP, 0, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0358=>C2FA                     mov *SP+,  11
2     >035A=>C03A                     mov *SP+,  0 
*** video.i
59    >035C=>045B             	rt
62    >035E                   vsetcolor
63    >035E=>064A             	dect   SP
64    >0360=>C68B             	mov    11, *SP
65    >0362=>C800 >F7BE       	mov    0, @vfgbg
66                            	
67    >0366=>9820 >0019 >F7CD 	cb     #M_text,@vidmode
68    >036C=>1304             	jeq    vsetcolor1
69    >036E=>9820 >021C >F7CD 	cb     #M_text2,@vidmode
70    >0374=>1608             	jne    vsetcolor0
72    >0376                   vsetcolor1:
73    >0376=>06A0 >038E           bl     @vgetcolorbyte
74    >037A=>06C0                 swpb   0
75    >037C=>0260 >0700       	ori    0,>700
76    >0380=>06A0 >0460       	bl     @vwreg
78    >0384=>1002             	jmp    vsetcolor9
80    >0386                   vsetcolor0:
81    >0386=>06A0 >0822       	bl     @vcolorsetup
82    >038A                   vsetcolor9:
83    >038A=>C2FA             	mov    *SP+, 11
84    >038C=>045B             	rt
87    >038E                   vgetcolorbyte
88    >038E=>04C0                 clr     0
89    >0390=>D020 >F7BE           movb    @vfgbg,0
90    >0394=>0A40                 sla     0,4
91    >0396=>F020 >F7BF           socb    @vfgbg+1,0
92    >039A=>045B                 rt
93                                
95    >039C                   vgetfgcolorbyte
96    >039C=>04C0                 clr     0
97    >039E=>D020 >F7BE           movb    @vfgbg,0
98    >03A2=>0A40                 sla     0,4
99    >03A4=>045B                 rt
100                               
101                               
106   >03A6                   vrwpage PUSH SP,11
*** <expansion of push>
1     >03A6=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >03A8=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video.i
107   >03AA=>06A0 >0A4E           bl      @vcursoroff
108   >03AE=>C081                 mov     r1 , r2
109   >03B0=>9820 >0014 >F7CD     cb     #M_bit4, @vidmode
110   >03B6=>1309                 jeq     vrwpage0
111                               
112                               ; text/graphics mode allows page access on 0x2000 boundaries
113   >03B8=>0AD1                 sla     r1, 13
114   >03BA=>C801 >FF70           mov     r1, @vtextpage
115   >03BE=>0A72                 sla     r2, 7
116   >03C0=>0242 >0400           andi    r2, >400
117   >03C4=>D802 >FF6C           movb    r2, @vpob 
118   >03C8=>1008                 jmp     vrwpageout
119                                
120   >03CA                   vrwpage0:
121   >03CA=>0A81                 sla     r1 , 8
122   >03CC=>C801 >FF6E           mov     r1 , @vpgrow       ; page row offset is 256 * page
123                               ; the page bank offset is this page row offset times bytes-per-line divided by 16k
124   >03D0=>38A0 >F7B6           mpy     @vbit4stride , r2   ; e.g. 256 * 1 , 128 * 1 ...
125   >03D4=>0A23                 sla     r3 , 2
126   >03D6=>D803 >FF6C           movb    r3 , @vpob
127   >03DA                   vrwpageout:    
128                               POP SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >03DA=>C2FA                     mov *SP+,  11
*** video.i
129   >03DC=>045B                 rt
130                                   
134   >03DE                   vpage PUSH SP,11
*** <expansion of push>
1     >03DE=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >03E0=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video.i
135   >03E2=>C001                 mov     r1 , r0
136   >03E4=>D2E0 >F7CD           movb    @vidmode, 11
137   >03E8=>92E0 >0014           cb     #M_bit4, 11
138   >03EC=>1320                 jeq     vpage0
139                               
140                               ; text/graphics mode allows page access on 0x2000 boundaries
141   >03EE=>0A30                 sla     0, 3
142   >03F0=>7000                 sb      0, 0
143   >03F2=>92E0 >021C           cb     #M_text2, 11
144   >03F6=>1303                 jeq     vpage1
145   >03F8=>0260 >0200           ori     0,>200
146   >03FC=>101B                 jmp     vpageout
147                               
148   >03FE                   vpage1:
149                               ; V9938 needs lower bits set
150   >03FE=>0260 >0203           ori     0,>203
151   >0402=>06A0 >0460           bl      @vwreg
152                               
153                               ; move color table too (A00 away from screen)
154   >0406=>C001                 mov     1, 0
155   >0408=>0240 >0001           andi    0, 1
156   >040C=>0A70                 sla     0, 7
157   >040E=>0260 >032F           ori     0,>32f
158   >0412=>06A0 >0460           bl      @vwreg
159   >0416=>C001                 mov     1, 0
160   >0418=>0910                 srl     0, 1
161   >041A=>0260 >0A00           ori     0,>A00
162   >041E=>06A0 >0460           bl      @vwreg
163                               
164                               ; and move pattern table
165   >0422=>C001                 mov     1, 0
166   >0424=>0A20                 sla     0, 2
167   >0426=>05C0                 inct    0
168   >0428=>0260 >0400           ori     0,>400
169   >042C=>1003                 jmp     vpageout
170                                
171   >042E                   vpage0:    
172   >042E=>0A50                 sla     r0 , 5
173   >0430=>0260 >821F           ori     r0 , >821f
174   >0434                   vpageout:    
175   >0434=>06A0 >0460           bl      @vwreg
176                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0438=>C2FA                     mov *SP+,  11
*** video.i
177   >043A=>045B                 rt
189   >043C                   gwaddr	movb	0,@GPLWA
      >043C=>D800 >FF96       
190   >0440=>06C0             	swpb	0
191   >0442=>D800 >FF96       	movb	0,@GPLWA
192   >0446=>06C0             	swpb	0
193   >0448=>045B             	rt
201   >044A                   vwaddr	ori	0,>4000
      >044A=>0260 >4000       
202   >044E                   vraddr
203   >044E=>06C0             	swpb	0
204   >0450=>D800 >FF8A       	movb	0,@VDPWA
205   >0454=>06C0             	swpb	0
206   >0456=>D800 >FF8A       	movb	0,@VDPWA
207   >045A=>0240 >3FFF       	andi    0,>3fff
208   >045E=>045B             	rt
209                           	
212   >0460                   vwreg   
213   >0460=>064A                 dect    SP
214   >0462=>C681                 mov     1, *SP
215   >0464=>C040                 mov     0, 1
216   >0466=>0241 >7FFF           andi    1,>7FFF
217   >046A=>0260 >8000           ori     0,>8000
218   >046E=>06C0                 swpb    0
219   >0470=>0281 >0F00           ci      1,>0F00
220   >0474=>1403                 jhe     vwreg0
221   >0476=>0981                 srl     1,8
222   >0478=>D840 >F7D6           movb    0,@savedvregs(1)
223   >047C                   vwreg0:    
224   >047C=>D800 >FF8A           movb    0,@VDPWA
225   >0480=>06C0                 swpb    0
226   >0482=>D800 >FF8A           movb    0,@VDPWA
227   >0486=>C07A                 mov     *SP+,1
228   >0488=>045B                 rt
231   >048A                   vwregnext 
232   >048A=>C03B                 mov     *11+, 0
233   >048C=>10E9                 jmp     vwreg
234                               
240   >048E                   vrreg
241   >048E=>D061 >F7D6           movb    @savedvregs(1),1
242   >0492=>0981                 srl     1,8
243   >0494=>045B                 rt
244                               
248   >0496                   vrestoremode
249   >0496=>064A                 dect SP
250   >0498=>C68B                 mov 11,*SP
251   >049A=>020C >FF8A           li  12,VDPWA
252   >049E=>0201 >F7D6           li  1, savedvregs
253   >04A2=>0200 >8000           li 0, >8000
254   >04A6                   vrm0 movb *1+, *12
      >04A6=>D731             
255   >04A8=>D700                 movb 0, *12
256   >04AA=>0220 >0100           ai 0, >100
257   >04AE=>0280 >8F00           ci 0, >8F00    
258   >04B2=>16F9                 jne  vrm0
259   >04B4=>06A0 >04DE           bl @vscreenon
260   >04B8=>C2FA                 mov *SP+,11
261   >04BA=>045B                 rt
269   >04BC                   vclr	dect SP
      >04BC=>064A             
270   >04BE=>C68B             	mov	11,*SP
271   >04C0=>064A             	dect SP
272   >04C2=>C682             	mov	2,*SP
275   >04C4=>06A0 >044A       	bl	@vwaddr
276   >04C8                   vclr0	movb	1,@VDPWD
      >04C8=>D801 >FF88       
277   >04CC=>0602             	dec	2
278   >04CE=>16FC             	jne	vclr0
279                           	
280   >04D0=>C0BA             	mov	*SP+,2
281   >04D2=>C2FA             	mov	*SP+,11
282   >04D4=>045B             	rt
302   >04D6                   vscreenoff
303   >04D6=>5820 >0215 >F7D7 	szcb 	#>40,@vregr1
304   >04DC=>1003             	jmp	vreg1set
305   >04DE                   vscreenon
306   >04DE=>F820 >0215 >F7D7 	socb	#>40,@vregr1
307   >04E4                   vreg1set:
308   >04E4=>D820 >F7D7 >FF8A 	movb	@vregr1,@VDPWA
309   >04EA=>D820 >00D3 >FF8A 	movb	#>81,@VDPWA
310   >04F0=>045B             	rt
314   >04F2                   vtmap	dw	vscreen,vscreensz,vcolors,vcolorsz,vpatts,vpattsz,vsprpat,vsprites,vsprmot,vsprcol,vfree
      >04F2=>F786 >F788 >F78E 
      >04F8=>F790 >F78A >F78C 
      >04FE=>F796 >F792 >F798 
      >0504=>F794 >F79A       
315   >0508=>F7CE >F7D0       	dw  vscrnx,vscrny
316   >001A                   vtmapsize equ $-vtmap
323   >050C                   vtxt db 0,>0,1,>B0,2,>0,4,>1,-1
      >050C=>0000 >01B0 >0200 
      >0512=>0401 >FF       
324   >0516=>0000 >03C0 >0000     dw  >0,960,>0,>0,>800,>800,0,0,0,0,>1000
      >051C=>0000 >0800 >0800 
      >0522=>0000 >0000 >0000 
      >0528=>0000 >1000       
325   >052C=>0100 >00C0           dw 256,192
326   >0530=>0930 >2818 >031B     dw vtextterms, >2818, hunder
336   >0536                   vgfx 	db	0,>0,1,>A0,2,>0,3,>E,4,>1,5,>6,6,>0,-1
      >0536=>0000 >01A0 >0200 
      >053C=>030E >0401 >0506 
      >0542=>0600 >FF       
337   >0546=>0000 >0300 >0380 	dw	>0,768,>380,>20,>800,>800,>000,>300,>3A0,0,>1000
      >054C=>0020 >0800 >0800 
      >0552=>0000 >0300 >03A0 
      >0558=>0000 >1000       
338   >055C=>0100 >00C0       	dw 256,192
339   >0560=>0930 >2018 >031B 	dw vtextterms, >2018, hunder
350   >0566                   vbit db	0,>2,1,>A0,2,>6,3,>ff,4,>03,5,>36,6,>3,-1
      >0566=>0002 >01A0 >0206 
      >056C=>03FF >0403 >0536 
      >0572=>0603 >FF       
351   >0576=>1800 >0300 >2000 	dw	>1800,>300,>2000,>1800,>0000,>1800,>1800,>1b00,>1B80,0,>3800
      >057C=>1800 >0000 >1800 
      >0582=>1800 >1B00 >1B80 
      >0588=>0000 >3800       
352   >058C=>0100 >00C0           dw 256,192
353   >0590=>0938 >2018 >072A     dw vbitterms, >2018,hff
366   >0596                   vbit3  db  0,>4,1,>A0,2,>E,3,>ff,4,>03,5,>36,>B,0,6,>3,-1
      >0596=>0004 >01A0 >020E 
      >059C=>03FF >0403 >0536 
      >05A2=>0B00 >0603 >FF 
367   >05A8=>3800 >0300 >2000     dw  >3800,768,>2000,>1800,>0,>1800,>1800,>1b00,>1b80,>1900,>3B00
      >05AE=>1800 >0000 >1800 
      >05B4=>1800 >1B00 >1B80 
      >05BA=>1900 >3B00       
368   >05BE=>0100 >00C0           dw 256,192
369   >05C2=>0938 >2018 >072A     dw vbitterms, >2018, hff
370                               
371                               
380   >05C8                   vbit4  db  0,>6,1,>A0,2,>0,5,>F4,>B,0,6,>E,-1
      >05C8=>0006 >01A0 >0200 
      >05CE=>05F4 >0B00 >060E 
      >05D4=>FF             
381   >05D6=>0000 >0000 >0000     dw >0000,0,>0000,>0000,>0,>6400,>7000,>7A00,>7A80,>7800,>8000
      >05DC=>0000 >0000 >6400 
      >05E2=>7000 >7A00 >7A80 
      >05E8=>7800 >8000       
382   >05EC=>0100 >00D4           dw 256,212
383   >05F0=>0080 >0001 >FFFE     dw >80, 1, >FFFE
384   >05F6=>0940 >201B >072A     dw vbit4terms, >201B, hff
394   >05FC                   vbit5  db  0,>8,1,>A0,2,>0,5,>F4,>B,0,6,>E,7,>FF,-1
      >05FC=>0008 >01A0 >0200 
      >0602=>05F4 >0B00 >060E 
      >0608=>07FF >FF       
395   >060C=>0000 >0000 >0000     dw  >0000,0,>0000,>0000,>0,>6A00,>7000,>7A00,>7A80,>7800,>8000
      >0612=>0000 >0000 >6A00 
      >0618=>7000 >7A00 >7A80 
      >061E=>7800 >8000       
396   >0622=>0200 >00D4           dw 512,212
397   >0626=>0080 >0002 >FFFC     dw >80, 2, >FFFC
398   >062C=>0948 >401B >072A     dw vbit5terms, >401B, hff
408   >0632                   vbit6  db  0,>A,1,>A0,2,>0,5,>AC,>B,>1,6,>1B,-1
      >0632=>000A >01A0 >0200 
      >0638=>05AC >0B01 >061B 
      >063E=>FF             
409   >0640=>0000 >0000 >0000     dw  >0000,0,>0000,>0000,>0,>D400,>D800,>D600,>D680,>D400,>E000
      >0646=>0000 >0000 >D400 
      >064C=>D800 >D600 >D680 
      >0652=>D400 >E000       
410   >0656=>0200 >00D4           dw 512,212
411   >065A=>0100 >0001 >FFFE     dw >100, 1, >FFFE
412   >0660=>0940 >401B >072A     dw vbit4terms, >401B, hff
422   >0666                   vbit7  db  0,>E,1,>A0,2,>0,5,>AC,>B,>1,6,>1B,-1
      >0666=>000E >01A0 >0200 
      >066C=>05AC >0B01 >061B 
      >0672=>FF             
423   >0674=>0000 >0000 >0000     dw  >0000,0,>0000,>0000,>0,>D400,>D800,>D600,>D680,>D400,>E000
      >067A=>0000 >0000 >D400 
      >0680=>D800 >D600 >D680 
      >0686=>D400 >E000       
424   >068A=>0100 >00D4           dw 256,212
425   >068E=>0100 >0000 >FFFF     dw >100, 0, >FFFF
426   >0694=>0950 >201B >072A     dw vbit7terms, >201B, hff
434   >069A                   vtxt2  db  0,>4,1,>B0,2,>0,3,>2f,>A,0,4,>2,>D,>22,-1
      >069A=>0004 >01B0 >0200 
      >06A0=>032F >0A00 >0402 
      >06A6=>0D22 >FF       
435   >06AA=>0000 >0870 >0A00     dw  >0,2160,>A00,2160/8,>1000,>800,0,0,0,0,>1800
      >06B0=>010E >1000 >0800 
      >06B6=>0000 >0000 >0000 
      >06BC=>0000 >1800       
436   >06C0=>0200 >00D4           dw  512, 212
437   >06C4=>0930 >501B >031B     dw vtextterms, >501B, hunder
438                               
448   >06CA                   vmonobit db 0,>2,1,>B0,2,>6,3,>80,4,>03,5,>36,6,>3,-1
      >06CA=>0002 >01B0 >0206 
      >06D0=>0380 >0403 >0536 
      >06D6=>0603 >FF       
449   >06DA=>1800 >0300 >2000     dw  >1800,>300,>2000,>800,>0000,>1800,>1800,>1B00,>1B80,0,>2800
      >06E0=>0800 >0000 >1800 
      >06E6=>1800 >1B00 >1B80 
      >06EC=>0000 >2800       
450   >06F0=>0100 >00C0           dw 256,192
451   >06F4=>0938 >2018 >072A     dw vbitterms, >2018, hff
460   >06FA                   vmulti    db  0,>0,1,>8,2,>0,3,>0,4,>1,5,>6,6,>0,-1
      >06FA=>0000 >0108 >0200 
      >0700=>0300 >0401 >0506 
      >0706=>0600 >FF       
461   >070A=>0000 >0300 >0000     dw  >0,768,0,0,>800,>800,>1000,>300,>380,0,>1800
      >0710=>0000 >0800 >0800 
      >0716=>1000 >0300 >0380 
      >071C=>0000 >1800       
462   >0720=>0100 >00C0           dw 256,192
463   >0724=>0958 >2018 >031B     dw vmultiterms, >2018, hunder
464                               
466   >072A                   hff db >ff
      >072A=>FF             
467   >072C                       even
468   >072C                   vmodesetups	
469   >072C=>0C4C                 dw vtextsetup       ; 0
470   >072E=>0C98                 dw vgraphsetup      ; 1
471   >0730=>0E0E                 dw vbitmapsetup     ; 2
472   >0732=>0E42                 dw vbitmap3setup    ; 3
473   >0734=>14F8                 dw vbitmap4setup    ; 4
474   >0736=>152A                 dw vbitmap5setup    ; 5
475   >0738=>1530                 dw vbitmap6setup    ; 6
476   >073A=>1536                 dw vbitmap7setup    ; 7
477   >073C=>0C6E                 dw vtext2setup      ; 8
478   >073E=>0E36                 dw vmonosetup       ; 9
479   >0740=>0CBA                 dw vmultisetup      ; 10
484                            Vector vsetmode, vidws
*** <expansion of vector>
1     >0742                   vsetmode  data vidws, vsetmode_entry
      >0742=>FC60 >0746       
2     >0746                   vsetmode_entry:    
*** video.i
485   >0746=>020A >F740           li     SP,vstack + vstacksize 
486   >074A=>D06D >0003           movb   @3(13), 1
487   >074E=>D801 >F7C7           movb   1, @vmode
488   >0752=>0971             	srl    1, 7
489   >0754=>C061 >072C       	mov    @vmodesetups(1), 1
490   >0758=>0691             	bl     *1
492   >075A=>0380             	rtwp
495   >075C                   vsetupregs:
496   >075C=>064A                 dect SP
497   >075E=>C68B                 mov 11,*SP
498                               
499   >0760                   vts0 cb #>ff,*1
      >0760=>9460 >045D       
500   >0764=>1304                 jeq  vts1
501   >0766=>C031                 mov   *1+, 0
502   >0768=>06A0 >0460           bl  @vwreg
503   >076C=>15F9             	jgt	vts0
505   >076E                   vts1:
506   >076E=>05C1                 inct 1
508   >0770=>06A0 >038E           bl  @vgetcolorbyte
509   >0774=>06C0                 swpb 0
510   >0776=>0260 >0700           ori 0,>700
511   >077A=>06A0 >0460           bl @vwreg
513   >077E=>7820 >FF6C >FF6C     sb      @vpob, @vpob
514   >0784=>04E0 >FF6E           clr     @vpgrow
515   >0788=>04E0 >FF70           clr     @vtextpage
516                           	
517   >078C=>C2FA             	mov *SP+,11
518   >078E=>045B             	rt
521   >0790                   vsetupaddrs:
522   >0790=>0200 >04F2       	li	0,vtmap
523   >0794                   vsa1 mov *1+,3
      >0794=>C0F1             
524   >0796=>C130             	mov	*0+,4
525   >0798=>C503             	mov	3,*4
526   >079A=>0280 >050C       	ci 0,vtmap + vtmapsize
527   >079E=>11FA             	jlt	vsa1
528   >07A0=>045B             	rt
531   >07A2                   vgettab
532   >07A2=>A041                 a 1,1
533   >07A4=>C021 >04F2           mov @vtmap(1), 0
534   >07A8=>045B                 rt
535                               
536   >07AA                   vcleartables:
537   >07AA=>064A             	dect SP	
538   >07AC=>C68B             	mov 11,*SP
540                               ; don't clear patterns... font routines and/or vtermclear does that
541                               ;mov @vpatts, 0
542                               ;bl @vsetbank
543                               ;clr 1
544                               ;mov @vpattsz, 2
545                               ;bl @vclr
546   >07AE=>1002                 jmp vct0
547                               
548   >07B0                   vcleartables4x:
549   >07B0=>064A                 dect SP 
550   >07B2=>C68B                 mov 11,*SP
551   >07B4                   vct0:
552   >07B4=>06A0 >0822           bl @vcolorsetup
554   >07B8=>06A0 >14D4           bl @vsetpalette
555                               
556   >07BC                   vclrtabscr:    
557   >07BC=>C0A0 >F788           mov @vscreensz, 2
558   >07C0=>1306                 jeq vclrtabspr
559   >07C2=>C020 >F786           mov @vscreen, 0
560   >07C6=>0201 >2000           li 1,>2000
561   >07CA=>06A0 >04BC           bl @vclr
562                               
563   >07CE                   vclrtabspr:
564   >07CE=>C020 >F792       	mov	@vsprites,0
565   >07D2=>1325             	jeq vclrtabout
566                           	
567                           	; delete the sprites; $d0 for mode 1 and $d8 for mode 2
568   >07D4=>C060 >F794           mov @vsprcol, 1
569   >07D8=>1603                 jne vclrtabspr2
570   >07DA=>D060 >010E       	movb #>d0,1
571   >07DE=>100C                 jmp vclrtabsprs
572   >07E0                   vclrtabspr2:
574                               ; clear sprite color table too
575   >07E0=>C001                 mov 1, 0
576   >07E2=>04C1                 clr 1
577   >07E4=>0202 >0200           li 2,>200
578   >07E8=>06A0 >166C           bl @vsetbank
579   >07EC=>06A0 >04BC           bl @vclr
580   >07F0=>C020 >F792           mov @vsprites, 0
581   >07F4=>D060 >0174       	movb #>d8,1
582   >07F8                   vclrtabsprs:
583   >07F8=>06A0 >166C           bl @vsetbank
584   >07FC=>06A0 >044A           bl  @vwaddr    
585   >0800=>D801 >FF8A           movb 1,@VDPWA
586   >0804=>0580             	inc 0
587   >0806=>04C1             	clr	1
588   >0808=>0202 >007F       	li	2,127
589   >080C=>06A0 >04BC       	bl	@vclr
591   >0810=>C020 >F798       	mov	@vsprmot,0
592                               ;bl @vsetbank       ; it'll be in the same page
593   >0814=>04C1             	clr	1
594   >0816=>0202 >0080       	li	2,128
595   >081A=>06A0 >04BC       	bl	@vclr
597   >081E                   vclrtabout:
598   >081E=>C2FA             	mov *SP+,11
599   >0820=>045B             	rt
604   >0822                   vcolorsetup
605   >0822=>C0A0 >F790           mov @vcolorsz, 2
606   >0826=>1313                 jeq vcolorsetup0
607   >0828=>064A                 dect SP
608   >082A=>C68B                 mov 11, *SP
609   >082C=>04C1                 clr 1
610   >082E=>9820 >021C >F7CD     cb #M_text2, @vidmode
611   >0834=>1303                 jeq vcolorsetup1
612   >0836=>06A0 >038E           bl @vgetcolorbyte
613   >083A=>D040                 movb 0,1
614   >083C                   vcolorsetup1:    
615   >083C=>C020 >F78E           mov @vcolors,0
616   >0840=>A020 >FF70           a   @vtextpage, 0
617   >0844=>06A0 >166C           bl  @vsetbank
618   >0848=>06A0 >04BC           bl  @vclr
619   >084C=>C2FA                 mov *SP+, 11
620   >084E                   vcolorsetup0:   
621   >084E=>045B                 rt
627   >0850                   vtermsetup
628                               PUSH    SP,R11
*** <expansion of push>
1     >0850=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0852=>C68B                     mov  R11, @(1-0-1)*2(SP)
*** video.i
629                               
630   >0854=>C060 >F7C8           mov     @vtermptr,1
631   >0858=>0200 >0928           li      0,vtermptrs
632   >085C=>C0F1                 mov     *1+,3
633   >085E                   vtts0:
634   >085E=>C0B0                 mov     *0+,2
635   >0860=>C4B3                 mov     *3+,*2
636   >0862=>0280 >0930           ci      0,vtermptrsend
637   >0866=>16FB                 jne     vtts0
638                               
639                               ; force window to full screen
640   >0868=>C811 >F7C4           mov     *1, @vwxs
641                               
642   >086C=>D0B1                 movb    *1+, 2
643   >086E=>0982                 srl     2,8
644   >0870=>C802 >F7B4           mov     2,@vwidth
645   >0874=>D831 >F7B3           movb    *1+, @vheight
646                               
647   >0878=>04E0 >F7C2           clr     @vwx
648   >087C=>04E0 >F7CA           clr     @vx
650                               ; get cursor char
651   >0880=>C0B1                 mov     *1+,2
652   >0882=>D812 >F7C1           movb    *2,@vcurschar
653                               
654                               POP     SP,R11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0886=>C2FA                     mov *SP+,  R11
*** video.i
655   >0888=>045B                 rt
662   >088A                   vreset
663                               PUSH SP,1,2,11    
*** <expansion of push>
1     >088A=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >088E=>CA81 >0004               mov  1 , @(3-0-1)*2(SP)
2     >0892=>CA82 >0002               mov  2 , @(3-1-1)*2(SP)
3     >0896=>C68B                     mov  11, @(3-2-1)*2(SP)
*** video.i
664                               
665   >0898=>06A0 >0850           bl @vtermsetup
666   >089C=>06A0 >07AA           bl  @vcleartables
667                               
668   >08A0=>D060 >F7CD           movb @vidmode,1
669   >08A4=>9060 >0019           cb   #M_text,1
670   >08A8=>1309                 jeq  vresettextish
671   >08AA=>9060 >021C           cb   #M_text2,1
672   >08AE=>1306                 jeq  vresettextish
673   >08B0=>9060 >0078           cb   #M_multi,1
674   >08B4=>1304                 jeq  vresetmulti
675   >08B6=>9060 >01B9           cb   #M_graph,1
676   >08BA=>1619                 jne  vreset0
678   >08BC                   vresettextish:    
679   >08BC=>102C                 jmp     vresetout
681   >08BE                   vresetmulti:
682                               ; setup standard SIT for multi mode
683                               ; 0 1 2 3 ... 30 31  x  4
684                               ; 32 33 ... 62 63    x 4
685                               ; ... 190 191
686   >08BE=>C020 >F786           mov     @vscreen,0      ; never banked
687   >08C2=>06A0 >044A           bl      @vwaddr
688   >08C6=>04C1                 clr     1
689   >08C8                   vbs4    li  2, 4 
      >08C8=>0202 >0004       
690   >08CC                   vbs3    movb 1,@VDPWD
      >08CC=>D801 >FF88       
691   >08D0=>0221 >0100           ai      1,>0100
692   >08D4=>2460 >2892           czc     #>1f00, 1
693   >08D8=>16F9                 jne     vbs3
694   >08DA=>0221 >E000           ai      1,->2000
695   >08DE=>0602                 dec     2
696   >08E0=>15F5                 jgt     vbs3
697   >08E2=>0221 >2000           ai      1,>2000
698   >08E6=>0281 >C000           ci      1,>C000
699   >08EA=>1AEE                 jl      vbs4
700   >08EC=>1014                 jmp     vresetout
701                               
702   >08EE                   vreset0:    
703   >08EE=>9820 >0018 >F7CD     cb      #M_bit,@vidmode
704   >08F4=>160E                 jne     vreset1
705                               
706                               ; setup standard SIT for bitmap mode
707   >08F6=>C020 >F786           mov     @vscreen,0      ; never banked
708   >08FA=>06A0 >044A           bl      @vwaddr
709   >08FE=>04C1                 clr     1
710   >0900=>0202 >0300           li      2,768
711   >0904                   vbs2    movb    1,@VDPWD
      >0904=>D801 >FF88       
712   >0908=>0221 >0100           ai      1,>100
713   >090C=>0602                 dec     2
714   >090E=>15FA                 jgt     vbs2
715                               
716   >0910=>1002                 jmp     vresetbitcommon
718   >0912                   vreset1:
719                               ; must be M_bit4
720                               
721   >0912=>06A0 >07B0           bl      @vcleartables4x
722                               
723   >0916                   vresetbitcommon:
724                                   
725   >0916                   vresetout:
726   >0916=>04C1                 clr     1
727   >0918=>06A0 >09D0           bl      @vsetfont
728   >091C=>06A0 >1A0E           bl      @termclear
729                               
730                               POP     SP,1,2,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0920=>C2FA                     mov *SP+,  11
2     >0922=>C0BA                     mov *SP+,  2 
3     >0924=>C07A                     mov *SP+,  1 
*** video.i
731   >0926=>045B                 rt
733   >0928                   vtermptrs dw vdrawchar,vclearline,vcursor,vcoordaddr
      >0928=>F79C >F7A0 >F7A8 
      >092E=>F7A4             
734   >0930                   vtermptrsend equ $
736   >0930                   vtextterms dw vtextchar,vtextclearline,vtextcursor,vtextaddr
      >0930=>0D54 >0D10 >0DC6 
      >0936=>0CC6             
737   >0938                   vbitterms dw  vbitchar,vbitclearline,vbitcursor,vbitaddr
      >0938=>0F04 >0E8E >0F7A 
      >093E=>0E5E             
738   >0940                   vbit4terms dw  vbit4xchar,vbit4xclearline,vbit4xcursor,vbit4xaddr
      >0940=>1696 >163E >16EC 
      >0946=>153C             
739   >0948                   vbit5terms dw  vbit4xchar,vbit4xclearline,vbit4xcursor,vbit4xaddr
      >0948=>1696 >163E >16EC 
      >094E=>153C             
740   >0950                   vbit7terms dw  vbit4xchar,vbit4xclearline,vbit4xcursor,vbit4xaddr
      >0950=>1696 >163E >16EC 
      >0956=>153C             
741   >0958                   vmultiterms dw vnopchar,vnopclearline,vnopcursor,vtextaddr
      >0958=>0E0A >0E0A >0E0A 
      >095E=>0CC6             
744   >0960                   vstdmode
745                               ;clr     @vpob
746                               ;clr     @vpgrow
747                               ;clr     @vtextpage
748   >0960=>04E0 >F7B6           clr     @vbit4stride
749   >0964=>0200 >0900           li      0, >900      ; 192 rows
750   >0968=>0460 >0460           b       @vwreg       
760   >CCB1                   vsaverestore_s equ >ccb1    ; mov *1+, *2+
761   >CC72                   vsaverestore_r equ >cc72    ; mov *2+, *1+
763   >096C                   vsaverestore 
764   >096C=>C041                 mov     1, 1
765   >096E=>1322                 jeq     vsvrssz
767                               PUSH    SP,11,12  
*** <expansion of push>
1     >0970=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0974=>CA8B >0002               mov  11 , @(2-0-1)*2(SP)
2     >0978=>C68C                     mov  12, @(2-1-1)*2(SP)
*** video.i
768   >097A=>0204 >CCB1           li      4, vsaverestore_s
769   >097E=>0281 >0001           ci      1, 1
770   >0982=>1302                 jeq     vsvrsrst
771   >0984=>0204 >CC72           li      4, vsaverestore_r
772   >0988                   vsvrsrst:    
773   >0988=>0201 >FF6C           li      1, _CPURAMSTART
774   >098C=>0203 >0005           li      3, (_CPURAMSIZE+1) / 2
775   >0990                   vsvrsrst0:  x 4
      >0990=>0484             
776   >0992=>0603                 dec     3
777   >0994=>15FD                 jgt     vsvrsrst0
778   >0996=>0201 >F786           li      1, _VIDVARSTART
779   >099A=>0203 >0030           li      3, (_VIDVARSIZE+1) / 2
780   >099E                   vsvrsrst1:  x 4
      >099E=>0484             
781   >09A0=>0603                 dec     3
782   >09A2=>15FD                 jgt     vsvrsrst1
783                               
784   >09A4=>0284 >CC72           ci      4, vsaverestore_r
785   >09A8=>1602                 jne     vsvrsrst2
787                               ;movb    @vmode, 1
788                               ;srl     1, 7
789                               ;mov     @vmodesetups(1), 1
790                               ;bl      *1
791                               
792   >09AA=>06A0 >0496           bl      @vrestoremode
793                               
794   >09AE                   vsvrsrst2:    
795                               POP     SP,11,12
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >09AE=>C33A                     mov *SP+,  12
2     >09B0=>C2FA                     mov *SP+,  11 
*** video.i
796   >09B2=>045B                 rt
797                                       
798   >09B4                   vsvrssz:
799   >09B4=>0201 >000B           li      1, _CPURAMSIZE+1
800   >09B8=>0221 >0061           ai      1, _VIDVARSIZE+1
801   >09BC=>045B                 rt
802                               
804   >09BE                   vfonts dw vf_8x8, vf_6x8, vf_5x6
      >09BE=>09C4 >09C8 >09CC 
806   >09C4                   vf_8x8 dw >0808, grom_font8x8
      >09C4=>0808 >0130       
807   >09C8                   vf_6x8 dw >0608, grom_font8x8
      >09C8=>0608 >0130       
808   >09CC                   vf_5x6 dw >0506, grom_font5x6
      >09CC=>0506 >0930       
816   >09D0                   vsetfont PUSH SP,11
*** <expansion of push>
1     >09D0=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >09D2=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video.i
817   >09D4=>A041                 a      r1,r1
818   >09D6=>C061 >09BE           mov    @vfonts(r1), r1
819                               
820   >09DA=>C831 >F7A2           mov    *1+, @vbsize
821   >09DE=>C011                 mov    *1, 0
822   >09E0=>C800 >F7BC           mov    0,@vfont
824   >09E4=>9820 >0018 >F7CD     cb     #M_bit, @vidmode
825   >09EA=>1316                 jeq    vsetfont1
826   >09EC=>9820 >0014 >F7CD     cb     #M_bit4, @vidmode
827   >09F2=>1312                 jeq    vsetfont1
828                               
829   >09F4                   vsetfont0:
830   >09F4=>06A0 >043C           bl      @gwaddr
832   >09F8=>C020 >F78A           mov     @vpatts, 0
833   >09FC=>A020 >FF70           a       @vtextpage, 0
834   >0A00=>06A0 >166C           bl      @vsetbank
835   >0A04=>06A0 >044A           bl      @vwaddr
837   >0A08=>0202 >0800           li      2,>800
838   >0A0C                   vgf1 movb   @GPLRD,@VDPWD
      >0A0C=>D820 >FF90 >FF88 
839   >0A12=>0602                 dec     2
840   >0A14=>15FB                 jgt     vgf1
842   >0A16=>1019                 jmp     vsetfont2
844   >0A18                   vsetfont1:    
845                               ; reset the maximum vwidth/vheight
846   >0A18=>04C0                 clr    0
847   >0A1A=>C060 >F7CE           mov    @vscrnx, 1
848   >0A1E=>D0A0 >F7A2           movb   @vbsize, 2
849   >0A22=>0982                 srl    2, 8
850   >0A24=>3C02                 div    2, 0
851   >0A26=>C800 >F7B4           mov    0, @vwidth
853   >0A2A=>04C0                 clr    0
854   >0A2C=>C060 >F7D0           mov    @vscrny, 1
855   >0A30=>D0A0 >F7A3           movb   @vbsize+1, 2
856   >0A34=>0982                 srl    2, 8
857   >0A36=>3C02                 div    2, 0
858                               
859                               ; add extra row if we can see at least half the character (slack for 212-line modes)
860   >0A38=>A041                 a      1, 1
861   >0A3A=>8081                 c      1, 2
862   >0A3C=>1A01                 jl     vsetfont1b
863   >0A3E=>0580                 inc    0
864   >0A40                   vsetfont1b    
865   >0A40=>06C0                 swpb   0
866   >0A42=>D800 >F7B3           movb   0, @vheight
867                               
868   >0A46=>06A0 >191A           bl      @treset
870   >0A4A                   vsetfont2:    
871                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0A4A=>C2FA                     mov *SP+,  11
*** video.i
872   >0A4C=>045B                 rt
874                               
883   >0A4E                   vcursoroff
884   >0A4E=>9820 >F7AA >0019 	cb	   @vcurs,#00
885   >0A54=>1306             	jeq	   vcursisoff
886   >0A56=>064A             	dect   SP
887   >0A58=>C680             	mov	   0,*SP
888                           	;movb   #>80,@vcurs		; force an "off" next time
889   >0A5A=>C020 >F7A8       	mov	   @vcursor,0
890   >0A5E=>0410             	blwp   *0
891   >0A60=>C03A             	mov	   *SP+,0
892   >0A62                   vcursisoff	rt
      >0A62=>045B             
899                            Vector pixel, vidws
*** <expansion of vector>
1     >0A64                   pixel  data vidws, pixel_entry
      >0A64=>FC60 >0A68       
2     >0A68                   pixel_entry:    
*** video.i
900   >0A68=>0300 >0000           limi    0
901   >0A6C=>020A >F740           li      SP,vstack + vstacksize
903   >0A70=>C32D >0018           mov     @24(13), 12
904                               
905   >0A74=>9820 >0014 >F7CD     cb      #M_bit4,@vidmode
906   >0A7A=>130D                 jeq     vbpcont4
907                               
908   >0A7C=>9820 >0018 >F7CD     cb      #M_bit,@vidmode
909   >0A82=>1301                 jeq     vbpcont
911   >0A84=>0380                 rtwp
913   >0A86                   vbpcont:
914   >0A86=>C0AC >0002           mov     @2(12), 2
915   >0A8A=>C06C >0004           mov     @4(12), 1
916   >0A8E=>C31C                 mov     *12, 12
917                               
918   >0A90=>06A0 >115E           bl      @vbl_drawpixel
920   >0A94=>0380                 rtwp
922   >0A96                   vbpcont4:
923   >0A96=>06A0 >1582           bl      @vcmdsetup
924   >0A9A=>0024                 data    >24             ; -> DX
925                               
926   >0A9C=>C02C >0004           mov     @4(12), 0
927   >0AA0=>06A0 >1578           bl      @vcoordsend
928   >0AA4=>C02C >0002           mov     @2(12), 0
929   >0AA8=>06A0 >1578           bl      @vcoordsend
930                               
931   >0AAC=>06A0 >048A           bl      @vwregnext
932   >0AB0=>112C                 data    >112c        ; -> CLR
933   >0AB2=>D52C >0001           movb    @1(12), *4     ; CLR
935   >0AB6=>D520 >0019           movb    #00, *4         ; ARG 
937   >0ABA=>0209 >5000           li      9, >5000        ; PSET
938   >0ABE=>5720 >024B           szcb    #>f0, *12
939   >0AC2=>F25C                 socb    *12, 9           ; OP
940   >0AC4=>06A0 >161E           bl      @vbit4xsetupMMMcommand
941                               
942   >0AC8=>0380                 rtwp
943                               
948                            Vector fillrect, vidws
*** <expansion of vector>
1     >0ACA                   fillrect  data vidws, fillrect_entry
      >0ACA=>FC60 >0ACE       
2     >0ACE                   fillrect_entry:    
*** video.i
949   >0ACE=>0300 >0000           limi    0
950   >0AD2=>020A >F740           li      SP,vstack + vstacksize
952   >0AD6=>C2AD >0018           mov     @24(13), 10
953                               
954   >0ADA=>9820 >F7CD >0014     cb      @vidmode, #M_bit4
955   >0AE0=>131B                 jeq     fr4x
956                               
957   >0AE2=>9820 >F7CD >0018     cb      @vidmode, #M_bit
958   >0AE8=>162C                 jne     frout
960   >0AEA=>C0AA >0006           mov     @6(10), 2       ; Y
961   >0AEE=>C06A >0008           mov     @8(10), 1       ; X
962   >0AF2=>06A0 >1124           bl      @vbl_getaddr    ; R0= addr, R1=shift
963                               
964   >0AF6=>C22A >0002           mov     @2(10), 8       ; H
965   >0AFA=>C0AA >0004           mov     @4(10), 2       ; W
966                               
967                               ; only fg honored, not op
968   >0AFE=>C31A                 mov     *10, 12         ; op|c 
969   >0B00=>0ACC                 sla     12, 12
970   >0B02=>F320 >F7BF           socb    @vfgbg+1, 12
971                               
972   >0B06=>06CC                 swpb    12
973   >0B08=>D320 >045D           movb    #>FF,12
975   >0B0C=>C100                 mov     0,4
976   >0B0E=>0241 >0007           andi    1,7
978   >0B12=>06A0 >1362           bl      @vbitfillrect
979   >0B16=>0380                 rtwp
980                               
981   >0B18                   fr4x:
982   >0B18=>06A0 >1582           bl      @vcmdsetup
983   >0B1C=>0024                 data    >24
984                               
985   >0B1E=>C04A                 mov     10, 1
986   >0B20=>05C1                 inct    1               ; skip color
987   >0B22=>0611                 dec     *1              ; convert end-coord relative offset to real width/height
988   >0B24=>0621 >0002           dec     @2(1)           ; ... again
989   >0B28=>04C2                 clr     2
990   >0B2A=>06A0 >1730           bl      @vbitsetupDXDYNXNYsigned
992   >0B2E=>D52A >0001           movb    @1(10), *4      ; CLR
994   >0B32=>D502                 movb    2, *4           ; ARG (dix=0, diy=0, mxc=0)
996   >0B34=>0209 >8000           li      9, >8000        ; LMMV
997   >0B38=>56A0 >024B           szcb    #>f0, *10
998   >0B3C=>F25A                 socb    *10, 9          ; OP
999   >0B3E=>06A0 >161E           bl      @vbit4xsetupMMMcommand
1000                              
1001  >0B42                   frout:    
1002  >0B42=>0380                 rtwp
1009                           Vector line, vidws
*** <expansion of vector>
1     >0B44                   line  data vidws, line_entry
      >0B44=>FC60 >0B48       
2     >0B48                   line_entry:    
*** video.i
1010  >0B48=>0300 >0000           limi    0
1011  >0B4C=>020A >F740           li      SP,vstack + vstacksize
1013  >0B50=>C32D >0018           mov     @24(13), 12
1014                              
1015  >0B54=>9820 >F7CD >0014     cb     @vidmode, #M_bit4
1016  >0B5A=>1306                 jeq     ln4x
1017                              
1018  >0B5C=>9820 >F7CD >0018     cb     @vidmode, #M_bit
1019  >0B62=>161A                 jne     lnout
1020                              
1021  >0B64=>0460 >0FE6           b       @vbitline
1022                              
1023  >0B68                   ln4x:
1024  >0B68=>06A0 >1582           bl      @vcmdsetup
1025  >0B6C=>0024                 data    >24
1026                              
1027  >0B6E=>C04C                 mov     12, 1
1028  >0B70=>05C1                 inct    1       ; skip color
1029  >0B72=>0202 >8000           li      2, >8000    ; LINE mode
1030                              
1031                              ; convert X2,Y2 to X2-X1, Y2-Y1
1032  >0B76=>6461 >0004           s       @4(1), *1
1033  >0B7A=>6861 >0006 >0002     s       @6(1), @2(1)
1034  >0B80=>06A0 >1730           bl      @vbitsetupDXDYNXNYsigned
1036  >0B84=>D52C >0001           movb    @1(12), *4     ; CLR
1038  >0B88=>D502                 movb    2, *4           ; ARG (dix=0, diy=0, mxc=0)
1040  >0B8A=>0209 >7000           li      9, >7000        ; LINE
1041  >0B8E=>5720 >024B           szcb    #>f0, *12
1042  >0B92=>F25C                 socb    *12, 9          ; OP
1043  >0B94=>06A0 >161E           bl      @vbit4xsetupMMMcommand
1044                              
1045  >0B98                   lnout:    
1046  >0B98=>0380                 rtwp
1065                           Vector  vspritemotion, vidws
*** <expansion of vector>
1     >0B9A                   vspritemotion  data vidws, vspritemotion_entry
      >0B9A=>FC60 >0B9E       
2     >0B9E                   vspritemotion_entry:    
*** video.i
1066  >0B9E=>020A >F740           li     SP,vstack + vstacksize 
1068  >0BA2=>D160 >FF66           movb    @nsprmot, 5
1069  >0BA6=>1601                 jne     $1+
1070                              
1071  >0BA8=>0380                 rtwp
1073  >0BAA                   $1:    
1074  >0BAA=>0985                 srl     5, 8
1075                              
1076  >0BAC=>C020 >F798           mov     @vsprmot, 0
1077  >0BB0=>C180                 mov     0, 6
1078  >0BB2=>61A0 >F792           s       @vsprites, 6    ; R6 = delta to sprites
1079                              
1080  >0BB6=>06A0 >166C           bl      @vsetbank
1081                              
1082  >0BBA=>C100                 mov     0, 4
1083                              
1084  >0BBC=>020C >FF80           li      12, VDPRD
1085  >0BC0=>0209 >FF8A           li      9, VDPWA
1086  >0BC4=>0208 >D000           li      8, >D000        ; boundary Y coord
1087                              
1088  >0BC8=>C020 >F7B6           mov     @vbit4stride, 0
1089  >0BCC=>1302                 jeq     vsm_loop
1090                              
1091  >0BCE=>0208 >D800           li      8, >D800        ; ... for V9938 modes
1092                              
1093  >0BD2                   vsm_loop:
1094  >0BD2=>D660 >FC69           movb    @vidws+9, *9
1095  >0BD6=>D644                 movb    4, *9       ; get sprite motion entry
1096                              
1097  >0BD8=>D05C                 movb    *12, 1      ; Y-motion
1098  >0BDA=>06C1                 swpb    1
1099  >0BDC=>D05C                 movb    *12, 1      ; X-motion
1100                              
1101  >0BDE=>C041                 mov     1, 1        ; any motion?
1102  >0BE0=>1330                 jeq     vsm_next
1103                              
1104  >0BE2=>D0DC                 movb    *12, 3      ; Y-frac
1105  >0BE4=>D09C                 movb    *12, 2      ; X-frac
1107  >0BE6=>C004                 mov     4, 0
1108  >0BE8=>6006                 s       6, 0
1109  >0BEA=>D660 >FC61           movb    @vidws+1, *9
1110  >0BEE=>D640                 movb    0, *9       ; get sprite coords
1111                              
1112  >0BF0=>06C3                 swpb    3
1113  >0BF2=>D0DC                 movb    *12, 3      ; Y|y
1114  >0BF4=>06C2                 swpb    2
1115  >0BF6=>D09C                 movb    *12, 2      ; X|x
1116                              
1117                              ; R2 = X|x coord, R3 = Y|y coord, R1 = x|y motion
1118                              
1119  >0BF8=>D1C1                 movb    1, 7
1120  >0BFA=>0887                 sra     7, 8        ; sign extend
1121  >0BFC=>0A47                 sla     7, 4        ; 1/16 pixel per 1/60 second        
1122  >0BFE=>A087                 a       7, 2        ; add motion for X
1124  >0C00=>06C1                 swpb    1
1125  >0C02=>0881                 sra     1, 8        ; sign extend
1126  >0C04=>0A41                 sla     1, 4        ; 1/16 pixel per 1/60 second        
1127  >0C06=>A0C1                 a       1, 3        ; add motion for Y
1128                              
1129                              ; Check for Y coordinate in bad range.
1130                              ;
1131                              ; The original idea was:
1132                              ;
1133                              ;   If we moved down to $D0 (or more), then bump by $10.
1134                              ;   If we moved up to $DF (or less), then bump by -$10.
1135                              ;   
1136                              ; We need to apply consistent movement, though, so we
1137                              ; can't just notice when a sprite happens to be in the
1138                              ; range -- we may have a kind of movement that sometimes
1139                              ; hits this range and sometimes doesn't.  Moving a whole 16
1140                              ; pixels in some cases and not others would be too noticeable.
1141                              ;
1142                              ; Instead, just check for the same coordinate and 
1143                              ; bump one pixel in the intended direction.
1144                              ;
1145                              ; TODO: further tweaks with the fraction
1146                              
1147  >0C08=>90C8                 cb      8, 3     
1148  >0C0A=>1607                 jne     $2+         ; at delete coordinate? 
1149                              
1150  >0C0C=>C041                 mov     1, 1        ; which direction?
1151  >0C0E=>1103                 jlt     $1+
1152                              
1153  >0C10=>B0E0 >01B9           ab      #>1, 3      ; moved down, go further 
1154  >0C14=>1002                 jmp     $2+
1155                              
1156  >0C16                   $1:
1157  >0C16=>70E0 >01B9           sb      #>1, 3      ; moved up, go further
1158                              
1159  >0C1A                   $2:
1160  >0C1A=>0260 >4000           ori     0, >4000
1161  >0C1E=>D660 >FC61           movb    @vidws+1, *9
1162  >0C22=>D640                 movb    0, *9       ; update sprite coord 
1163                              
1164  >0C24=>DA43 >FFFE           movb    3, @-2(9)
1165  >0C28=>DA42 >FFFE           movb    2, @-2(9)
1166                              
1167  >0C2C=>A006                 a       6, 0
1168  >0C2E=>05C0                 inct    0
1169  >0C30=>D660 >FC61           movb    @vidws+1, *9
1170  >0C34=>D640                 movb    0, *9        ; update motion fractions
1171                              
1172  >0C36=>06C3                 swpb    3
1173  >0C38=>DA43 >FFFE           movb    3, @-2(9)
1174  >0C3C=>06C2                 swpb    2
1175  >0C3E=>DA42 >FFFE           movb    2, @-2(9)
1176                              
1177  >0C42                   vsm_next:
1178  >0C42=>0224 >0004           ai      4, 4
1179  >0C46=>0605                 dec     5
1180  >0C48=>15C4                 jgt     vsm_loop
1182  >0C4A=>0380                 rtwp
1183                              
*** nforth.tsm
504                           	incl	video_text.i
*** video_text.i
21                              
22    >0C4C                   vtextsetup
23                                PUSH    SP,11
*** <expansion of push>
1     >0C4C=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0C4E=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_text.i
24    >0C50=>0201 >050C           li      1,vtxt
25    >0C54=>D820 >0019 >F7CD     movb    #M_text,@vidmode
26    >0C5A=>06A0 >0960           bl      @vstdmode
27    >0C5E                   vtextsetup0:
28    >0C5E=>06A0 >075C       	bl	    @vsetupregs
29    >0C62=>06A0 >0790       	bl	    @vsetupaddrs
30    >0C66=>C801 >F7C8       	mov    1,@vtermptr
31                                
32                            	POP    SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0C6A=>C2FA                     mov *SP+,  11
*** video_text.i
33    >0C6C=>045B             	rt
34                            	
35    >0C6E                   vtext2setup
36                                PUSH    SP,11
*** <expansion of push>
1     >0C6E=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0C70=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_text.i
37    >0C72=>06A0 >14A8           bl      @venhmode
38    >0C76=>D820 >021C >F7CD     movb    #M_text2,@vidmode
39                                
40                                ; set inverted bg/fg for blink color
41    >0C7C=>04C0                 clr     0
42    >0C7E=>D020 >F7BE           movb    @vfgbg,0
43    >0C82=>06C0                 swpb    0
44    >0C84=>D020 >F7BE           movb    @vfgbg,0
45    >0C88=>0B05                 src     5, 0
46    >0C8A=>D020 >049B           movb    #>C,0
47    >0C8E=>06A0 >0460           bl      @vwreg
48                                
49    >0C92=>0201 >069A           li      1,vtxt2
50    >0C96=>10E3                 jmp     vtextsetup0
53    >0C98                   vgraphsetup
54    >0C98=>D820 >01B9 >F7CD     movb    #M_graph,@vidmode
55    >0C9E=>0201 >0536       	li	1,vgfx
56    >0CA2                   vgraphsetup0:	
57                                PUSH    SP,11
*** <expansion of push>
1     >0CA2=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0CA4=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_text.i
58    >0CA6=>06A0 >075C       	bl	@vsetupregs
59    >0CAA=>06A0 >0790       	bl	@vsetupaddrs
60    >0CAE=>C801 >F7C8       	mov 1,@vtermptr
61                                ;bl  @vtermsetup
62    >0CB2=>06A0 >0960           bl  @vstdmode
63                                POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0CB6=>C2FA                     mov *SP+,  11
*** video_text.i
64    >0CB8=>045B             	rt
66    >0CBA                   vmultisetup
67    >0CBA=>D820 >0078 >F7CD     movb    #M_multi,@vidmode
68    >0CC0=>0201 >06FA           li  1,vmulti
69    >0CC4=>10EE                 jmp vgraphsetup0
70                                
80    >0CC6                   vtextaddr PUSH SP, 2
*** <expansion of push>
1     >0CC6=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0CC8=>C682                     mov  2, @(1-0-1)*2(SP)
*** video_text.i
81                                
82    >0CCA=>C080                 mov     0,2              ; save X
83    >0CCC=>06C0                 swpb    0
85    >0CCE=>B020 >F7C3           ab      @vwy,0
86    >0CD2=>0980                 srl     0,8
87    >0CD4=>3820 >F7B4           mpy     @vwidth,0        ; get row offset in R1
88                                
89    >0CD8=>D002                 movb    2,0
90    >0CDA=>B020 >F7C2           ab      @vwx,0
91    >0CDE=>0980                 srl     0,8              ; get column offset
93    >0CE0=>A001                 a       1,0                ; column+row
94    >0CE2=>A020 >F786           a       @vscreen,0         ; R0=addr
95    >0CE6=>A020 >FF70           a       @vtextpage,0
97                                POP     SP, 2
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0CEA=>C0BA                     mov *SP+,  2
*** video_text.i
98    >0CEC=>045B                 rt
110   >0CEE                   vgraphaddr PUSH SP, 2
*** <expansion of push>
1     >0CEE=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0CF0=>C682                     mov  2, @(1-0-1)*2(SP)
*** video_text.i
111   >0CF2=>C080                 mov     0,2             ; save X
112   >0CF4=>06C0                 swpb    0
114   >0CF6=>B020 >F7C3           ab      @vwy,0
115   >0CFA=>0980                 srl     0,8
116   >0CFC=>0A50                 sla     0,5
118   >0CFE=>D042                 movb    2,1
119   >0D00=>B060 >F7C2           ab      @vwx,1
120   >0D04=>0981                 srl     1,8                 ; get column offset
122   >0D06=>A001                 a       1,0             ; column+row
123   >0D08=>A020 >F786           a       @vscreen,0          ; R0=addr
125                               POP     SP, 2
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0D0C=>C0BA                     mov *SP+,  2
*** video_text.i
126   >0D0E=>045B                 rt
136   >0D10                   vtextclearline
137                               PUSH    SP,0,3,11
*** <expansion of push>
1     >0D10=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0D14=>CA80 >0004               mov  0 , @(3-0-1)*2(SP)
2     >0D18=>CA83 >0002               mov  3 , @(3-1-1)*2(SP)
3     >0D1C=>C68B                     mov  11, @(3-2-1)*2(SP)
*** video_text.i
139   >0D1E=>C0E0 >F7A4           mov     @vcoordaddr,3
140   >0D22=>0693                 bl      *3
141   >0D24=>06A0 >166C           bl      @vsetbank
142   >0D28=>0201 >2000           li      1,>2000
143                               ;movb    @vwxs, 2
144                               ;srl     2,8 
145   >0D2C=>06A0 >04BC           bl      @vclr               ; clear out line
146                               
147   >0D30=>9820 >021C >F7CD     cb      #M_text2, @vidmode
148   >0D36=>160A                 jne     vtextclearlineout
149                               
150                               ; clear blinks
151   >0D38=>04C1                 clr     1
152   >0D3A=>D0E0 >FF6D           movb    @vblinkflag, 3
153   >0D3E=>1301                 jeq     vtextclearline0
154   >0D40=>0701                 seto    1    
155   >0D42                   vtextclearline0:
156   >0D42=>0932                 srl     2, 3                ; NOTE: only works on 8-char aligned windows
157   >0D44=>06A0 >0DAE           bl      @vtxt2blink
158   >0D48=>06A0 >04BC           bl      @vclr               ; set blink 
160   >0D4C                   vtextclearlineout:         
161                               POP     SP,0,3,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0D4C=>C2FA                     mov *SP+,  11
2     >0D4E=>C0FA                     mov *SP+,  3 
3     >0D50=>C03A                     mov *SP+,  0 
*** video_text.i
162   >0D52=>045B                 rt
178                            Vector vtextchar, vidws
*** <expansion of vector>
1     >0D54                   vtextchar  data vidws, vtextchar_entry
      >0D54=>FC60 >0D58       
2     >0D58                   vtextchar_entry:    
*** video_text.i
179   >0D58=>0300 >0000       	limi   0
180   >0D5C=>020A >F740       	li	   SP,vstack + vstacksize
182   >0D60=>C020 >F7CA       	mov	   @vx,0
183   >0D64=>C060 >F7A4       	mov	   @vcoordaddr,1
184   >0D68=>0691             	bl	   *1				; get address
185                               
186   >0D6A=>06A0 >166C           bl     @vsetbank            ; set bank / page
187   >0D6E=>06A0 >044A       	bl	   @vwaddr				; set VDP addr
188   >0D72=>D820 >F7C0 >FF88 	movb   @vch,@VDPWD			; draw
190   >0D78=>9820 >021C >F7CD     cb     #M_text2, @vidmode	
191   >0D7E=>1301             	jeq    vtextchar0
192   >0D80=>0380             	rtwp
193                           	
194   >0D82                   vtextchar0:
195                               ; set blink flag
196   >0D82=>06A0 >0DAE           bl     @vtxt2blink
197   >0D86=>06A0 >044E       	bl     @vraddr
198   >0D8A=>D0A0 >FF80       	movb   @VDPRD, 2
199   >0D8E=>06A0 >044A       	bl     @vwaddr
200   >0D92=>0201 >8000       	li     1, >8000
201   >0D96=>0240 >0007           andi   0, 7
202   >0D9A=>1301                 jeq    vtextchar1
203   >0D9C=>0901             	srl    1, 0
204   >0D9E                   vtextchar1:	
205   >0D9E=>5081             	szcb   1, 2
206   >0DA0=>D020 >FF6D       	movb   @vblinkflag, 0     
207   >0DA4=>1301             	jeq    vtextchar2
208   >0DA6=>F081             	socb   1, 2
209   >0DA8                   vtextchar2:	   
210   >0DA8=>D802 >FF88           movb   2, @VDPWD
211   >0DAC=>0380             	rtwp
213   >0DAE                   vtxt2blink
214   >0DAE=>6020 >F786           s      @vscreen, 0
215   >0DB2=>0930                 srl    0, 3
216   >0DB4=>0240 >01FF           andi   0, >1ff
217   >0DB8=>A020 >FF70           a       @vtextpage, 0
218   >0DBC=>A020 >F78E           a      @vcolors, 0
219   >0DC0=>0240 >3FFF           andi   0, >3fff
220   >0DC4=>045B                 rt
229                             Vector vtextcursor, vidws
*** <expansion of vector>
1     >0DC6                   vtextcursor  data vidws, vtextcursor_entry
      >0DC6=>FC60 >0DCA       
2     >0DCA                   vtextcursor_entry:    
*** video_text.i
230   >0DCA=>0300 >0000       	limi	0
231   >0DCE=>020A >F740       	li	    SP,vstack+  vstacksize
233   >0DD2=>C020 >F7CA       	mov	   @vx,0
234   >0DD6=>C060 >F7A4       	mov	   @vcoordaddr,1
235   >0DDA=>0691             	bl	    *1
236                           	
237   >0DDC=>06A0 >166C       	bl     @vsetbank
238   >0DE0=>B820 >005F >F7AA 	ab	    #>80,@vcurs
239   >0DE6=>130B             	jeq	   vtcoff
241   >0DE8=>06A0 >044E       	bl	    @vraddr			; read char under cursor
242   >0DEC=>D820 >FF80 >F7AB 	movb	@VDPRD,@vcursunder
244   >0DF2=>06A0 >044A       	bl	    @vwaddr
245   >0DF6=>D820 >F7C1 >FF88 	movb	@vcurschar,@VDPWD		; draw cursor
247   >0DFC=>1005             	jmp	vtcout
249   >0DFE                   vtcoff:
250   >0DFE=>06A0 >044A       	bl	    @vwaddr
251   >0E02=>D820 >F7AB >FF88 	movb	@vcursunder,@VDPWD		; restore char under cursor
253   >0E08                   vtcout:
254   >0E08=>0380             	rtwp
257   >0E0A                   vnopchar:
258   >0E0A                   vnopclearline:
259   >0E0A                   vnopcursor:
260   >0E0A=>FC60 >0E08           data vidws, vtcout
*** nforth.tsm
505                           	incl	video_bit.i
*** video_bit.i
23    >0E0E                   vbitmapsetup
24    >0E0E=>D820 >0019 >F7CC 	movb	#00,@vmono
25    >0E14=>0201 >0566       	li 	   1, vbit
26    >0E18                   vbitsentr:
27                                PUSH    SP,11
*** <expansion of push>
1     >0E18=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0E1A=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit.i
28    >0E1C=>D820 >0018 >F7CD     movb    #M_bit,@vidmode
30    >0E22=>06A0 >075C       	bl	    @vsetupregs
31    >0E26=>06A0 >0790       	bl	    @vsetupaddrs
32    >0E2A=>C801 >F7C8       	mov    1,@vtermptr
33    >0E2E=>06A0 >0960           bl      @vstdmode
34                                
35                                POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0E32=>C2FA                     mov *SP+,  11
*** video_bit.i
36    >0E34=>045B             	rt
38    >0E36                   vmonosetup
39    >0E36=>D820 >01B9 >F7CC 	movb	#1,@vmono
40    >0E3C=>0201 >06CA       	li     1, vmonobit
41    >0E40=>10EB             	jmp	   vbitsentr
43    >0E42                   vbitmap3setup
44    >0E42=>0201 >0596           li      1, vbit3
45    >0E46=>10E8                 jmp     vbitsentr
55    >0E48                   vbitpixeladdr
56    >0E48=>C040                 mov    0,1
57    >0E4A=>0A50                 sla    0,5              ; R0=Y offset (row8) ++
58    >0E4C=>E001                 soc    1,0              ; R0=Y offset (row) ++
59    >0E4E=>0240 >FF07           andi   0,>ff07          ; R0=complete Y offset
61    >0E52=>C042                 mov    2,1              ; copy of X
62    >0E54=>0241 >0007           andi   1,7              ; complete X bit offs
63    >0E58=>A002                 a      2,0              ; Y-X offset ++
64    >0E5A=>6001                 s      1,0              ; complete Y-X offset
65    >0E5C=>045B                 rt
66                                
77    >0E5E                   vbitaddr 
78                                PUSH    SP,2,11
*** <expansion of push>
1     >0E5E=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0E62=>CA82 >0002               mov  2 , @(2-0-1)*2(SP)
2     >0E66=>C68B                     mov  11, @(2-1-1)*2(SP)
*** video_bit.i
80    >0E68=>A020 >F7C2           a       @vwx, 0
81                                
82                                ; scale by vbsize
83    >0E6C=>04C1                 clr     1
84    >0E6E=>D060 >F7A2           movb    @vbsize,1       ; X size (hi)
85    >0E72=>04C2                 clr     2
86    >0E74=>D080                 movb    0,2             ; X (hi)
87    >0E76=>3881                 mpy     1,2             ; R2=col #  (3 = 0)
88                                
89    >0E78=>0A80                 sla     0,8             ; Y
90    >0E7A=>D0E0 >F7A3           movb    @vbsize+1,3
91    >0E7E=>38C0                 mpy     0,3             ; 3=row#
92                                
93    >0E80=>C003                 mov     3,0
94    >0E82=>7000                 sb      0,0             ; R0=Y
96    >0E84=>06A0 >0E48           bl      @vbitpixeladdr
97                                
98                                POP     SP,2,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0E88=>C2FA                     mov *SP+,  11
2     >0E8A=>C0BA                     mov *SP+,  2 
*** video_bit.i
99    >0E8C=>045B                 rt
109   >0E8E                   vbitclearline
110                               PUSH    SP,0,3,11
*** <expansion of push>
1     >0E8E=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0E92=>CA80 >0004               mov  0 , @(3-0-1)*2(SP)
2     >0E96=>CA83 >0002               mov  3 , @(3-1-1)*2(SP)
3     >0E9A=>C68B                     mov  11, @(3-2-1)*2(SP)
*** video_bit.i
112                               ; get start address and shift in R0/R1
113   >0E9C=>C0E0 >F7A4           mov     @vcoordaddr,3
114   >0EA0=>0693                 bl      *3
115   >0EA2=>C100                 mov     0,4
117                               ; scale width by vbsize
118   >0EA4=>C201                 mov     1,8
119                               
120   >0EA6=>04C1                 clr     1
121   >0EA8=>D060 >F7A2           movb    @vbsize,1       ; X size (hi)
122                               ;clr     2
123                               ;movb    @vwxs,2         ; X (hi)
124   >0EAC=>0A82                 sla     2,8
125   >0EAE=>3881                 mpy     1,2             ; 2=col #  (3 = 0)
126                               
127   >0EB0=>C048                 mov     8,1
128                               
129                               ; height is vbsize
130   >0EB2=>D220 >F7A3           movb    @vbsize+1,8
131   >0EB6=>0988                 srl     8,8      
133   >0EB8=>06A0 >038E           bl      @vgetcolorbyte
134   >0EBC=>D300                 movb    0,12
135   >0EBE=>098C                 srl     12,8
136                               
137   >0EC0=>06A0 >1362           bl      @vbitfillrect
139                               POP     SP,0,3,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0EC4=>C2FA                     mov *SP+,  11
2     >0EC6=>C0FA                     mov *SP+,  3 
3     >0EC8=>C03A                     mov *SP+,  0 
*** video_bit.i
140   >0ECA=>045B                 rt
151   >0ECC                   vfetchfontchar
152                               PUSH    SP,11,0
*** <expansion of push>
1     >0ECC=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0ED0=>CA8B >0002               mov  11 , @(2-0-1)*2(SP)
2     >0ED4=>C680                     mov  0, @(2-1-1)*2(SP)
*** video_bit.i
153   >0ED6=>D020 >F7C0           movb    @vch,0
154   >0EDA=>0980                 srl     0,8
155   >0EDC=>0A30                 sla     0,3
156   >0EDE=>A020 >F7BC           a       @vfont,0
157   >0EE2=>06A0 >043C           bl      @gwaddr             ; set GROM addr
158                               
159   >0EE6=>D2E0 >F7A3           movb    @vbsize+1,11
160   >0EEA=>098B                 srl     11,8
161                               
162   >0EEC=>C04A                 mov     SP, 1
163   >0EEE=>604B                 s       11, 1               ; get space on stack for char
164   >0EF0=>C001                 mov     1, 0
165   >0EF2                   $1:
166   >0EF2=>DC20 >FF90           movb    @GPLRD, *0+
167   >0EF6=>DC20 >FF90           movb    @GPLRD, *0+
168   >0EFA=>064B                 dect    11
169   >0EFC=>15FA                 jgt     $1-
170                                    
171                               POP     SP,11,0
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >0EFE=>C03A                     mov *SP+,  0
2     >0F00=>C2FA                     mov *SP+,  11 
*** video_bit.i
172   >0F02=>045B                 rt
182                            Vector vbitchar, vidws
*** <expansion of vector>
1     >0F04                   vbitchar  data vidws, vbitchar_entry
      >0F04=>FC60 >0F08       
2     >0F08                   vbitchar_entry:    
*** video_bit.i
183   >0F08=>0300 >0000       	limi	0
184   >0F0C=>020A >F740       	li		SP,vstack + vstacksize
186   >0F10=>8820 >F7A2 >2890 	c       @vbsize,#>0808
187   >0F16=>1302             	jeq		vbitfast
188   >0F18=>0460 >11DC       	b		@vbitcharsmall+4
190   >0F1C                   vbitfast:
191   >0F1C=>C020 >F7CA           mov     @vx,0
192   >0F20=>C060 >F7A4       	mov		@vcoordaddr,1
193   >0F24=>0691             	bl		*1				; get address in 0, shift in 1
195   >0F26=>C100             	mov		0,4              
196                           	
197   >0F28=>06A0 >0ECC       	bl      @vfetchfontchar
198                           	
199   >0F2C=>A020 >F78A       	a		@vpatts,0
200   >0F30=>06A0 >044A       	bl		@vwaddr				; set VDP addr for patt
202   >0F34=>0203 >FF88       	li		3,VDPWD
203   >0F38=>0202 >0008           li      2, 8
204   >0F3C                   $1: movb    *1+,*3
      >0F3C=>D4F1             
205   >0F3E=>0602                 dec     2
206   >0F40=>15FD                 jgt     $1-
207                           	
208   >0F42=>D820 >F7CC >F7CC 	movb	@vmono,@vmono
209   >0F48=>160D             	jne		vbcnocol
211   >0F4A=>C004             	mov		4,0
212   >0F4C=>A020 >F78E       	a		@vcolors,0			; draw color
213   >0F50=>06A0 >044A       	bl		@vwaddr
215   >0F54=>06A0 >038E           bl      @vgetcolorbyte
216   >0F58=>D040                 movb    0,1
218   >0F5A=>0202 >0008           li      2, 8
219   >0F5E                   $1: movb    1,*3
      >0F5E=>D4C1             
220   >0F60=>0602                 dec     2
221   >0F62=>15FD                 jgt     $1-    
223   >0F64                   vbcnocol:
224   >0F64=>0380             	rtwp
227   >0F66                   vbitcursorset
228   >0F66=>C28B                 mov     11,10 
229   >0F68=>06A0 >044E           bl     @vraddr
230   >0F6C=>D060 >FF80           movb   @VDPRD, 1
231   >0F70=>DD81                 movb    1,*6+
232   >0F72=>F043                 socb   3,1
233   >0F74=>045A                 b       *10
234                               
235   >0F76                   vbitcursorreset 
236   >0F76=>D076                 movb *6+,1
237   >0F78=>045B                 rt
238                            
242                            Vector vbitcursor, vidws
*** <expansion of vector>
1     >0F7A                   vbitcursor  data vidws, vbitcursor_entry
      >0F7A=>FC60 >0F7E       
2     >0F7E                   vbitcursor_entry:    
*** video_bit.i
244   >0F7E=>0300 >0000       	limi   0
245   >0F82=>020A >F740       	li	   SP,vstack + vstacksize
247   >0F86=>C020 >F7CA       	mov    @vx,0
248   >0F8A=>C060 >F7A4       	mov	   @vcoordaddr,1
249   >0F8E=>0691             	bl	   *1
250                           	
251   >0F90=>A020 >F78A       	a	   @vpatts,0		; only change patt
252   >0F94=>06A0 >166C           bl     @vsetbank
253   >0F98=>C100             	mov    0,4
254                               
255   >0F9A=>C001                 mov    1,0
256   >0F9C=>0203 >C0C0           li     3,>c0c0
257   >0FA0=>0B03                 src    3,0
258                               
259                               ; based on the cursor mode, we either save + modify or restore the bits under the cursor
260   >0FA2=>0205 >0F66           li      5,vbitcursorset
261   >0FA6=>B820 >005F >F7AA     ab      #>80,@vcurs
262   >0FAC=>1602                 jne     vbc1
263   >0FAE=>0205 >0F76           li      5,vbitcursorreset
264   >0FB2                   vbc1:    
265   >0FB2=>0206 >F7AB           li     6,vcursunder
266   >0FB6=>D0A0 >F7A3           movb   @vbsize+1, 2
267   >0FBA=>0982                 srl    2,8
268                               
269   >0FBC=>0207 >0007           li      7, 7
270   >0FC0=>020C >0001           li      12, 1
271   >0FC4                   vbc0:
272   >0FC4=>C004                 mov     4,0
273   >0FC6=>0695                 bl      *5      ; read or write pixel
274   >0FC8=>06A0 >044A           bl      @vwaddr
275   >0FCC=>D801 >FF88           movb    1,@VDPWD
276                               
277   >0FD0=>A10C                 a       12,4    ; next row
278   >0FD2=>2507                 czc     7,4     ; end of block?
279   >0FD4=>1604                 jne     vbc2
280   >0FD6=>0224 >00FF           ai      4,>ff   
281   >0FDA=>0244 >3FF8           andi    4,>3ff8
282   >0FDE                   vbc2:
283   >0FDE=>0602                 dec     2
284   >0FE0=>15F1                 jgt     vbc0
285                               
286   >0FE2=>0380             	rtwp
294   >0FE4                   h14         data 14
      >0FE4=>000E             
296   >0FE6                   vbitline
297                               PUSH   SP, 13, 14
*** <expansion of push>
1     >0FE6=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >0FEA=>CA8D >0002               mov  13 , @(2-0-1)*2(SP)
2     >0FEE=>C68E                     mov  14, @(2-1-1)*2(SP)
*** video_bit.i
298                               
299   >0FF0=>C06C >0008           mov    @8(12), 1   ; X
300   >0FF4=>C0AC >0006           mov    @6(12), 2   ; Y
301   >0FF8=>C0EC >0004           mov    @4(12), 3   ; X2
302   >0FFC=>C12C >0002           mov    @2(12), 4   ; Y2
303                               
304   >1000=>60C1             	s	   1,3          ; X direction = R3-R1
305   >1002=>C1C3             	mov    3,7        
306   >1004=>0747             	abs	   7            ; X distance 
308   >1006=>6102             	s	   2,4          ; Y direction = R4-R2
309   >1008=>C204             	mov    4,8        
310   >100A=>0748             	abs	   8            ; Y distance
312   >100C=>8207             	c	   7,8			; which axis is longer?
313                           						; R6>=0 means Y is longer
314                           						; R6<0  means X is longer
315   >100E=>150A             	jgt	   vbl_x
321   >1010=>020E >1096           li      14, vbl_ymajor
322                               
323   >1014=>C104                 mov     4, 4        ; going up?
324   >1016=>1505                 jgt     $1+
325                              
326   >1018=>A084                 a       4, 2
327   >101A=>0504                 neg     4           ; make it go the other way
328                               
329   >101C=>C06C >0004           mov     @4(12), 1
330   >1020=>0503                 neg     3           ; minor direction swapped too
331                                
332   >1022                   $1:    
333                               
334   >1022=>100C                 jmp     vbl_plotline
335                               
336   >1024                   vbl_x:
341   >1024=>020E >10C6           li      14, vbl_xmajor
343   >1028=>C0C3                 mov     3, 3        ; going up/left?
344   >102A=>1505                 jgt     $1+
345                              
346   >102C=>A043                 a       3, 1        ; make it go the other way
347   >102E=>0503                 neg     3           
348                               
349   >1030=>C0AC >0002           mov     @2(12), 2
350   >1034=>0504                 neg     4           ; minor direction swapped too
351                               
352                                
353   >1036                   $1:    
354                               
355                               ; Swap major and minor
356   >1036=>C2C3                 mov     3, 11
357   >1038=>C0C4                 mov     4, 3
358   >103A=>C10B                 mov     11, 4
359                               
360   >103C                   vbl_plotline:    
361   >103C=>0584                 inc     4
362                               
363   >103E=>C31C                 mov    *12, 12
364                               
365                               ; get op
366   >1040=>06A0 >1148           bl      @vbitgetdrawfuncandcolor
367                               
369   >1044=>06A0 >1124           bl      @vbl_getaddr       ; get start addr (R1, R2) -> (R0, R1)
370   >1048=>A020 >F78A           a       @vpatts, 0
371                               
372   >104C=>06A0 >1106           bl      @vbl_getfracmags
373                               
374                               ; R7=minor increment
375                               ; R6=minor fraction 
376                               ; R3=minor magnitude
378   >1050=>04C2                 clr    2                ; so we have a clean check for COC
379                               
380   >1052=>020D >2420           li     13, >2420        ; CZC <addr>, 0
381   >1056=>C243                 mov    3, 9
382                               
383   >1058=>1502                 jgt    $2+
384   >105A=>020D >2020           li     13, >2020        ; COC <addr>, 0
385   >105E                   $2:    
386   >105E=>028E >1096           ci     14, vbl_ymajor
387   >1062=>1605                 jne    $3+
388                               
389   >1064=>022D >0040           ai     13, >40          ; COC|CZC ..., 1
390   >1068=>A0C3                 a      3, 3             ; X shift change is in increments of 2
391   >106A=>0A39                 sla    9, 3             ; adjust direction for X byte change (8 bytes)
392   >106C=>1004                 jmp    vbl_linepixel
394   >106E                   $3:
395   >106E=>C2C9                 mov    9, 11
396   >1070=>0A3B                 sla    11, 3
397   >1072=>0A89                 sla    9, 8
398   >1074=>624B                 s      11, 9             ; adjust direction for Y block change (256-8)    
399                               
400   >1076                   vbl_linepixel:    
412   >1076=>04C2                 clr     2
413   >1078=>0208 >FF8A           li      8, VDPWA
415   >107C=>06A0 >117E           bl      @vbitreadpixel_
416                                   
417   >1080                   vbl_lineloop:
418   >1080=>0241 >000E           andi   1, >E            ; keep shift in range
419                              ;bl     @vbitdrawpixel_
420                               
421   >1084=>045E                 b      *14              ; next major 
423   >1086                   vbl_lineloopret:    
424   >1086=>0604                 dec    4                ; one pixel consumed
425   >1088=>15FB                 jgt    vbl_lineloop
427   >108A=>06A0 >118A           bl     @vbitwritepixel_
428                                    
429   >108E=>04CF             	clr    15               ; clr out what we did
430                           	POP    SP, 13, 14
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1090=>C3BA                     mov *SP+,  14
2     >1092=>C37A                     mov *SP+,  13 
*** video_bit.i
431   >1094=>0380             	rtwp
436   >1096                   vbl_ymajor:
437   >1096=>0485                  x       5
438   >1098=>11C8                  data    vbl_shifts
439                                
440   >109A=>06A0 >118A            bl     @vbitwritepixel_
441                               
442   >109E=>0580                 inc    0                ; new Y
443   >10A0=>2420 >0B10           czc    #7, 0            ; new block?
444   >10A4=>1604                 jne    $1+              ; nope
446   >10A6=>0220 >00F8           ai     0,256-8          ; next block
447   >10AA=>0240 >1FFF           andi   0, >1fff         ; keep in range
449   >10AE                   $1:    
450   >10AE=>A1C6                 a      6, 7
451   >10B0=>1707                 jnc    $1+              ; new X yet?
452                               
453   >10B2=>A043                 a      3, 1             ; yup, adjust shift
454   >10B4=>048D                 x      13               ; test for going left or right and crossing the byte
455   >10B6=>0FE4                 data   h14
456                               
457   >10B8=>1603                 jne    $1+              ; not yet
458                               
459   >10BA=>C080                 mov    0, 2
460   >10BC=>A009                 a      9, 0             ; move across a row (8 bytes)
461   >10BE=>D002                 movb   2, 0             ; keep in range
462   >10C0                   $1:    
463   >10C0=>06A0 >117E           bl     @vbitreadpixel_
464   >10C4=>10E0                 jmp     vbl_lineloopret
465                               
469   >10C6                   vbl_xmajor: 
470   >10C6=>0485                 x       5
471   >10C8=>11C8                 data    vbl_shifts
472                               
473   >10CA=>05C1                 inct   1                ; adjust shift
474   >10CC=>2460 >0FE4           czc    @h14, 1          ; test for going right and crossing the byte
475                               
476   >10D0=>1607                 jne    $1+              ; not yet
477                               
478   >10D2=>06A0 >118A           bl     @vbitwritepixel_
479                               
480   >10D6=>B820 >0A0A >FC61     ab     #8, @vidws+1     ; move across a row (8 bytes), keeping in range
481                               
482   >10DC=>06A0 >117E           bl     @vbitreadpixel_
483                               
484   >10E0                   $1:
485                               
486   >10E0=>A1C6                 a      6, 7
487   >10E2=>17D1                 jnc    vbl_lineloopret   ; new Y yet?
489   >10E4=>06A0 >118A           bl     @vbitwritepixel_
490                               
491   >10E8=>C080                 mov    0, 2             ; remember original address
492                               
493   >10EA=>A003                 a      3, 0             ; yup
494   >10EC=>048D                 x      13               ; new block?
495   >10EE=>031C                 data   h07
496   >10F0=>1601                 jne    $2+              ; nope
498   >10F2=>A009                 a      9, 0             ; next/previous block
500   >10F4                   $2:    
501   >10F4=>2880                 xor    0, 2             ; check if wrapped
502   >10F6=>1504                 jgt    $3+
503                               
504   >10F8=>0240 >1FFF           andi   0, >1fff         ; keep in range
505   >10FC=>0220 >F800           ai     0, ->800
506   >1100                   $3:
507   >1100=>06A0 >117E           bl     @vbitreadpixel_
508   >1104=>10C0                 jmp    vbl_lineloopret
512   >1106                   vbl_getfracmags:
513   >1106=>C183                 mov     3, 6       
514   >1108=>0746                 abs     6         
515   >110A=>04C7                 clr     7
516   >110C=>3D84                 div     4, 6            ; R6=minor increment
517   >110E=>04C7                 clr     7               ; R7=minor fraction 
518   >1110=>1902                 jno     $1+
519                               
520   >1112=>0706                 seto    6               ; close enough to straight
521   >1114=>0707                 seto    7               ; force immediate carry    
522   >1116                   $1:    
523                               
524                               ; Convert R3 to the magnitude for shift adjust (-2, 0, 2)
526   >1116=>C0C3                 mov     3, 3
527   >1118=>0703                 seto    3
528   >111A=>1103                 jlt     $1+
529   >111C=>04C3                 clr     3
530   >111E=>1301                 jeq     $1+
531   >1120=>0583                 inc     3
532                               
533   >1122                   $1:
534   >1122=>045B                 rt
543   >1124                   vbl_getaddr
544                               PUSH    SP, 2, 11
*** <expansion of push>
1     >1124=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1128=>CA82 >0002               mov  2 , @(2-0-1)*2(SP)
2     >112C=>C68B                     mov  11, @(2-1-1)*2(SP)
*** video_bit.i
546   >112E=>7041             	sb      1,1    				; scale down X
547   >1130=>C2C1                 mov     1, 11
548                               
549   >1132=>04C1                 clr     1
550   >1134=>3C60 >2894           div     #192, 1              ; scale down Y (R2=mod)
551   >1138=>C002                 mov     2, 0
553                               ; R0=Y R2=X
554   >113A=>C08B                 mov     11, 2
555   >113C=>06A0 >0E48           bl     @vbitpixeladdr
556                               
557   >1140=>A041                 a      1,1                ; shift in increments of 2 
558                           	
559                               POP    SP,2,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1142=>C2FA                     mov *SP+,  11
2     >1144=>C0BA                     mov *SP+,  2 
*** video_bit.i
560   >1146=>045B             	rt
569   >1148                   vbitgetdrawfuncandcolor
570                               
571   >1148=>04C5                 clr     5
572   >114A=>D14C                 movb    12, 5
573   >114C=>0245 >0F00           andi    5, >F00 
574   >1150=>0975                 srl     5, 7
575   >1152=>C165 >11B8           mov     @vdrawops(5), 5    ; R5 = pattern operation
577   >1156=>0ACC                 sla     12, 12
578   >1158=>F320 >F7BF           socb    @vfgbg+1, 12 ; R12 = color
579                               
580   >115C=>045B                 rt
581                               
587   >115E                   vbl_drawpixel PUSH SP, 11
*** <expansion of push>
1     >115E=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1160=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit.i
588   >1162=>06A0 >1148           bl     @vbitgetdrawfuncandcolor
590   >1166=>06A0 >1124           bl     @vbl_getaddr
592   >116A=>0208 >FF8A           li     8,VDPWA    
593   >116E=>06A0 >117E           bl     @vbitreadpixel_
594                               
595   >1172=>0485                 x      5
596   >1174=>11C8                 data   vbl_shifts
597                            
598   >1176=>06A0 >118A           bl     @vbitwritepixel_ 
599                               
600                               POP    SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >117A=>C2FA                     mov *SP+,  11
*** video_bit.i
601   >117C=>045B                 rt
608   >117E                   vbitreadpixel_ 
609   >117E=>D620 >FC61           movb   @vidws+1, *8
610   >1182=>D600                 movb   0, *8
611                               
612   >1184=>D0A0 >FF80           movb   @VDPRD, 2            ; get patt byte
613   >1188=>045B                 rt
621   >118A                   vbitwritepixel_ 
622   >118A=>0260 >4000           ori    0, >4000
623   >118E=>D620 >FC61           movb   @vidws+1, *8
624   >1192=>D600                 movb   0, *8
625                               
626   >1194=>D802 >FF88           movb   2, @VDPWD            ; put patt byte
628   >1198=>D820 >F7CC >F7CC     movb   @vmono,@vmono
629   >119E=>1609                 jne    $1+
630                                   
631   >11A0=>2820 >07C8           xor    #>2000, 0            ; pattern -> color table
633   >11A4=>D620 >FC61           movb   @vidws+1, *8
634   >11A8=>D600                 movb   0, *8
635                               
636   >11AA=>D80C >FF88           movb   12, @VDPWD          ; put color byte
637                               
638   >11AE=>2820 >07C8           xor    #>2000, 0            ; pattern -> color table
639   >11B2                   $1:
640   >11B2=>0240 >3FFF           andi   0, >3fff            ; turn off write bit    
641   >11B6=>045B                 rt
642                               
644   >11B8                   vdrawops: 
645   >11B8=>F0A1 >F0A1           dw  >F0A1, >F0A1
646   >11BC=>50A1 >28A1           dw  >50A1, >28A1            ; nop is CB
647   >11C0=>90A1 >90A1 >90A1     dw  >90A1, >90A1, >90A1, >90A1
      >11C6=>90A1             
649   >11C8                   vbl_shifts byte >80,0,>40,0,>20,0,>10,0,>8,0,>4,0,>2,0,>1,0
      >11C8=>8000 >4000 >2000 
      >11CE=>1000 >0800 >0400 
      >11D4=>0200 >0100       
660                            Vector vbitcharsmall, vidws
*** <expansion of vector>
1     >11D8                   vbitcharsmall  data vidws, vbitcharsmall_entry
      >11D8=>FC60 >11DC       
2     >11DC                   vbitcharsmall_entry:    
*** video_bit.i
661   >11DC=>0300 >0000       	limi	0
662   >11E0=>020A >F740       	li		SP,vstack + vstacksize
664   >11E4=>C020 >F7CA       	mov		@vx,0
665   >11E8=>C060 >F7A4       	mov		@vcoordaddr,1
666   >11EC=>0691             	bl		*1				; get address in 0, shift in 1
668   >11EE=>C0C0             	mov		0,3
669   >11F0=>0243 >0007       	andi	3,7
670   >11F4=>0503             	neg		3
671   >11F6=>0223 >0008       	ai		3,8				; R3=# pixels before row block
674   >11FA=>C100             	mov		0, 4
676                           	; first, draw with R0 shift and the left 8-shift bit
677                           	
678   >11FC=>0705             	seto	5
679   >11FE=>D020 >F7A2       	movb	@vbsize, 0
680   >1202=>0980             	srl		0,8
681   >1204=>1301             	jeq		vbscs0				; avoid losing all bits (=16)
682   >1206=>0905             	srl		5, 0				; bitmask
683   >1208                   vbscs0:
684   >1208=>0545             	inv		5				; e.g. FF00 or FC00
686   >120A=>C001             	mov		1,0
687   >120C=>0B05             	src		5,0				; e.g. 03F0
688   >120E=>06A0 >122A       	bl		@vbitcharstrip
690                           	; then draw the next strip over one block
691   >1212=>0201 >0008       	li		1,8
692   >1216=>A001             	a		1,0
693   >1218=>0280 >0008       	ci		0,8
694   >121C=>1205             	jle		vbcsout
695   >121E=>0224 >0008       	ai		4,8
696   >1222=>06C5             	swpb	5
697   >1224=>06A0 >122A       	bl		@vbitcharstrip
698   >1228                   vbcsout:
700   >1228=>0380             	rtwp
702                           	
712   >122A                   vbitcharstrip
713                               PUSH    SP, 0, 1, 3, 4, 7, 8, 9, 11, 12
*** <expansion of push>
1     >122A=>022A >FFEE           ai SP, -9*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >122E=>CA80 >0010               mov  0 , @(9-0-1)*2(SP)
2     >1232=>CA81 >000E               mov  1 , @(9-1-1)*2(SP)
3     >1236=>CA83 >000C               mov  3 , @(9-2-1)*2(SP)
4     >123A=>CA84 >000A               mov  4 , @(9-3-1)*2(SP)
5     >123E=>CA87 >0008               mov  7 , @(9-4-1)*2(SP)
6     >1242=>CA88 >0006               mov  8 , @(9-5-1)*2(SP)
7     >1246=>CA89 >0004               mov  9 , @(9-6-1)*2(SP)
8     >124A=>CA8B >0002               mov  11 , @(9-7-1)*2(SP)
9     >124E=>C68C                     mov  12, @(9-8-1)*2(SP)
*** video_bit.i
714   >1250=>C240             	mov		0,9
716                           	; read video memory into RAM
717   >1252=>0202 >F7E6       	li		2,vbitbuf
719                           	; read all the current char bytes and mask off bits to modify
720   >1256=>D220 >F7A3       	movb 	@vbsize+1, 8
721   >125A=>0988             	srl		8,8
723   >125C=>A120 >F78A       	a		@vpatts,4
724   >1260=>C1C4             	mov		4,7
726   >1262=>06A0 >12D8       	bl		@vbitreadstrip
728   >1266=>06A0 >0ECC           bl      @vfetchfontchar
730   >126A=>C107             	mov		7,4
731   >126C=>C004             	mov		4,0
732   >126E=>06A0 >044A       	bl		@vwaddr				; set VDP addr for patt
734   >1272=>C009             	mov		9,0
735   >1274=>C0C8             	mov		8,3
736   >1276                   vbsblit:
737   >1276=>04CC             	clr		12
738   >1278=>D331             	movb	*1+,12
739   >127A=>0B0C             	src		12,0
740   >127C=>F332             	socb	*2+,12
741   >127E=>D80C >FF88       	movb	12,@VDPWD
742   >1282=>0603             	dec		3
743   >1284=>130A             	jeq 	vbsblit_0
744   >1286=>0584             	inc		4
745   >1288=>2520 >031C       	czc		@h07,4
746   >128C=>16F4             	jne		vbsblit
747   >128E=>0604             	dec		4
748   >1290=>06A0 >12BA       	bl		@vbsnextblock
749   >1294=>044A             	data	vwaddr
750   >1296=>C009             	mov		9,0
751   >1298=>10EE             	jmp		vbsblit
753   >129A                   vbsblit_0:
754   >129A=>06A0 >038E           bl      @vgetcolorbyte
755   >129E=>D040                 movb    0,1
756   >12A0=>C107             	mov		7,4
757   >12A2=>06A0 >131C       	bl		@vbitsetcolorstrip
759                               POP     SP, 0, 1, 3, 4, 7, 8, 9, 11, 12
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >12A6=>C33A                     mov *SP+,  12
2     >12A8=>C2FA                     mov *SP+,  11 
3     >12AA=>C27A                     mov *SP+,  9 
4     >12AC=>C23A                     mov *SP+,  8 
5     >12AE=>C1FA                     mov *SP+,  7 
6     >12B0=>C13A                     mov *SP+,  4 
7     >12B2=>C0FA                     mov *SP+,  3 
8     >12B4=>C07A                     mov *SP+,  1 
9     >12B6=>C03A                     mov *SP+,  0 
*** video_bit.i
760   >12B8=>045B             	rt
768   >12BA                   vbsnextblock ; PUSH   SP, 1, 11
769   >12BA=>022A >FFFC       	ai 		SP,-4
770   >12BE=>CA81 >0002       	mov		1,@2(SP)
771   >12C2=>C07B             	mov		*11+,1
772   >12C4=>C68B             	mov 	11,*SP
773   >12C6=>0224 >0100       	ai		4,>100
774   >12CA=>0244 >3FF8       	andi	4,>3ff8
775   >12CE=>C004             	mov		4,0
776   >12D0=>0691             	bl		*1
777   >12D2=>C2FA             	mov 	*SP+, 11
778   >12D4=>C07A             	mov 	*SP+, 1
779   >12D6=>045B             	rt
792   >12D8                   vbitreadstrip PUSH  SP,4, 6, 9, 11
*** <expansion of push>
1     >12D8=>022A >FFF8           ai SP, -4*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >12DC=>CA84 >0006               mov  4 , @(4-0-1)*2(SP)
2     >12E0=>CA86 >0004               mov  6 , @(4-1-1)*2(SP)
3     >12E4=>CA89 >0002               mov  9 , @(4-2-1)*2(SP)
4     >12E8=>C68B                     mov  11, @(4-3-1)*2(SP)
*** video_bit.i
793   >12EA=>C004             	mov		4,0
794   >12EC=>06A0 >044E       	bl		@vraddr				; set VDP addr for patt
796                           	; read video memory into RAM
798                           	; read all the current char bytes and mask off bits to modify
800   >12F0=>C248             	mov 	8,9
801   >12F2                   vbrsrd:
802   >12F2=>D1A0 >FF80       	movb 	@VDPRD,6
803   >12F6=>5185             	szcb 	5, 6
804   >12F8=>DC86             	movb 	6,*2+
805   >12FA=>0609             	dec 	9
806   >12FC=>1309             	jeq 	vbrsrd_1
807   >12FE=>0580             	inc		0
808   >1300=>2420 >031C       	czc		@h07,0
809   >1304=>16F6             	jne		vbrsrd
810   >1306=>0600             	dec		0
811   >1308=>06A0 >12BA       	bl		@vbsnextblock
812   >130C=>044E             	data	vraddr
813   >130E=>10F1             	jmp		vbrsrd
814   >1310                   vbrsrd_1:
815                           	
816   >1310=>6088             	s 		8, 2			; reset buf ptr
818                               POP     SP, 4, 6, 9, 11 
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1312=>C2FA                     mov *SP+,  11
2     >1314=>C27A                     mov *SP+,  9 
3     >1316=>C1BA                     mov *SP+,  6 
4     >1318=>C13A                     mov *SP+,  4 
*** video_bit.i
819   >131A=>045B             	rt
829   >131C                   vbitsetcolorstrip
830                               PUSH    SP, 4, 8, 11
*** <expansion of push>
1     >131C=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1320=>CA84 >0004               mov  4 , @(3-0-1)*2(SP)
2     >1324=>CA88 >0002               mov  8 , @(3-1-1)*2(SP)
3     >1328=>C68B                     mov  11, @(3-2-1)*2(SP)
*** video_bit.i
832   >132A=>D820 >F7CC >F7CC 	movb	@vmono,@vmono
833   >1330=>1614             	jne	vbcsnocol
835   >1332=>6120 >F78A       	s		@vpatts,4
836   >1336=>A120 >F78E       	a		@vcolors,4
838   >133A=>C004             	mov		4,0				; draw color
839   >133C=>06A0 >044A       	bl		@vwaddr
841   >1340                   vbsclr:
842   >1340=>D801 >FF88       	movb	1,@VDPWD
843   >1344=>0608             	dec		8
844   >1346=>1309             	jeq		vbcsnocol
845   >1348=>0580             	inc		0
846   >134A=>2420 >031C       	czc		@h07,0
847   >134E=>16F8             	jne		vbsclr
848   >1350=>0600             	dec		0
849   >1352=>06A0 >12BA       	bl		@vbsnextblock
850   >1356=>044A             	data	vwaddr
851   >1358=>10F3             	jmp		vbsclr
853   >135A                   vbcsnocol:
854                               POP     SP, 4, 8, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >135A=>C2FA                     mov *SP+,  11
2     >135C=>C23A                     mov *SP+,  8 
3     >135E=>C13A                     mov *SP+,  4 
*** video_bit.i
855   >1360=>045B             	rt
865   >1362                   vbitfillrect
866                               PUSH    SP,11
*** <expansion of push>
1     >1362=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1364=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit.i
868                           	; check for a work in the right part of an 8x8 column
870   >1366=>C041             	mov		1,1			; any shift?
871   >1368=>1317             	jeq		vbfr_mid
873   >136A                   vbfr_left:
874                           	; calc the shift right (for left side)
875   >136A=>0205 >FF00       	li		5,>FF00
877   >136E=>0282 >0008       	ci		2,8
878   >1372=>1405             	jhe		vbfr_fulltoleft
880                           	; not full to the left of the next 8x8 block
881   >1374=>C002             	mov    	2,0
882   >1376=>0240 >0007       	andi	0,7
883   >137A=>0A05             	sla		5,0
885   >137C=>6082             	s		2,2				; full width taken care of
887   >137E                   vbfr_fulltoleft:
889   >137E=>C001             	mov		1,0
890   >1380=>0240 >0007       	andi	0,7
891   >1384=>0905             	srl		5,0				; bitmask
893   >1386=>06A0 >13C8       	bl		@vbitunalignedfill
895   >138A=>0224 >0008       	ai		4,8				; skip that partial column
897   >138E=>C082             	mov    	2,2				; already done?
898   >1390=>1319             	jeq		vbfr_out
900   >1392=>0222 >0008       	ai		2,8
901   >1396=>6081             	s		1,2				; remove lhs strip from width to use
905   >1398                   vbfr_mid:
906   >1398=>0282 >0008       	ci		2,8
907   >139C=>1A07             	jl		vbfr_right
909                           	; fill a column of 8xR8 blocks
910   >139E=>06A0 >142A       	bl		@vbitalignedfill
911   >13A2=>0224 >0008       	ai		4,8
912   >13A6=>0222 >FFF8       	ai		2,-8
913   >13AA=>10F6             	jmp		vbfr_mid
917   >13AC                   vbfr_right:
918   >13AC=>C042             	mov		2,1           	; # pixels remaining
919   >13AE=>0241 >0007       	andi	1,7				; # pixels on right
920   >13B2=>1308             	jeq		vbfr_out
922   >13B4=>0705             	seto	5
924   >13B6=>0200 >0007       	li		0,7
925   >13BA=>6001             	s		1,0
926   >13BC=>1301             	jeq		vbfr_r1
927   >13BE=>0905             	srl		5,0				; bitmask
928   >13C0                   vbfr_r1:
930                           	; adjust patt addr
931                           	
932   >13C0=>06A0 >13C8       	bl		@vbitunalignedfill
934   >13C4                   vbfr_out:
936                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >13C4=>C2FA                     mov *SP+,  11
*** video_bit.i
937   >13C6=>045B             	rt
949   >13C8                   vbitunalignedfill
950                               PUSH    SP, 1, 2, 7, 9, 11, 12
*** <expansion of push>
1     >13C8=>022A >FFF4           ai SP, -6*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >13CC=>CA81 >000A               mov  1 , @(6-0-1)*2(SP)
2     >13D0=>CA82 >0008               mov  2 , @(6-1-1)*2(SP)
3     >13D4=>CA87 >0006               mov  7 , @(6-2-1)*2(SP)
4     >13D8=>CA89 >0004               mov  9 , @(6-3-1)*2(SP)
5     >13DC=>CA8B >0002               mov  11 , @(6-4-1)*2(SP)
6     >13E0=>C68C                     mov  12, @(6-5-1)*2(SP)
*** video_bit.i
952   >13E2=>C1C4             	mov		4,7
953                           	; read video memory into RAM
954   >13E4=>0202 >F7E6       	li		2,vbitbuf
956   >13E8=>06A0 >12D8       	bl		@vbitreadstrip
958   >13EC=>C107             	mov		7,4
959   >13EE=>C004             	mov		4,0
960   >13F0=>06A0 >044A       	bl		@vwaddr				; set VDP addr for patt
962   >13F4=>C248             	mov		8,9
963   >13F6                   vbufblit:
964   >13F6=>F48C             	socb	12,*2
965   >13F8=>D832 >FF88       	movb	*2+,@VDPWD
966   >13FC=>0609             	dec		9
967   >13FE=>1309             	jeq 	vbufblit_0
968   >1400=>0584             	inc		4
969   >1402=>2520 >031C       	czc		@h07,4
970   >1406=>16F7             	jne		vbufblit
971   >1408=>0604             	dec		4
972   >140A=>06A0 >12BA       	bl		@vbsnextblock
973   >140E=>044A             	data	vwaddr
974   >1410=>10F2             	jmp		vbufblit
976   >1412                   vbufblit_0:
977   >1412=>C04C             	mov		12,1
978   >1414=>06C1             	swpb	1
979   >1416=>C107             	mov		7,4
980   >1418=>06A0 >131C       	bl		@vbitsetcolorstrip
982                               POP     SP, 1, 2, 7, 9, 11, 12
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >141C=>C33A                     mov *SP+,  12
2     >141E=>C2FA                     mov *SP+,  11 
3     >1420=>C27A                     mov *SP+,  9 
4     >1422=>C1FA                     mov *SP+,  7 
5     >1424=>C0BA                     mov *SP+,  2 
6     >1426=>C07A                     mov *SP+,  1 
*** video_bit.i
983   >1428=>045B             	rt
994   >142A                   vbitalignedfill
995                               PUSH    SP, 1, 2, 7, 9, 11    
*** <expansion of push>
1     >142A=>022A >FFF6           ai SP, -5*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >142E=>CA81 >0008               mov  1 , @(5-0-1)*2(SP)
2     >1432=>CA82 >0006               mov  2 , @(5-1-1)*2(SP)
3     >1436=>CA87 >0004               mov  7 , @(5-2-1)*2(SP)
4     >143A=>CA89 >0002               mov  9 , @(5-3-1)*2(SP)
5     >143E=>C68B                     mov  11, @(5-4-1)*2(SP)
*** video_bit.i
997   >1440=>C1C4             	mov		4,7
998   >1442=>C004             	mov		4,0
999   >1444=>06A0 >044A       	bl		@vwaddr				; set VDP addr for patt
1001  >1448=>C248             	mov		8,9
1002  >144A=>0201 >0007       	li		1,7
1003  >144E                   vbafblit:
1004  >144E=>D80C >FF88       	movb	12,@VDPWD
1005  >1452=>0609             	dec		9
1006  >1454=>1307             	jeq 	vbafblit_0
1007  >1456=>0580             	inc		0
1008  >1458=>2401             	czc		1,0
1009  >145A=>16F9             	jne		vbafblit
1010  >145C=>06A0 >12BA       	bl		@vbsnextblock
1011  >1460=>044A             	data	vwaddr
1012  >1462=>10F5             	jmp		vbafblit
1014  >1464                   vbafblit_0:
1015  >1464=>C04C             	mov		12,1
1016  >1466=>06C1             	swpb	1
1017  >1468=>C107             	mov		7,4
1018  >146A=>06A0 >131C       	bl		@vbitsetcolorstrip
1020                              POP     SP, 1, 2, 7, 9, 11    
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >146E=>C2FA                     mov *SP+,  11
2     >1470=>C27A                     mov *SP+,  9 
3     >1472=>C1FA                     mov *SP+,  7 
4     >1474=>C0BA                     mov *SP+,  2 
5     >1476=>C07A                     mov *SP+,  1 
*** video_bit.i
1021  >1478=>045B             	rt
*** nforth.tsm
506                           	incl	video_bit4.i
*** video_bit4.i
26    >147A                   vstdpalette
27    >147A=>0000                 db >00, >00 ;0
28    >147C=>0000                 db >00, >00 ;1
29    >147E=>1106                 db >11, >06 ;2
30    >1480=>3307                 db >33, >07 ;3
31    >1482=>1701                 db >17, >01 ;4
32    >1484=>2703                 db >27, >03 ;5
33    >1486=>5101                 db >51, >01 ;6
34    >1488=>2706                 db >27, >06 ;7
35    >148A=>7101                 db >71, >01 ;8
36    >148C=>7303                 db >73, >03 ;9
37    >148E=>6106                 db >61, >06 ;A
38    >1490=>6406                 db >64, >06 ;B
39    >1492=>1104                 db >11, >04 ;C
40    >1494=>6502                 db >65, >02 ;D
41    >1496=>5505                 db >55, >05 ;E
42    >1498=>7707                 db >77, >07 ;F
43                                
45    >149A                   venhregs    
46    >149A=>0808                 dw  >808        ; 64 kvideo RAM
47    >149C=>0E00                 dw  >e00        ; set bank 0, page 0, etc
48    >149E=>0980                 dw  >980        ; 212-line mode, color, etc
49    >14A0=>0C00                 dw  >c00        ; turn off alt colors
50    >14A2=>0D00                 dw  >d00        ; turn off blink/pageswap
51    >14A4=>0F00                 dw  >f00        ; point to sr0
52    >14A6=>0000                 dw  0
53                                         
56    >14A8                   venhmode
57                                push SP,R0,R1,R11
*** <expansion of push>
1     >14A8=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >14AC=>CA80 >0004               mov  R0 , @(3-0-1)*2(SP)
2     >14B0=>CA81 >0002               mov  R1 , @(3-1-1)*2(SP)
3     >14B4=>C68B                     mov  R11, @(3-2-1)*2(SP)
*** video_bit4.i
58                                
59    >14B6=>0201 >149A           li      1, venhregs
60    >14BA                   venhmode0:  mov *1+, 0
      >14BA=>C031             
61    >14BC=>1303                 jeq     venhmode1
62    >14BE=>06A0 >0460           bl      @vwreg
63    >14C2=>10FB                 jmp     venhmode0
64    >14C4                   venhmode1:    
65                                pop     SP,R0,R1,R11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >14C4=>C2FA                     mov *SP+,  R11
2     >14C6=>C07A                     mov *SP+,  R1 
3     >14C8=>C03A                     mov *SP+,  R0 
*** video_bit4.i
66    >14CA=>045B                 rt
70    >14CC                   vstatus0
71    >14CC=>0200 >0F00           li      0, >f00
72    >14D0=>0460 >0460           b       @vwreg
73                                
74    >14D4                   vsetpalette
75                                push    SP,R0,R11
*** <expansion of push>
1     >14D4=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >14D8=>CA80 >0002               mov  R0 , @(2-0-1)*2(SP)
2     >14DC=>C68B                     mov  R11, @(2-1-1)*2(SP)
*** video_bit4.i
76                                ; set std palette
77    >14DE=>06A0 >048A           bl      @vwregnext
78    >14E2=>1000                 data    >1000
79    >14E4=>0200 >147A           li      0, vstdpalette
80    >14E8                   vsetpal1 movb *0+, @VDPCL
      >14E8=>D830 >FF8C       
81    >14EC=>0280 >149A           ci      0, vstdpalette + 16*2
82    >14F0=>16FB                 jne     vsetpal1
83                                pop     SP,R0,R11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >14F2=>C2FA                     mov *SP+,  R11
2     >14F4=>C03A                     mov *SP+,  R0 
*** video_bit4.i
84    >14F6=>045B                 rt
89    >14F8                   vbitmap4setup
90    >14F8=>0201 >05C8           li  1, vbit4
91    >14FC                   vbit4sentr:
92                                PUSH    SP,11
*** <expansion of push>
1     >14FC=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >14FE=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
93    >1500=>D820 >0014 >F7CD     movb    #M_bit4,@vidmode
95    >1506=>06A0 >075C           bl  @vsetupregs
96    >150A=>06A0 >0790           bl  @vsetupaddrs
97    >150E=>06A0 >14A8           bl  @venhmode
98                                
99    >1512=>C831 >F7B6           mov *1+,@vbit4stride
100   >1516=>C831 >F7B8           mov *1+,@vbit4shift
101   >151A=>C831 >F7BA           mov *1+,@vbit4mask
103   >151E=>C801 >F7C8           mov 1,@vtermptr
104   >1522=>06A0 >14D4           bl  @vsetpalette
105                               
106                               POP SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1526=>C2FA                     mov *SP+,  11
*** video_bit4.i
107   >1528=>045B                 rt
109   >152A                   vbitmap5setup
110   >152A=>0201 >05FC           li  1, vbit5
111   >152E=>10E6                 jmp vbit4sentr
113   >1530                   vbitmap6setup
114   >1530=>0201 >0632           li  1, vbit6
115   >1534=>10E3                 jmp vbit4sentr
117   >1536                   vbitmap7setup
118   >1536=>0201 >0666           li  1, vbit7
119   >153A=>10E0                 jmp vbit4sentr
131   >153C                   vbit4xaddr 
132                               PUSH    SP,2
*** <expansion of push>
1     >153C=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >153E=>C682                     mov  2, @(1-0-1)*2(SP)
*** video_bit4.i
134   >1540=>A020 >F7C2           a       @vwx, 0
135                               
136                               ; scale Y by vbsize
137   >1544=>C040                 mov     0,1
138   >1546=>7041                 sb      1,1
139   >1548=>D0A0 >F7A3           movb    @vbsize+1,2
140   >154C=>0982                 srl     2,8
141   >154E=>3881                 mpy     1,2             ; 2=xxx, 3=row#
142                               
143   >1550=>C043                 mov     3,1
144   >1552=>3860 >F7B6           mpy     @vbit4stride, 1 ; 2=addr
145                               
146                               ; scale X by vbsize
147   >1556=>0980                 srl     0,8
148   >1558=>D060 >F7A2           movb    @vbsize,1
149   >155C=>0981                 srl     1,8    
150   >155E=>3801                 mpy     1,0             ; 0=xxx, 1=X scaled 
151                               
152   >1560=>C0C1                 mov     1,3
153   >1562=>C020 >F7B8           mov     @vbit4shift,0
154   >1566=>1301                 jeq     vb4xnoshift
155   >1568=>0901                 srl     1,0             ; R1=offset
156   >156A                   vb4xnoshift:
157   >156A=>A081                 a       1,2             ; R2=full addr
158   >156C=>C002                 mov     2,0             ; R0=full addr
159                               
160   >156E=>C043                 mov     3,1             ; preshifted X
161   >1570=>4060 >F7BA           szc     @vbit4mask,1    ; R1=portion
162                               
163                               POP     SP,2
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1574=>C0BA                     mov *SP+,  2
*** video_bit4.i
164   >1576=>045B                 rt
172   >1578                   vcoordsend:
173   >1578=>06C0             	swpb	0
174   >157A=>D500             	movb	0, *4
175   >157C=>06C0             	swpb	0
176   >157E=>D500             	movb	0, *4
177   >1580=>045B             	rt
183   >1582                   vcmdsetup
184   >1582=>C03B                 mov     *11+, 0  
185                               PUSH    SP, 11
*** <expansion of push>
1     >1584=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1586=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
186                               
187   >1588=>0260 >1100           ori     0,>1100
188   >158C=>06A0 >0460           bl      @vwreg
189                               
190   >1590=>0204 >FF8E           li      4, VDPWI
191                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1594=>C2FA                     mov *SP+,  11
*** video_bit4.i
192   >1596=>045B                 rt
201   >1598                   vbit4xsetupcursorDXDY
202                               PUSH    SP, 11
*** <expansion of push>
1     >1598=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >159A=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
203   >159C=>A020 >F7C2           a       @vwx, 0
204                               
205                               ; scale Y by vbsize
206   >15A0=>C040                 mov     0,1
207   >15A2=>7041                 sb      1,1
208   >15A4=>D0A0 >F7A3           movb    @vbsize+1,2
209   >15A8=>0982                 srl     2,8
210   >15AA=>3881                 mpy     1,2             ; 2=xxx, 3=row#
211                               
212                               ; account for the "big page"
213   >15AC=>A0E0 >FF6E           a       @vpgrow, 3
214                               
215   >15B0=>0980                 srl     0,8
216   >15B2=>D060 >F7A2           movb    @vbsize,1
217   >15B6=>0981                 srl     1,8    
218   >15B8=>3801                 mpy     1,0             ; 0=xxx, 1=X scaled 
220   >15BA=>06A0 >1582           bl      @vcmdsetup
221   >15BE=>0024                 data    >24
222                               
223   >15C0=>C001                 mov     1, 0
224   >15C2=>06A0 >1578           bl      @vcoordsend     ; send DX
225   >15C6=>C003                 mov     3, 0
226   >15C8=>06A0 >1578           bl      @vcoordsend     ; send DY
227                               
228                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >15CC=>C2FA                     mov *SP+,  11
*** video_bit4.i
229   >15CE=>045B                 rt
230                               
237   >15D0                   vbit4xsetupwindowlineNXNY
238                               push    SP, 11
*** <expansion of push>
1     >15D0=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >15D2=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
239                               
240   >15D4=>04C1                 clr     1
241   >15D6=>D060 >F7A2           movb    @vbsize,1       ; X size (hi)
242   >15DA=>04C2                 clr     2
243   >15DC=>D0A0 >F7C4           movb    @vwxs,2         ; X (hi)
244   >15E0=>3881                 mpy     1,2             ; 2=col #  (3 = 0)
245   >15E2=>C002                 mov     2, 0
246   >15E4=>0600                 dec     0
247   >15E6=>06A0 >1578           bl      @vcoordsend     ; NX
248                               
249                               ; height is vbsize
250   >15EA=>D020 >F7A3           movb    @vbsize+1,0
251   >15EE=>0980                 srl     0,8
252   >15F0=>0600                 dec     0      
253   >15F2=>06A0 >1578           bl      @vcoordsend     ; NY
254                               
255                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >15F6=>C2FA                     mov *SP+,  11
*** video_bit4.i
256   >15F8=>045B                 rt
265   >15FA                   vbit4xsetupwindowcharNXNY
266                               push    SP, 11
*** <expansion of push>
1     >15FA=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >15FC=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
267                               
268   >15FE=>D0A0 >F7A2           movb    @vbsize,2      
269   >1602=>0982                 srl     2,8
270   >1604=>C002                 mov     2,0
271   >1606=>0600                 dec     0
272   >1608=>06A0 >1578           bl      @vcoordsend     ; NX
273                               
274   >160C=>D0E0 >F7A3           movb    @vbsize+1,3
275   >1610=>0983                 srl     3,8
276   >1612=>C003                 mov     3,0
277   >1614=>0600                 dec     0
278   >1616=>06A0 >1578           bl      @vcoordsend     ; NY
279                               
280                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >161A=>C2FA                     mov *SP+,  11
*** video_bit4.i
281   >161C=>045B                 rt
282                               
296   >161E                   vbit4xsetupMMMcommand
297                               push    SP,11
*** <expansion of push>
1     >161E=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1620=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
298                               
299   >1622=>06A0 >048A           bl      @vwregnext
300   >1626=>0F02                 data    >0f02        ; set status reg for testing command finished & transfer ready
301                               
302                               ; wait for ready
303   >1628                   vb4xclr:
304   >1628=>D020 >FF82           movb    @VDPST,0
305   >162C=>0240 >0100           andi    0, >0100
306   >1630=>16FB                 jne     vb4xclr
308                               ; write the command
309   >1632=>D509                 movb    9, *4 
310                               
311                               ; back to the CLR reg, no autoincrement
312   >1634=>06A0 >048A           bl      @vwregnext
313   >1638=>11AC                 data    >11AC
314                               
315                               pop     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >163A=>C2FA                     mov *SP+,  11
*** video_bit4.i
316   >163C=>045B                 rt
317                               
318                               
330   >163E                   vbit4xclearline
331                               PUSH    SP,0,3,11
*** <expansion of push>
1     >163E=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1642=>CA80 >0004               mov  0 , @(3-0-1)*2(SP)
2     >1646=>CA83 >0002               mov  3 , @(3-1-1)*2(SP)
3     >164A=>C68B                     mov  11, @(3-2-1)*2(SP)
*** video_bit4.i
333   >164C=>06A0 >1598           bl      @vbit4xsetupcursorDXDY
334   >1650=>06A0 >15D0           bl      @vbit4xsetupwindowlineNXNY
336   >1654=>D520 >F7BF           movb    @vfgbg+1, *4    ; CLR
338   >1658=>D520 >0019           movb    #>00, *4        ; ARG (dix=0, diy=0, mxc=0)
340   >165C=>0209 >8000           li      9, >8000        ; HMMV  (terminal is usually aligned)
341   >1660=>06A0 >161E           bl      @vbit4xsetupMMMcommand
342                               
343                               ; don't wait :)
344                               ;li      2, >0100
345                               ;li      3, VDPST
347                           	; see if done
348                           	;movb	*3,0
349                           	;coc		2, 0
350                           	;jeq		vb4xcl
352   >1664                   vb4xclout:			
353                               POP		SP,0,3,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1664=>C2FA                     mov *SP+,  11
2     >1666=>C0FA                     mov *SP+,  3 
3     >1668=>C03A                     mov *SP+,  0 
*** video_bit4.i
354   >166A=>045B             	rt
355                           	
363   >166C                   vsetbank
364   >166C=>064A                 dect    SP
365   >166E=>C680                 mov     0,*SP
366   >1670=>0960                 srl     0, 6
367   >1672=>B020 >FF6C           ab      @vpob, 0
368   >1676=>D800 >FF8A           movb    0, @VDPWA
369   >167A=>C03A                 mov     *SP+,0
370   >167C=>D820 >0FEF >FF8A     movb    #>8e,@VDPWA
371   >1682=>0240 >3FFF           andi    0,>3fff
372   >1686=>045B                 rt
377                               
378   >1688                   vbit4xsendcharpixel
379   >1688=>0A17                 sla     7,1
380   >168A=>1703                 jnc     vbit4xscpon
381   >168C=>D520 >FC79           movb    @vidws+25, *4       ; CLR
382   >1690=>045B                 rt
383   >1692                   vbit4xscpon:    
384   >1692=>D50C                 movb    12, *4              ; CLR
385   >1694=>045B                 rt
386                               
394                            Vector vbit4xchar, vidws
*** <expansion of vector>
1     >1696                   vbit4xchar  data vidws, vbit4xchar_entry
      >1696=>FC60 >169A       
2     >169A                   vbit4xchar_entry:    
*** video_bit4.i
395   >169A=>0300 >0000           limi    0
396   >169E=>020A >F740           li      SP,vstack + vstacksize
398   >16A2=>C020 >F7CA           mov     @vx, 0
399   >16A6=>06A0 >1598           bl      @vbit4xsetupcursorDXDY
400                               ; R4 = VDPWI
401                               
402   >16AA=>06A0 >15FA           bl      @vbit4xsetupwindowcharNXNY
403                               ; R2 = X size, R3 = Y size
404                               
405   >16AE=>06A0 >0ECC           bl      @vfetchfontchar
407   >16B2=>C320 >F7BE           mov     @vfgbg,12
408   >16B6=>06CC                 swpb    12
409   >16B8=>D1F1                 movb    *1+, 7               ; fetch first row
410   >16BA=>06A0 >1688           bl      @vbit4xsendcharpixel  ; send first CLR
412   >16BE=>D520 >0019           movb    #0, *4              ; ARG (dix=0, diy=0, mxc=0)
413                               
414   >16C2=>0209 >B800           li      9, >B800            ; LMMC + TINP
415   >16C6=>06A0 >161E           bl      @vbit4xsetupMMMcommand
417   >16CA=>C202                 mov     2, 8                ; R8 = ctr for column
418   >16CC=>0608                 dec     8                   ; from first pixel above
419                               
420   >16CE                   vbit4xchar_row
421                               ; R7 holds char, R8 is column ctr
422                               
423   >16CE                   vb4xchp:
424                               ; see if ready
425   >16CE=>D020 >FF82           movb    @VDPST,0
426   >16D2=>1101                 jlt     vbit4xchar_pixel
427   >16D4=>10FC                 jmp     vb4xchp
429   >16D6                   vbit4xchar_pixel:    
430   >16D6=>06A0 >1688           bl      @vbit4xsendcharpixel
431                               
432   >16DA=>0608                 dec     8
433   >16DC=>15F8                 jgt     vb4xchp
434                               
435   >16DE=>C202                 mov     2, 8
436   >16E0=>D1F1                 movb    *1+, 7
437   >16E2=>0603                 dec     3
438   >16E4=>15F4                 jgt     vbit4xchar_row
439                                   
440   >16E6=>06A0 >14CC           bl      @vstatus0
441   >16EA=>0380                 rtwp
449                            Vector vbit4xcursor, vidws
*** <expansion of vector>
1     >16EC                   vbit4xcursor  data vidws, vbit4xcursor_entry
      >16EC=>FC60 >16F0       
2     >16F0                   vbit4xcursor_entry:    
*** video_bit4.i
451   >16F0=>0300 >0000           limi   0
452   >16F4=>020A >F740           li     SP,vstack + vstacksize
454   >16F8=>C020 >F7CA           mov     @vx, 0
455   >16FC=>06A0 >1598           bl      @vbit4xsetupcursorDXDY
456                               ; R4 = VDPWI
457                               
458   >1700=>0200 >0001           li      0, 1            ; two cols
459   >1704=>06A0 >1578           bl      @vcoordsend         ; NX
460                               
461   >1708=>D020 >F7A3           movb    @vbsize+1, 0
462   >170C=>0980                 srl     0,8
463   >170E=>0600                 dec     0
464   >1710=>06A0 >1578           bl      @vcoordsend         ; NY
466   >1714=>D520 >045D           movb    #>ff, *4            ; CLR
468   >1718=>D520 >0019           movb    #0, *4              ; ARG (dix=0, diy=0, mxc=0)
469                               
470   >171C=>0209 >8300           li      9, >8300            ; LMMV + EOR
471   >1720=>06A0 >161E           bl      @vbit4xsetupMMMcommand
473   >1724=>B820 >005F >F7AA     ab  #>80,@vcurs
475   >172A=>06A0 >14CC           bl      @vstatus0
476                               ; no need to wait!
477                               
478   >172E=>0380                 rtwp
498   >1730                   vbitsetupDXDYNXNYsigned
499                               PUSH    SP,11
*** <expansion of push>
1     >1730=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1732=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
500                               
501                               ; R2 is original ARG byte, but has $8000 mask for LINE
502                               
503                               ; adjust dx and dix
504   >1734=>C021 >0002           mov @2(1) , r0   ; nx
505   >1738=>1503                 jgt vbsdns0
506                               
507   >173A=>0262 >0004           ori R2 , 4     ; DIX
508   >173E=>0740                 abs r0
509   >1740                   vbsdns0:
510                               
511                               ; adjust dy and diy
512                               
513   >1740=>C0D1                 mov *1 , r3     ; ny
514   >1742=>1503                 jgt vbsdns1
515                               
516   >1744=>0262 >0008           ori R2 , 8     ; DIY
517   >1748=>0743                 abs r3
518   >174A                   vbsdns1:
519                               
520                               ; -------------
521                               
522   >174A=>C082                 mov R2 , R2       ; is this a LINE command?
523   >174C=>1508                 jgt vbsdns2
524   >174E=>1307                 jeq vbsdns2
525                               
526   >1750=>80C0                 c r0 , r3           ; compare X and Y lengths
527   >1752=>1B05                 jh vbsdns2
528   >1754=>0262 >0001           ori R2 , 1          ; Y is major
529                               
530   >1758=>C2C3                 mov r3 , 11         ; swap DX / DY
531   >175A=>C0C0                 mov r0 , r3
532   >175C=>C00B                 mov 11 , r0
533                               
534                               ; -------------
536   >175E                   vbsdns2:    
537   >175E=>C840 >0002           mov r0 , @2(1)
538   >1762=>C443                 mov r3 , *1
540   >1764=>1002                 jmp vbsdn0
554   >1766                   vbitsetupDXDYNXNY:
555                               PUSH    SP, 11
*** <expansion of push>
1     >1766=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1768=>C68B                     mov  11, @(1-0-1)*2(SP)
*** video_bit4.i
556                               
557   >176A                   vbsdn0:
558   >176A=>0203 >1578           li      3, vcoordsend
559                               
560   >176E=>C021 >0006           mov     @6(1) , 0
561   >1772=>0693                 bl      *3        ; DX
563   >1774=>C021 >0004           mov     @4(1) , 0
564   >1778=>A020 >FF6E           a       @vpgrow , 0
565   >177C=>0693                 bl      *3         ; DY
567   >177E=>C021 >0002           mov     @2(1) , 0
568   >1782=>0693                 bl      *3         ; NX
570   >1784=>C011                 mov     *1 , 0
571   >1786=>0693                 bl      *3        ; NY
573   >1788=>06C2                 swpb    2
574                               
575                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >178A=>C2FA                     mov *SP+,  11
*** video_bit4.i
576   >178C=>045B                 rt
*** nforth.tsm
507                           	incl	kbd.i
*** kbd.i
24    >178E                   kinit
25                                ;   reset clears all memory
27    >178E=>C820 >2896 >F90C     mov    #>1e03,@kbdlimit  ; 1/2 s before repeat, 1/20 s delay between repeat
28                            	
29    >1794=>045B             	rt
45    >1796                   scankbd	mov	11,10
      >1796=>C28B             
47    >1798=>04CC             	clr		12
48    >179A=>1D15             	sbo		21		 	; clear alpha lock line
50    >179C=>04C1             	clr		1		 	; read char
52    >179E=>020C >0024       	li		12,>24	 	; kbd select
53    >17A2=>04C3             	clr		3			; row * >100
54    >17A4=>30C3             	ldcr	3,3		 	; set
56    >17A6=>020C >0006       	li		12,>6	 	; kbd matrix
57    >17AA=>3604             	stcr	4,8		 	; get row 0
58    >17AC=>0544             	inv		4			; 0=off 1=on
59                            	
60    >17AE=>04C5             	clr     5
61    >17B0=>9120 >03BF       	cb      #>72, 4     ; ctrl+fctn+shift+space (abort)?
62    >17B4=>1601             	jne     sknobreak
63                            	
64    >17B6=>0705             	seto    5           ; remember for later
65                            	
66    >17B8                   sknobreak:	
67    >17B8=>C084             	mov		4,2			; copy to R2=shifts
68    >17BA=>0242 >7000       	andi	2,>7000		; save 0=off 1=on (shifts)
69    >17BE=>D802 >F8E9       	movb	2,@kbdshft	; save shift
70    >17C2=>0244 >0700       	andi	4,>0700		; mask =, space, enter
71    >17C6=>1003             	jmp		skloop0
73    >17C8                   skloop:
74    >17C8=>0704             	seto	4		 	; set low bits too	
75    >17CA=>3604             	stcr	4,8		 	; read 8 bits
76    >17CC=>0544               	inv		4		 	; 0=off 1=on
77    >17CE                   skloop0:
78    >17CE=>160B             	jne		skgotsome	; any bits set?
79    >17D0=>0223 >0100       	ai		3,>100
80    >17D4=>0283 >0600       	ci		3,>600		; stop at joystick
81    >17D8=>130C             	jeq		skblank
83    >17DA=>020C >0024       	li		12,>24		; point to kbd select
84    >17DE=>30C3             	ldcr	3,3		 	; set new row #
85    >17E0=>020C >0006       	li		12,>6	 	; point to matrix
86    >17E4=>10F1             	jmp		skloop
88    >17E6                   skgotsome:
89    >17E6=>0953             	srl		3,5		 	; entry into table
90    >17E8=>06C4             	swpb	4		 	; move to low byte so we can
91    >17EA                   skwhich:
92    >17EA=>0914             	srl		4,1			; roll down
93    >17EC=>1808             	joc		skdone	 	; this bit?
94    >17EE=>0583             	inc		3			; next
95    >17F0=>10FC             	jmp		skwhich
97    >17F2                   skblank:
98    >17F2=>D801 >F8E8       	movb	1,@kbdscan	; no key whatsoever
100   >17F6=>D0E0 >F8E9       	movb	@kbdshft,3	; shifts?
101   >17FA=>130A             	jeq		sknone
103   >17FC=>1002             	jmp		sknone0
105   >17FE                   skdone:	
106   >17FE=>06A0 >181A       	bl		@kbdhandle
107   >1802                   sknone0:
108   >1802=>A820 >F784 >F910     a       @timeout,@randnoise
109   >1808=>04E0 >F784           clr     @timeout
110   >180C=>06A0 >04DE       	bl     	@vscreenon
112   >1810                   sknone:
113   >1810=>D801 >F8E6       	movb	1,@kbdlast	   	; update last char
114   >1814=>A801 >F910       	a		1,@randnoise
116   >1818=>045A             	b		*10
120   >181A                   kbdhandle
131   >181A=>09B2             	srl		2,11		 	; get shift state
132                           	ai		2,grom_kbdlist	
134   >181C=>0209 >FF92           li      9,GPLRA
135   >1820=>D219             	movb	*9,8	      ; save GROM addr in R8
136   >1822=>06C8             	swpb    8
137   >1824=>D219             	movb	*9,8
138   >1826=>06C8             	swpb    8
139   >1828=>0608             	dec		8
141   >182A=>020C >FF96       	li		12,GPLWA
142   >182E=>D702             	movb	2,*12			; point to grom kbd list
143   >1830=>06C2             	swpb	2
144   >1832=>D702             	movb	2,*12
146   >1834=>0649                 dect    9
147   >1836=>D099             	movb	*9,2		   ; get table entry
148   >1838=>06C2             	swpb	2
149   >183A=>D099             	movb	*9,2		   ; it's flipped in GROM
150   >183C=>06C2             	swpb	2				
152   >183E=>A083             	a		3,2		 		; get offset
154   >1840=>D702             	movb	2,*12			; point to char
155   >1842=>06C2             	swpb	2
156   >1844=>D702             	movb	2,*12
157                           	
158   >1846=>D059             	movb	*9,1      	 	; R1=key code, 0-255
160   >1848=>D708             	movb	8,*12	    	; restore GROM addr
161   >184A=>06C8             	swpb    8
162   >184C=>D708             	movb	8,*12
164   >184E=>04CC             	clr		12
165   >1850=>1E15             	sbz		21		 	; turn on alpha lock line
166   >1852=>1F07             	tb		7
167   >1854=>1308             	jeq		khnoalpha
168                           		
169   >1856=>0281 >6100       	ci		1,>6100		; alpha lock on; 
170   >185A=>1A05             	jl		khnoalpha	; test 'a'-'z'
171   >185C=>0281 >7B00       	ci		1,>7b00
172   >1860=>1402             	jhe		khnoalpha
173   >1862=>0221 >E000       	ai		1,->2000	; uppercase
175   >1866                   khnoalpha:
176   >1866=>1D15             	sbo		21
177   >1868=>0583             	inc     3
178   >186A=>06C3             	swpb	3			; put scancode in hi byte
180   >186C                   khtestbuffer:
181   >186C=>0A14             	sla		4,1		 	; kbd_poll set?
182   >186E=>183E             	joc		khnone
184                           	; HACK!  Fctn-Shift-S is treated as Ctrl-H
185   >1870=>9060 >0B08       	cb		#211, 1
186   >1874=>1606             	jne		$0+
187   >1876=>9820 >03EF >F8E9 	cb		#>30, @kbdshft
188   >187C=>1602             	jne		$0
189                           	
190   >187E=>0201 >0800       	li		1,>0800
191                           	
192   >1882                   $0:
193   >1882=>F041             	socb	1,1
194   >1884=>1601             	jne		khbuffer   	; got something
196   >1886=>1032             	jmp		khnone
202   >1888                   khbuffer:	
203   >1888=>9803 >F8E8       	cb		3,@kbdscan 	       ; scancode the same?
204   >188C=>1611             	jne		khnew
206   >188E=>D0A0 >F90E       	movb	@kbdflag, 2      	; get flags
207   >1892=>B082             	ab      2,2
208   >1894=>1705             	jnc		khb4repeat          ; repeating yet?
210   >1896=>9820 >F8E7 >F90D 	cb		@kbdtimer,@kbddelay ; time for new repeat?
211   >189C=>1A27             	jl		khnone
212   >189E=>100D             	jmp		khstuff
214   >18A0                   khb4repeat:
215   >18A0=>9820 >F8E7 >F90C 	cb		@kbdtimer,@kbdlimit ; repeated long enough yet?
216   >18A6=>1A22             	jl		khnone		     	; no
217                           	
218   >18A8=>F820 >005F >F90E     socb    #>80,@kbdflag       ; set repeat flag
219                           	
220   >18AE=>1005             	jmp		khstuff
222   >18B0                   khnew:
223   >18B0=>5820 >005F >F90E 	szcb	#>80,@kbdflag	    ; clear repeat flag
224   >18B6=>D803 >F8E8       	movb	3,@kbdscan			; save new scancode
226   >18BA                   khstuff:
227   >18BA=>7820 >F8E7 >F8E7 	sb		@kbdtimer,@kbdtimer ; restart timer
229   >18C0=>C145                 mov     5,5                 ; check abort flag
230   >18C2=>1306                 jeq     khstuffit
231                               
232   >18C4=>04E0 >F8EA           clr     @kbdhead
233   >18C8=>04E0 >F90E           clr     @kbdflag
234   >18CC=>0460 >0070           b       @ABORT
236   >18D0                   khstuffit:
237   >18D0=>D0A0 >F8EB       	movb	@kbdtail,2	       	; get current pos in ring
238   >18D4=>0982                 srl     2,8
239   >18D6=>D881 >F8EC       	movb	1,@kbdbuf(2)	    ; buffer it
240   >18DA=>0582             	inc		2		     		; inc...
241   >18DC=>0242 >001F       	andi	2,kbdbufsize-1	    ; roll over if necc
242   >18E0=>06C2             	swpb	2
243   >18E2=>9802 >F8EA       	cb		2,@kbdhead	     	; overflow if equal!
244   >18E6=>1302             	jeq		khnone		     	; eeeer... don't update ptrs
246   >18E8=>D802 >F8EB       	movb	2,@kbdtail	     	; update
248   >18EC                   khnone:
250   >18EC                   khout:
251   >18EC=>045B             	rt
263   >18EE                   kbdavail 
272   >18EE=>9820 >F8EA >F8EB 	cb		@kbdhead,@kbdtail	; EQ=1 means none
273   >18F4=>045B             	rt
285   >18F6                   kbdread	   
295   >18F6=>04C1             	clr		1
296   >18F8=>9820 >F8EA >F8EB 	cb		@kbdhead,@kbdtail
297   >18FE=>130C             	jeq		krbempty
298   >1900=>D060 >F8EA       	movb	@kbdhead,1			; get head ptr
299   >1904=>B820 >01B9 >F8EA 	ab		#1,@kbdhead		; and inc...
300   >190A=>5820 >0079 >F8EA 	szcb	#-kbdbufsize,@kbdhead	; mask...
301   >1910=>06C1             	swpb	1					; and make offset
302   >1912=>D021 >F8EC       	movb	@kbdbuf(1),0		; and retrieve!
303   >1916=>0980             	srl		0,8
304   >1918                   krbempty:
305   >1918=>045B             	rt
*** nforth.tsm
508                           	
509                           	incl	term.i
*** term.i
30    >191A                   treset  	
31    >191A=>04E0 >F7CA       	clr	   @vx			    ; upper-left corner
32    >191E=>04E0 >F7C2       	clr	   @vwx			    ; window starts upper-left
33    >1922=>D820 >F7B5 >F7C4 	movb   @vwidth+1,@vwxs	; set dims to screen size
34    >1928=>D820 >F7B3 >F7C5 	movb   @vheight,@vwys	; set dims to screen size
35    >192E=>045B             	rt
55    >1930                   window	PUSH    SP,11
*** <expansion of push>
1     >1930=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1932=>C68B                     mov  11, @(1-0-1)*2(SP)
*** term.i
57    >1934=>06A0 >0A4E       	bl	    @vcursoroff			; clear cursor stuff
59    >1938=>D0A0 >F7B5       	movb   @vwidth+1,2
60    >193C=>9080             	cb     0,2				; check left coord
61    >193E=>1A01             	jl     wxlookay			; lower, okay
62    >1940=>7000             	sb     0,0				; fix to edge
63    >1942                   wxlookay:
64    >1942=>D800 >F7C2       	movb   0,@vwx			; save 
65    >1946=>B001             	ab	   1,0				; get right coord
66    >1948=>1802             	jc	   wxxover
67    >194A=>9080             	cb	   0,2				; lower or equal, okay
68    >194C=>1203             	jle    wxhiokay			
69    >194E                   wxxover:
70    >194E=>D042             	movb	2,1
71    >1950=>7060 >F7C2       	sb	    @vwx,1			; fix R1 to that width
72    >1954                   wxhiokay:
73    >1954=>D801 >F7C4       	movb	1,@vwxs
75    >1958=>06C0             	swpb	0				; point to Y 
76    >195A=>06C1             	swpb	1				; coordinates
77    >195C=>D0A0 >F7B3       	movb   @vheight, 2
79    >1960=>9080             	cb     0,2				; check top coord
80    >1962=>1201             	jle    wylookay			; lower, okay
81    >1964=>7000             	sb     0,0				; fix to edge
82    >1966                   wylookay:
83    >1966=>D800 >F7C3       	movb   0,@vwy		    ; save 
84    >196A=>B001             	ab     1,0				; get bottom coord
85    >196C=>1802             	jc     wyyover
86    >196E=>9080             	cb     0,2				; lower or equal, okay
87    >1970=>1203             	jle    wyhiokay			
88    >1972                   wyyover:
89    >1972=>D042             	movb   2,1
90    >1974=>7060 >F7C3       	sb     @vwy,1				; fix R1 to that height
91    >1978                   wyhiokay:
92    >1978=>D801 >F7C5       	movb   1,@vwys
94    >197C=>04E0 >F7CA       	clr	   @vx				; clear coords
96                                POP    SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1980=>C2FA                     mov *SP+,  11
*** term.i
97    >1982=>045B             	rt
106   >1984                   printchar PUSH  SP, 11
*** <expansion of push>
1     >1984=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1986=>C68B                     mov  11, @(1-0-1)*2(SP)
*** term.i
107   >1988=>06A0 >0A4E       	bl	    @vcursoroff			; we're movin', buddy!
109   >198C=>D801 >F7C0       	movb	1,@vch
110   >1990=>C060 >F79C       	mov	    @vdrawchar,1
111   >1994=>0411             	blwp	*1  				; print char
113   >1996=>B820 >01B9 >F7CA 	ab	    #1,@vx	     		; add a space
114   >199C=>1804             	jc	    prchwr				; carried, thus wrapped
115   >199E=>9820 >F7CA >F7C4 	cb	    @vx,@vwxs			; edge of window?
116   >19A4=>1A02             	jl	    prchout				; no, we're okay
117   >19A6                   prchwr:
118   >19A6=>06A0 >1A98       	bl	    @crlf
120   >19AA                   prchout:
121                               POP SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >19AA=>C2FA                     mov *SP+,  11
*** term.i
122   >19AC=>045B             	rt
132   >19AE                   gotoxy	PUSH SP, 11
*** <expansion of push>
1     >19AE=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >19B0=>C68B                     mov  11, @(1-0-1)*2(SP)
*** term.i
134   >19B2=>06A0 >0A4E       	bl	    @vcursoroff			; we're moving it!
136   >19B6=>9800 >F7C4       	cb	    0,@vwxs
137   >19BA=>1A04             	jl	    gxyokayx
138   >19BC=>D020 >F7C4       	movb	@vwxs,0
139   >19C0=>7020 >01B9       	sb 	    #1,0
140   >19C4                   gxyokayx:
141   >19C4=>06C0             	swpb	0
142   >19C6=>9800 >F7C5       	cb	    0,@vwys
143   >19CA=>1A04             	jl	    gxyokayy
144   >19CC=>D020 >F7C5       	movb	@vwys,0
145   >19D0=>7020 >01B9       	sb	    #1,0
146   >19D4                   gxyokayy:
147   >19D4=>06C0             	swpb	0
148   >19D6=>C800 >F7CA       	mov	    0,@vx
150                               POP     SP, 11    
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >19DA=>C2FA                     mov *SP+,  11
*** term.i
151   >19DC=>045B             	rt
164   >19DE                   termscroll
165                               PUSH    SP,11
*** <expansion of push>
1     >19DE=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >19E0=>C68B                     mov  11, @(1-0-1)*2(SP)
*** term.i
166                               
167   >19E2=>C0E0 >F7A0           mov     @vclearline, 3
169   >19E6=>D0A0 >F7C4           movb    @vwxs,2             ; length
170   >19EA=>0982                 srl     2,8
172   >19EC=>C020 >F7CA           mov     @vx,0
173   >19F0=>7000                 sb      0,0                 ; get coord for lower-left
174                               
175   >19F2=>064A                 dect    SP
176   >19F4=>C682                 mov     2,*SP
177   >19F6=>0693                 bl      *3
178                               
179   >19F8=>0580                 inc     0
180   >19FA=>06C0                 swpb    0
181   >19FC=>9800 >F7C5           cb      0,@vwys
182   >1A00=>1A01                 jl      termscroll1
183   >1A02=>7000                 sb      0,0
184   >1A04                   termscroll1
185   >1A04=>06C0                 swpb    0
186   >1A06=>C0BA                 mov     *SP+,2     
187   >1A08=>0693                 bl      *3
189                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1A0A=>C2FA                     mov *SP+,  11
*** term.i
190   >1A0C=>045B                 rt
193   >1A0E                   termclear
194                               PUSH    SP,0,2,3,11
*** <expansion of push>
1     >1A0E=>022A >FFF8           ai SP, -4*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1A12=>CA80 >0006               mov  0 , @(4-0-1)*2(SP)
2     >1A16=>CA82 >0004               mov  2 , @(4-1-1)*2(SP)
3     >1A1A=>CA83 >0002               mov  3 , @(4-2-1)*2(SP)
4     >1A1E=>C68B                     mov  11, @(4-3-1)*2(SP)
*** term.i
195   >1A20=>04C0                 clr     0
196   >1A22=>C0E0 >F7A0           mov     @vclearline,3
197   >1A26=>064A                 dect    SP
198   >1A28=>D0A0 >F7C4           movb    @vwxs,2             ; length
199   >1A2C=>0982                 srl     2,8
200   >1A2E                   termclear0
201   >1A2E=>C682                 mov     2,*SP
202   >1A30=>0693                 bl      *3
203   >1A32=>C09A                 mov     *SP,2
204   >1A34=>0580                 inc     0
205   >1A36=>06C0                 swpb    0
206   >1A38=>9800 >F7C5           cb      0,@vwys
207   >1A3C=>1302                 jeq     termclear1
208   >1A3E=>06C0                 swpb    0
209   >1A40=>10F6                 jmp     termclear0
210   >1A42                   termclear1
211   >1A42=>04E0 >F7CA           clr     @vx
212   >1A46=>05CA                 inct    SP
213                               POP     SP,0,2,3,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1A48=>C2FA                     mov *SP+,  11
2     >1A4A=>C0FA                     mov *SP+,  3 
3     >1A4C=>C0BA                     mov *SP+,  2 
4     >1A4E=>C03A                     mov *SP+,  0 
*** term.i
214   >1A50=>045B                 rt        
215                               
221   >1A52                   bksp	PUSH   SP, 1, 2, 11
*** <expansion of push>
1     >1A52=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1A56=>CA81 >0004               mov  1 , @(3-0-1)*2(SP)
2     >1A5A=>CA82 >0002               mov  2 , @(3-1-1)*2(SP)
3     >1A5E=>C68B                     mov  11, @(3-2-1)*2(SP)
*** term.i
223   >1A60=>06A0 >0A4E       	bl	@vcursoroff
225   >1A64=>D060 >F7CA       	movb	@vx,1				; get x
226   >1A68=>7060 >01B9       	sb	    #1,1				; decrement
227   >1A6C=>180F             	jc	    bksp0				; 0 -> -1?
229   >1A6E=>D060 >F7C4       	movb	@vwxs,1				; yup, move to other edge
230   >1A72=>7060 >01B9       	sb	    #1,1			
231   >1A76=>D0A0 >F7CB       	movb	@vy,2				; and decrement
232   >1A7A=>70A0 >01B9       	sb	    #1,2				; Y
233   >1A7E=>1804             	jc	    bksp1				; 0 -> -1?
234   >1A80=>D0A0 >F7C5       	movb	@vwys,2				; move to bottom
235   >1A84=>70A0 >01B9       	sb	    #1,2
236   >1A88                   bksp1	movb	2,@vy				; save
      >1A88=>D802 >F7CB       
237   >1A8C                   bksp0	movb	1,@vx				; save
      >1A8C=>D801 >F7CA       
239                               POP SP, 1, 2, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1A90=>C2FA                     mov *SP+,  11
2     >1A92=>C0BA                     mov *SP+,  2 
3     >1A94=>C07A                     mov *SP+,  1 
*** term.i
240   >1A96=>045B             	rt
247   >1A98                   crlf    PUSH    SP, 1, 11
*** <expansion of push>
1     >1A98=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1A9C=>CA81 >0002               mov  1 , @(2-0-1)*2(SP)
2     >1AA0=>C68B                     mov  11, @(2-1-1)*2(SP)
*** term.i
249   >1AA2=>06A0 >0A4E           bl      @vcursoroff         ; we're moving cursor
251   >1AA6=>7820 >F7CA >F7CA     sb      @vx,@vx             ; reset X coord
252   >1AAC=>B820 >01B9 >F7CB     ab      #1,@vy               ; next line
253   >1AB2=>1804                 jc      crlfc               ; wrapped?
254   >1AB4=>9820 >F7CB >F7C5     cb      @vy,@vwys           ; bottom of window?
255   >1ABA=>1A03                 jl      crlf0
256   >1ABC                   crlfc:
257   >1ABC=>7820 >F7CB >F7CB     sb      @vy,@vy
259   >1AC2                   crlf0:
261   >1AC2=>9820 >F7CB >F7C6     cb      @vy,@vwcy
262   >1AC8=>1305                 je      crlf1
263   >1ACA=>D820 >F7CB >F7C6     movb    @vy,@vwcy
264   >1AD0=>06A0 >19DE           bl      @termscroll
266   >1AD4                   crlf1:
267                               POP     SP, 1, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1AD4=>C2FA                     mov *SP+,  11
2     >1AD6=>C07A                     mov *SP+,  1 
*** term.i
268   >1AD8=>045B                 rt
276   >1ADA                   tab	PUSH    SP, 1, 11
*** <expansion of push>
1     >1ADA=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1ADE=>CA81 >0002               mov  1 , @(2-0-1)*2(SP)
2     >1AE2=>C68B                     mov  11, @(2-1-1)*2(SP)
*** term.i
277   >1AE4=>CA81 >0002       	mov	1,@2(SP)
278   >1AE8=>C68B             	mov	11,*SP
280   >1AEA                   tab0	li	1,>2000
      >1AEA=>0201 >2000       
281   >1AEE=>06A0 >1984       	bl	@printchar  			; print a space
282   >1AF2=>D060 >F7CA       	movb	@vx,1
283   >1AF6=>0241 >0700       	andi	1,>0700				; if not on 8-char boundary
284   >1AFA=>16F7             	jne	tab0				; repeat
286                               POP     SP, 1, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1AFC=>C2FA                     mov *SP+,  11
2     >1AFE=>C07A                     mov *SP+,  1 
*** term.i
287   >1B00=>045B             	rt
290   >1B02                   clreol  PUSH    SP, 0, 2, 3, 11
*** <expansion of push>
1     >1B02=>022A >FFF8           ai SP, -4*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1B06=>CA80 >0006               mov  0 , @(4-0-1)*2(SP)
2     >1B0A=>CA82 >0004               mov  2 , @(4-1-1)*2(SP)
3     >1B0E=>CA83 >0002               mov  3 , @(4-2-1)*2(SP)
4     >1B12=>C68B                     mov  11, @(4-3-1)*2(SP)
*** term.i
292   >1B14=>C0E0 >F7A0           mov     @vclearline, 3
294   >1B18=>D0A0 >F7C4           movb    @vwxs,2             ; length
295   >1B1C=>0982                 srl     2,8
297   >1B1E=>C020 >F7CA           mov     @vx,0
298   >1B22=>7000                 sb      0,0                 ; get coord for lower-left
299                               
300   >1B24=>0693                 bl      *3
301                               
302                               POP     SP, 0, 2, 3, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1B26=>C2FA                     mov *SP+,  11
2     >1B28=>C0FA                     mov *SP+,  3 
3     >1B2A=>C0BA                     mov *SP+,  2 
4     >1B2C=>C03A                     mov *SP+,  0 
*** term.i
303   >1B2E=>045B                 rt
304                               
311   >1B30                   emit
312   >1B30=>9801 >1053           cb      1,#>0d           ; enter?
313   >1B34=>13B1                 jeq     crlf
315   >1B36                   $1:  cb     1,#>07          ; bell?
      >1B36=>9801 >004E       
316   >1B3A=>130B                 jeq     bell
318   >1B3C                   $1:  cb     1,#>08          ; backspace?
      >1B3C=>9801 >0A0A       
319   >1B40=>1388                 jeq     bksp
321   >1B42                   $1:  cb     1,#>09          ; tab?
      >1B42=>9801 >0216       
322   >1B46=>13C9                 jeq     tab
323                               
324   >1B48                   $1: cb      1,#>0B          ; vertical tab ( == clear to end of line )
      >1B48=>9801 >002D       
325   >1B4C=>13DA                 jeq     clreol
326                                   
327   >1B4E=>0460 >1984           b       @printchar
328                               
330   >1B52                   bell:    
331   >1B52=>045B                 rt
340   >1B54                   type PUSH    SP,11
*** <expansion of push>
1     >1B54=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1B56=>C68B                     mov  11, @(1-0-1)*2(SP)
*** term.i
341   >1B58=>022A >FFFC           ai      SP,-4
342   >1B5C                   $1: mov     3,3
      >1B5C=>C0C3             
343   >1B5E=>130B                 jeq     $2+
344   >1B60=>D072                 movb    *2+,1
345   >1B62=>C682                 mov     2, *SP
346   >1B64=>CA83 >0002           mov     3, @2(SP)
347   >1B68=>06A0 >1B30           bl      @emit
348   >1B6C=>C0EA >0002           mov     @2(SP), 3
349   >1B70=>C09A                 mov     *SP, 2
350   >1B72=>0603                 dec     3
351   >1B74=>10F3                 jmp     $1-
352   >1B76                   $2: ai      SP,4
      >1B76=>022A >0004       
353                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1B7A=>C2FA                     mov *SP+,  11
*** term.i
354   >1B7C=>045B                 rt
355                           	
*** nforth.tsm
511                           	incl	dev.i
*** dev.i
29    >1B7E                   haa	byte	>aa
      >1B7E=>AA             
30    >1B7F=>00             	byte	0
32    >1B80                   dinit	li	0,>3ffe        ; steal an extra byte to avoid having DSRs wraparound
      >1B80=>0200 >3FFE       
33    >1B84=>C800 >FB70       	mov	0,@vdplimit			; set up 16k VDP RAM
35    >1B88=>02E0 >FBE0       	lwpi	cpurambase + >e0  				; be standard
36    >1B8C=>020D >FF90       	li	13,GPLRD
37    >1B90=>020E >0100       	li	14,>100
38    >1B94=>020F >FF8A       	li	15,VDPWA
40    >1B98=>020C >0F00       	li	12,>0f00			; start below first DSR
41    >1B9C                   di00	sbz	0
      >1B9C=>1E00             
42    >1B9E=>B320 >01B9       	ab	#1,12				; point to next DSR
43    >1BA2=>028C >2000       	ci	12,>2000
44    >1BA6=>1410             	jhe	diout				; done
46    >1BA8=>1D00             	sbo	0					; turn on ROM
47    >1BAA=>9820 >4000 >1B7E 	cb	@>4000,@haa			; legal rom?
48    >1BB0=>16F5             	jne	di00				; nope
50    >1BB2=>C060 >4004       	mov	@>4004,1			; get init ptr
51    >1BB6=>13F2             	jeq	di00				; none
52    >1BB8                   di01	mov	@2(1),11			; get addr for init
      >1BB8=>C2E1 >0002       
53    >1BBC=>C80C >FBD0       	mov	12,@cpurambase + >d0
54    >1BC0=>069B             	bl	*11				; call powerup routine
55    >1BC2=>C051             	mov	*1,1				; get next powerup
56    >1BC4=>16F9             	jne	di01				; if it exists
57    >1BC6=>10EA             	jmp	di00
59    >1BC8                   diout	lwpi	mainws				; restore WP
      >1BC8=>02E0 >FC00       
60    >1BCC=>045B             	rt
74    >1BCE                   noemuerr db	"No emulated disk DSR found!",>ff
      >1BCE=>4E6F >2065 >6D75 
      >1BD4=>6C61 >7465 >6420 
      >1BDA=>6469 >736B >2044 
      >1BE0=>5352 >2066 >6F75 
      >1BE6=>6E64 >21FF       
75    >1BEA=>506C >6561 >7365 	db	"Please install the emulated disk DSR",>ff
      >1BF0=>2069 >6E73 >7461 
      >1BF6=>6C6C >2074 >6865 
      >1BFC=>2065 >6D75 >6C61 
      >1C02=>7465 >6420 >6469 
      >1C08=>736B >2044 >5352 
      >1C0E=>FF             
76    >1C0F=  >62 >7920 >6164 	db	"by adding 'EmuDisk' to the DSRCombo",>ff
      >1C14=>6469 >6E67 >2027 
      >1C1A=>456D >7544 >6973 
      >1C20=>6B27 >2074 >6F20 
      >1C26=>7468 >6520 >4453 
      >1C2C=>5243 >6F6D >626F 
      >1C32=>FF             
77    >1C33=  >76 >6172 >6961 	db	"variable in FORTH.CNF.",>ff,>ff
      >1C38=>626C >6520 >696E 
      >1C3E=>2046 >4F52 >5448 
      >1C44=>2E43 >4E46 >2EFF 
      >1C4A=>FF             
78    >1C4B=  >28 >5365 >6520 	db	"(See DISKS.TXT for info.)",>ff,>ff
      >1C50=>4449 >534B >532E 
      >1C56=>5458 >5420 >666F 
      >1C5C=>7220 >696E >666F 
      >1C62=>2E29 >FFFF       
79    >1C66=>5072 >6573 >7320 	db	"Press Ctrl+Break to halt."
      >1C6C=>4374 >726C >2B42 
      >1C72=>7265 >616B >2074 
      >1C78=>6F20 >6861 >6C74 
      >1C7E=>2E             
80    >1C7F=>00             	db	0
82    >1C80                   forthdskdef db	"FORTHDSK  "
      >1C80=>464F >5254 >4844 
      >1C86=>534B >2020       
83    >1C8A                   	even
85    >1C8A                   diskinit dect	SP
      >1C8A=>064A             
86    >1C8C=>C68B             	mov	11,*SP
88    >1C8E=>02E0 >FBE0           lwpi    cpurambase + >E0           ; be standard and avoid having the ROM clobber our workspace ;)
89                                
90    >1C92=>020C >1000       	li	12,>1000			; DSR base for emulated DSR
91    >1C96=>1D00             	sbo	0				; turn on
92    >1C98=>9820 >1B7E >4000 	cb	@haa,@>4000			; installed?
93    >1C9E=>1301             	jeq	dskiokay
95                            	;li	2,noemuerr			; print error message
96                            	;b	@dieerr
97    >1CA0=>100C             	jmp dskiignore
99    >1CA2                   dskiokay:
100   >1CA2=>1E00             	sbz	0
102   >1CA4=>02E0 >FC00           lwpi    mainws          
103                               
104   >1CA8=>0200 >1C80       	li	0,forthdskdef
105   >1CAC=>0201 >F936       	li	1,forthdsk
106   >1CB0=>0202 >000A       	li	2,10
107   >1CB4                   dskifn	movb	*0+,*1+
      >1CB4=>DC70             
108   >1CB6=>0602             	dec	2
109   >1CB8=>15FD             	jgt	dskifn
111   >1CBA                   dskiignore:
112   >1CBA=>C2FA             	mov	*SP+,11
113   >1CBC=>045B             	rt
115   >1CBE                   vsbw	dect	SP
      >1CBE=>064A             
116   >1CC0=>C68B             	mov	11,*SP
117   >1CC2=>06A0 >044A       	bl	@vwaddr
118   >1CC6=>D801 >FF88       	movb	1,@VDPWD
119   >1CCA=>C2FA             	mov	*SP+,11
120   >1CCC=>045B             	rt
123   >1CCE                   vsbr	dect	SP
      >1CCE=>064A             
124   >1CD0=>C68B             	mov	11,*SP
125   >1CD2=>06A0 >044E       	bl	@vraddr
126   >1CD6=>D060 >FF80       	movb	@VDPRD,1
127   >1CDA=>C2FA             	mov	*SP+,11
128   >1CDC=>045B             	rt
131   >1CDE                   equals	db	>20
      >1CDE=>20             
132   >1CDF                   period	db	"."
      >1CDF=>2E             
145   >C000                   DSRVBASE equ >C000
147   >1CE0                   dsrlnk	data	dskws,dsrlnk+4
      >1CE0=>FC20 >1CE4       
148   >1CE4=>0300 >0000       	limi   0
149   >1CE8=>C2A0 >FC14       	mov    @mainws + 20, SP    ; use same stack as main
151   >1CEC=>0200 >C000           li      0, DSRVBASE
152   >1CF0=>D0A0 >FF6C           movb    @vpob, 2
153   >1CF4=>7802 >FF6C           sb      2, @vpob
154   >1CF8=>06A0 >166C           bl      @vsetbank          ; set VDP bank for DSR operations
155                               
156   >1CFC=>0208 >FB00           li      8,cpurambase         ; cpuram base
157                               
158   >1D00=>C16D >0002       	mov	   @2(13),5			; get offset
159   >1D04=>53E0 >1CDE       	szcb   @equals,15			; no error
160   >1D08=>C028 >0056       	mov	   @>56(8),0			; get ptr to name
161   >1D0C=>C240             	mov	   0,9				
162   >1D0E=>0229 >FFF8       	ai     9,-8				; point to error code
164   >1D12=>06A0 >1CCE       	bl     @vsbr				; get len
165   >1D16=>D0C1             	movb   1,3				; save
166   >1D18=>0983             	srl    3,8				
167   >1D1A=>0704             	seto   4				; # chars
169   >1D1C=>0202 >FB4A       	li     2,cpurambase + >4a				; buffer
170   >1D20                   dsr00	
171   >1D20=>0580                 inc     0    				; move device name
172   >1D22=>0584             	inc    4
173   >1D24=>80C4             	c      4,3
174   >1D26=>1306             	jeq    dsr01
175   >1D28=>06A0 >1CCE       	bl     @vsbr
176   >1D2C=>DC81             	movb   1,*2+
177   >1D2E=>9801 >1CDF       	cb	   1,@period
178   >1D32=>16F6             	jne	   dsr00
179   >1D34                   dsr01	
180   >1D34=>C104                 mov	   4,4				; any chars read?
181   >1D36=>1344             	jeq	   dsr09
182   >1D38=>0284 >0007       	ci	   4,7
183   >1D3C=>1541             	jgt	   dsr09				; too many?
184   >1D3E=>04E8 >00D0       	clr	   @>d0(8)
185   >1D42=>CA04 >0054       	mov    4,@>54(8)			; # chars in device name
186   >1D46=>0584             	inc	   4
187   >1D48=>AA04 >0056       	a      4,@>56(8)			; point to '.' in name
188   >1D4C=>02E0 >FBE0       	lwpi   cpurambase + >e0				; GPLWS
189   >1D50=>04C1             	clr    1				; init card counter
190   >1D52=>020C >0F00       	li     12,>f00
191   >1D56                   dsr03	
192   >1D56=>1E00                 sbz     0
193   >1D58=>022C >0100       	ai     12,>100				; start scan at >1000
194   >1D5C=>04E8 >00D0       	clr    @>d0(8)
195   >1D60=>028C >2000       	ci     12,>2000			; last base?
196   >1D64=>132B             	jeq    dsr08
197   >1D66=>CA0C >00D0       	mov    12,@>d0(8)			; store CRU
198   >1D6A=>1D00             	sbo    0				; turn on rom
199   >1D6C=>0202 >4000       	li     2,>4000
200   >1D70=>9812 >1B7E       	cb     *2,@haa				; legal rom?
201   >1D74=>16F0             	jne    dsr03
202   >1D76=>A0A0 >FC2A       	a      @dskws+10,2			; add offset
203   >1D7A=>1003             	jmp    dsr05
204   >1D7C                   dsr04	
205   >1D7C=>C0A8 >00D2           mov     @>d2(8),2
206   >1D80=>1D00             	sbo    0
207   >1D82                   dsr05	
208   >1D82=>C092                 mov	    *2,2				; any devices?
209   >1D84=>13E8             	jeq	   dsr03		    		; nope... next rom pleez
210   >1D86=>CA02 >00D2       	mov    2,@>d2(8)			; save next link
211   >1D8A=>05C2             	inct   2
212   >1D8C=>C272             	mov    *2+,9				; get routine addr
213   >1D8E=>D168 >0055       	movb   @>55(8),5			; get len of caller
214   >1D92=>1309             	jeq    dsr07				; ??? no length?
215   >1D94=>9C85             	cb     5,*2+				; match name
216   >1D96=>16F2             	jne    dsr04
217   >1D98=>0985             	srl    5,8
218   >1D9A=>0206 >FB4A       	li     6,>4a + cpurambase
219   >1D9E                   dsr06	
220   >1D9E=>9CB6                 cb      *6+,*2+
221   >1DA0=>16ED             	jne    dsr04
222   >1DA2=>0605             	dec    5
223   >1DA4=>16FC             	jne    dsr06
224   >1DA6                   dsr07	
225   >1DA6=>0581                 inc     1	    			; increment card #
226   >1DA8=>0699             	bl     *9				; run it
227   >1DAA=>10E8             	jmp    dsr04				; if no error, skip this word
228   >1DAC=>1E00             	sbz    0				; turn off rom
229   >1DAE=>02E0 >FC20       	lwpi   dskws				
230   >1DB2=>C009             	mov    9,0				; get error code (cpurambase + >F2)
231   >1DB4=>06A0 >1CCE       	bl     @vsbr
232   >1DB8=>09D1             	srl    1,13				; any error?
233   >1DBA=>1003             	jmp	   dsr10
234   >1DBC                   dsr08	
235   >1DBC=>02E0 >FC20           lwpi   dskws
236   >1DC0                   dsr09
237   >1DC0=>04C1             	clr	   1
238   >1DC2                   dsr10	
239                               ;swpb   1
240   >1DC2=>C741             	mov	    1,*13
241   >1DC4=>F3E0 >1CDE       	socb	@equals,15
242                           	
243   >1DC8=>04C0                 clr     0
244   >1DCA=>06A0 >166C           bl      @vsetbank       ; back to bank 0 for std modes
245                           	
246   >1DCE=>D802 >FF6C       	movb 2, @vpob
247   >1DD2=>0380             	rtwp
250   >1DD4                   vmbw    
251   >1DD4=>064A                 dect    SP
252   >1DD6=>C68B                 mov     11,*SP
253   >1DD8=>06A0 >044A           bl      @vwaddr
254   >1DDC                   vmbw0   
255   >1DDC=>D831 >FF88           movb    *1+,@VDPWD
256   >1DE0=>0602                 dec     2
257   >1DE2=>15FC                 jgt     vmbw0
258   >1DE4=>C2FA                 mov     *SP+,11
259   >1DE6=>045B                 rt
262   >1DE8                   vmbr    
263   >1DE8=>064A                 dect    SP
264   >1DEA=>C68B                 mov     11,*SP
265   >1DEC=>06A0 >044E           bl      @vraddr
266   >1DF0                   vmbr0   
267   >1DF0=>DC60 >FF80           movb    @VDPRD,*1+
268   >1DF4=>0602                 dec     2
269   >1DF6=>15FC                 jgt     vmbr0
270   >1DF8=>C2FA                 mov     *SP+,11
271   >1DFA=>045B                 rt
288   >1DFC                   rblockpab db    >01,>14
      >1DFC=>0114             
289   >1DFE                   wblockpab db    >01,>15
      >1DFE=>0115             
291   >1E00                   rwblock  data    dskws,rwblock + 4
      >1E00=>FC20 >1E04       
292   >1E04=>0300 >0000           limi    0
293   >1E08=>020A >F936           li      SP,dskstack + dskstacksize
295   >1E0C=>064A                 dect    SP
296   >1E0E=>D6A0 >FF6C           movb    @vpob, *SP
297                               
298   >1E12=>781A >FF6C           sb      *SP, @vpob
299   >1E16=>0200 >C000           li      0, DSRVBASE
300   >1E1A=>06A0 >166C           bl      @vsetbank          ; set VDP bank for DSR operations
302   >1E1E=>0208 >FB00           li      8, cpurambase            ; CPU RAM base
303                               
304   >1E22=>C32D >0018           mov     @24(13), 12
305                               
306   >1E26=>C028 >0070           mov     @>70(8), 0
307   >1E2A=>0220 >FC00           ai      0,-1024
308   >1E2E=>C060 >F79A           mov     @vfree, 1
309   >1E32=>0241 >3FFF           andi    1, >3FFF
310   >1E36=>8040                 c       0, 1
311   >1E38=>1403                 jhe     $0+
312                               
313   >1E3A=>D760 >0014           movb    #4, *13             ; not enough memory!
314   >1E3E=>103D                 jmp     $1+
315                                
316   >1E40                   $0:
317   >1E40=>C1C0                 mov     0, 7
318                               
319   >1E42=>0220 >FFF0           ai      0,->10
320   >1E46=>0201 >F936           li      1,forthdsk
321   >1E4A=>0202 >000A           li      2,10
322   >1E4E=>06A0 >1DD4           bl      @vmbw               ; set filename
323   >1E52=>CA00 >004E           mov     0,@>4e(8)
325   >1E56=>0203 >0004           li      3,4                 ; # secs to read/write
326   >1E5A=>C06C >0004           mov     @4(12),1            ; CPU addr
327                               
328   >1E5E=>C16C >0002           mov     @2(12),5            ; block #
329   >1E62=>0A25                 sla     5,2                 ; sector #
330                               
331   >1E64=>04C4                 clr     4
332   >1E66=>3D20 >2898           div     #360, 4             ; sector -> disk
333   >1E6A=>0584                 inc     4                   ; 0-based to 1-based
334   >1E6C=>06C4                 swpb    4
335   >1E6E=>DA04 >004C           movb    4, @>4C(8)          ; disk #
336                               
337   >1E72=>0206 >1DFE           li      6,wblockpab
338   >1E76=>C11C                 mov     *12,4
339   >1E78=>1302                 jeq     rblks
340   >1E7A=>0206 >1DFC           li      6,rblockpab
341                               
342   >1E7E                   rblks 
343   >1E7E=>DA20 >0014 >004D     movb    #4, @>4D(8)         ; four sectors
344   >1E84=>04E8 >0050           clr     @>50(8)              ; parms @>00 + rambase
346   >1E88=>C607                 mov     7,*8             ; VDP buff addr 
347   >1E8A=>CA05 >0002           mov     5,@2(8)          ; sector #
349   >1E8E=>0202 >0400           li      2,1024
350                               
351   >1E92=>C104                 mov     4,4
352   >1E94=>1603                 jne     rblks0
354   >1E96=>C007                 mov     7,0
355   >1E98=>06A0 >1DD4           bl      @vmbw               ; move block to VDP for write
356                               
357   >1E9C                   rblks0:
358   >1E9C=>06A0 >1EC6           bl      @dodsr              ; do op
359                               
360   >1EA0=>04DC                 clr     *12
361   >1EA2=>DB28 >0050 >0001     movb    @>50(8),@1(12)
362   >1EA8=>1606                 jne     rwblkerr
364   >1EAA=>C104                 mov     4,4
365   >1EAC=>1303                 jeq     wblks0
366                               
367   >1EAE=>C007                 mov     7,0
368   >1EB0=>06A0 >1DE8           bl      @vmbr               ; copy block from VDP for read
370   >1EB4                   wblks0:
371   >1EB4=>1002                 jmp     $1+
373   >1EB6                   rwblkerr movb @>50(8),*13
      >1EB6=>D768 >0050       
374   >1EBA                   $1:
375   >1EBA=>04C0                 clr     0
376   >1EBC=>06A0 >166C           bl      @vsetbank       ; back to bank 0 for std modes
377   >1EC0=>D83A >FF6C           movb    *SP+, @vpob
378                               
379   >1EC4=>0380                 rtwp
391   >1EC6                   dodsr   mov 6,@>e0+12(8) 
      >1EC6=>CA06 >00EC       
392   >1ECA=>02E0 >FBE0           lwpi    cpurambase + >e0               ; be standard
393   >1ECE=>020D >FF90           li      13,GPLRD
394   >1ED2=>020E >0100           li      14,>100
395   >1ED6=>020F >FF8A           li      15,VDPWA
397   >1EDA=>0208 >FB00           li      8,cpurambase             ; CPU RAM base
398   >1EDE=>020C >1000           li      12,>1000            ; our CRU base
399   >1EE2=>1D00                 sbo     0               ; turn it on
401   >1EE4=>0201 >400A           li      1,>400A             ; subprograms
402   >1EE8=>C051                 mov     *1,1
403   >1EEA=>1306                 jeq     dodsrerr
404   >1EEC                   dodsrfnd 
405   >1EEC=>C0A1 >0004           mov     @4(1),2             ; complete name
406   >1EF0=>8582                 c       2,*6                ; same name?
407   >1EF2=>1306                 jeq     dodsrrun
408   >1EF4=>C051                 mov     *1,1                ; get next
409   >1EF6=>16FA                 jne     dodsrfnd
411   >1EF8                   dodsrerr 
412   >1EF8=>DA20 >045D >0050     movb    #>ff,@>50(8)         ; fake error
413   >1EFE=>1006                 jmp     dodsrout
415   >1F00                   dodsrrun 
416   >1F00=>C2E1 >0002           mov     @2(1),11                ; get addr
417   >1F04=>CA0C >00D0           mov     12,@>d0(8)           ; save CRU addr
418   >1F08=>069B                 bl      *11             ; call routine
419   >1F0A=>1000                 nop                 ; error 
421   >1F0C                   dodsrout 
422   >1F0C=>020C >1000           li      12,>1000 
423   >1F10=>1E00                 sbz     0               ; turn off ROM
424                               
425   >1F12=>02E0 >FC20           lwpi    dskws
426   >1F16=>045B                 rt
427                           	
*** nforth.tsm
512                               incl    sound.i
*** sound.i
22    >1F18                   sndinit
23                                PUSH    SP, 11
*** <expansion of push>
1     >1F18=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1F1A=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
24    >1F1C=>0200 >9FBF           li     0, >9FBF
25    >1F20=>0202 >000A           li     2, 10
26    >1F24=>0201 >FFA0           li     1, SOUND
27                                
28                                ; first iter: clear out console chip;
29                                ; next four iters: clear out extra chips
30                                ;
31                                ; on each iter, send the volume off and effect off commands for each voice 
32    >1F28                   $0:    
33    >1F28=>D440                 movb   0, *1
34    >1F2A=>D840 >0002           movb   0, @2(1)
35    >1F2E=>06C0                 swpb   0
36    >1F30=>D440                 movb   0, *1
37    >1F32=>D840 >0002           movb   0, @2(1)
38    >1F36=>0200 >DFFF           li     0, >DFFF
39    >1F3A=>D440                 movb   0, *1
40    >1F3C=>D840 >0002           movb   0, @2(1)
41    >1F40=>06C0                 swpb   0
42    >1F42=>D440                 movb   0, *1
43    >1F44=>D840 >0002           movb   0, @2(1)
44    >1F48=>0642                 dect   2
45    >1F4A=>1703                 jnc	   $1+
46    >1F4C=>C062 >21AE       	mov    @snd_voice_ports(2), 1
47    >1F50=>10EB             	jmp    $0    
48    >1F52                   $1:    
49    >1F52=>04E0 >FF68           clr     @sndlist
50    >1F56=>06A0 >23C0           bl      @snd_seq_init
51                                POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1F5A=>C2FA                     mov *SP+,  11
*** sound.i
52                                
53    >1F5C=>045B                 rt
59    >1F5E                   sndfetch1
60    >1F5E=>D0F0                 movb    *0+, 3
61    >1F60=>045B                 rt
62    >1F62                   sndfetchv
63    >1F62=>0580                 inc     0
64    >1F64=>D0D4                 movb    *4, 3
65    >1F66=>045B                 rt
66                                
67                             Vector soundlist, vidws
*** <expansion of vector>
1     >1F68                   soundlist  data vidws, soundlist_entry
      >1F68=>FC60 >1F6C       
2     >1F6C                   soundlist_entry:    
*** sound.i
68                             
69                                ; check active duration
70    >1F6C=>D020 >FF6A           movb    @snddur, 0
71    >1F70=>1304                 jeq     $0+
72                               
73    >1F72=>7820 >01B9 >FF6A     sb      #1, @snddur
74    >1F78=>1623                 jne     $3+
75                                 
76    >1F7A                   $0:    
77                             
78    >1F7A=>C020 >FF68           mov     @sndlist, 0
79    >1F7E=>1320                 jeq     $3+
80                                
81    >1F80=>0202 >1F5E           li      2, sndfetch1
82                                
83    >1F84=>D060 >FF67           movb    @sndflags, 1
84    >1F88=>0A11                 sla     1, 1
85    >1F8A=>1706                 jnc     $1+
86                                
87    >1F8C=>06A0 >044E           bl      @vraddr
88    >1F90=>0204 >FF80           li      4, VDPRD
89    >1F94=>0202 >1F62           li      2, sndfetchv
90                                 
91    >1F98                   $1: 
92    >1F98=>0692                 bl      *2
93    >1F9A=>1310                 jeq     $5+         ; end of song?
94                                
95                                ; duration first
96    >1F9C=>D803 >FF6A           movb    3, @snddur
98    >1FA0                   $4:
99                                ; then a set of volumes or tones (noise must have a dummy $ff byte)
100   >1FA0=>0692                 bl      *2
101   >1FA2=>1309                 jeq     $2+         ; end of group?
102                                   
103   >1FA4=>D803 >FFA0           movb    3, @SOUND
104   >1FA8=>20E0 >1C94           coc     #>1000, 3    ; volume?
105   >1FAC=>13F9                 jeq     $4-         ; yup 
106                               
107   >1FAE=>0692                 bl      *2          ; else it was the first byte of a two-byte tone; fetch next
108   >1FB0=>D803 >FFA0           movb    3, @SOUND   
109   >1FB4=>10F5                 jmp     $4-
110                               
111   >1FB6                   $2:
112   >1FB6=>C800 >FF68           mov     0, @sndlist
113   >1FBA=>0380                 rtwp
114                               
115   >1FBC                   $5:    
116   >1FBC=>04E0 >FF68           clr     @sndlist
117   >1FC0                   $3:
118   >1FC0=>0380                 rtwp
125   >1FC2                   snd_tracks_init
126                               PUSH    SP, 11
*** <expansion of push>
1     >1FC2=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >1FC4=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
128   >1FC6=>0200 >1E00           li      r0, 30 * 256
129   >1FCA=>06A0 >200E           bl      @snd_track_tempo_to_incr
130                               
131   >1FCE=>0204 >FA00           li      r4, tracks
132   >1FD2=>04C2                 clr     r2
133   >1FD4                   $0:
134   >1FD4=>06A0 >1FE2           bl      @snd_track_init
135   >1FD8=>0284 >FA80           ci      r4, TRACKS_END
136   >1FDC=>1AFB                 jl      $0
137                               
138                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >1FDE=>C2FA                     mov *SP+,  11
*** sound.i
139   >1FE0=>045B                 rt
149   >1FE2                   snd_track_init
150   >1FE2=>CD02                 mov     r2, *r4+    ; lt_cmdptr
151   >1FE4=>04F4                 clr     *r4+        ; lt_clock
152   >1FE6=>0734                 seto    *r4+        ; lt_incr
153   >1FE8=>CD00                 mov     r0,*r4+     ; lt_tempoincr
154   >1FEA=>04F4                 clr     *r4+        ; lt_a_d, lt_s_r
155   >1FEC=>CD20 >0472           mov     #>0f00,*r4+     ; lt_volume, lt_sustain
156   >1FF0=>04F4                 clr     *r4+        ; lt_vibrato, lt_tremolo
157   >1FF2=>04F4                 clr     *r4+        ; lt_waveform, lt_balance
158   >1FF4=>045B                 rt
159                                   
164   >1FF6                   snd_track_reset
165   >1FF6=>04E4 >0008           clr     @lt_a_d(r4)  ; + s_r
166   >1FFA=>04C0                 clr     r0
167   >1FFC=>D900 >000B           movb    r0, @lt_sustain(r4)
168   >2000=>04E4 >000C           clr     @lt_vibrato(r4)  ; + lt_tremolo
169   >2004=>C900 >000E           mov     r0, @lt_waveform(r4) ; + lt_balance
170   >2008=>045B                 rt
179   >200A                   snd_track_isDone
180   >200A=>C014                 mov     @lt_cmdptr(r4), r0
181   >200C=>045B                 rt
193   >200E                   snd_track_tempo_to_incr
194   >200E=>0980                 srl     r0, 8
195   >2010=>0A20                 sla     r0, 2
196   >2012=>04C1                 clr     r1
197   >2014=>3C20 >289A           div     #3600, r0
198   >2018=>1901                 jno     $0+
199   >201A=>0700                 seto    r0 
200   >201C                   $0:    
201   >201C=>045B                 rt    
202                               
213   >201E                   snd_track_length_to_incr
214   >201E=>C0A4 >0006           mov     @lt_tempoincr(r4), r2
215   >2022=>C042                 mov     r2, r1
216   >2024=>09C1                 srl     r1, 12
217   >2026=>0A42                 sla     r2, 4    
218   >2028=>0980                 srl     r0, 8
219   >202A=>3C40                 div     r0, r1
220   >202C=>045B                 rt
231   >202E                   snd_track_note_to_hertz_16
232   >202E=>D040                 movb    r0, r1
233   >2030=>0241 >0F00           andi    r1, >0f00
234   >2034=>0971                 srl     r1, 7           ; note offset
235   >2036=>C061 >2048           mov     @snd_scale_12_tone_octave_11(r1), r1
236                               
237   >203A=>09C0                 srl     r0, 12          ; octave
238   >203C=>0500                 neg     r0
239   >203E=>0220 >0007           ai      r0, 11 - 4      ; shift
240   >2042=>1301                 jeq     $0+
241   >2044=>0901                 srl     r1, r0    
242   >2046                   $0:    
243   >2046=>045B                 rt
244                               
248   >2048                   snd_scale_12_tone_octave_11:
249   >2048=>82D0 >8A97 >92D5     dw  33488, 35479, 37589, 39824
      >204E=>9B90             
250   >2050=>A4D0 >AE9D >B8FF     dw  42192, 44701, 47359, 50175 
      >2056=>C3FF             
251   >2058=>CFA7 >DC00 >E915     dw  53159, 56320, 59669, 63217 
      >205E=>F6F1             
252   >2060=>0000 >0000 >0000     dw  0, 0, 0, 0
      >2066=>0000             
258   >2068                   snd_tracks_tick
259                                  PUSH SP, 11
*** <expansion of push>
1     >2068=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >206A=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
260                                  
261   >206C=>0204 >FA00              li   r4, tracks
262   >2070                   $0:
263   >2070=>C014                    mov  @lt_cmdptr(r4), r0
264   >2072=>1302                    jeq  $1+
265                                  
266   >2074=>06A0 >2086              bl   @snd_track_tick
267   >2078                   $1:
268   >2078=>0224 >0010              ai   r4, lt_size       
269   >207C=>0284 >FA80              ci   r4, TRACKS_END
270   >2080=>1AF7                    jl   $0-
271                                  
272                                  POP  SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >2082=>C2FA                     mov *SP+,  11
*** sound.i
273   >2084=>045B                    rt
274                               
282   >2086                   snd_track_tick
283   >2086=>A924 >0004 >0002     a       @lt_incr(r4), @lt_clock(r4)
284   >208C=>1801                 joc     $3+
285                               ;   not end of lump, continue
286   >208E=>045B                 rt
287                                   
288   >2090                   $3:
289                               PUSH    SP, 5, 11
*** <expansion of push>
1     >2090=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >2094=>CA85 >0002               mov  5 , @(2-0-1)*2(SP)
2     >2098=>C68B                     mov  11, @(2-1-1)*2(SP)
*** sound.i
290   >209A=>1004                 jmp     $1+
291                               
292   >209C                   $2:
293                               ; end of track
294   >209C=>04D4                 clr     @lt_cmdptr(r4)
295                               
296                               ; one last tick
297   >209E=>06A0 >2308           bl      @snd_voices_tick
298   >20A2=>1014                 jmp     $0+
299                                   
300   >20A4                   $1:
301   >20A4=>C154                 mov     @lt_cmdptr(r4), r5
302   >20A6=>1312                 jeq     $0+
303                               
304   >20A8=>D035                 movb    *r5+, r0
305   >20AA=>1625                 jne     $9+            ; assertion error, should be at lump
306                               
307   >20AC=>D035                 movb    *r5+, r0        ; get lump length
308   >20AE=>13F6                 jeq     $2-             ; end of track?
309                               
310   >20B0=>06A0 >201E           bl      @snd_track_length_to_incr
311                               
312                               ; length includes this tick
313   >20B4=>C901 >0004           mov     r1, @lt_incr(r4)
314   >20B8=>C901 >0002           mov     r1, @lt_clock(r4)
315                               
316   >20BC                   $2:
317   >20BC=>D035                 movb    *r5+, r0        ; next command
318   >20BE=>D040                 movb    r0, r1          ; keep R0 in case low nybble is used
319   >20C0=>09B1                 srl     r1, 11          ; hi nybble -> word offset
320   >20C2=>C061 >20D2           mov     @snd_track_commands(r1), r1
321   >20C6=>13FA                 jeq     $2-
322   >20C8=>0691                 bl      *r1
323   >20CA=>10F8                 jmp     $2-
325   >20CC                   $0: 
326                               POP     SP, 5, 11   
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >20CC=>C2FA                     mov *SP+,  11
2     >20CE=>C17A                     mov *SP+,  5 
*** sound.i
327   >20D0=>045B                 rt
328                               
329   >20D2                   snd_track_commands
330   >20D2=>20F4                 dw      snd_track_cmd_lump     ; 0
331   >20D4=>20FA                 dw      snd_track_cmd_note     ; 1
332   >20D6=>2152                 dw      snd_track_cmd_volume   ; 2
333   >20D8=>2176                 dw      snd_track_cmd_adhsr    ; 3
334   >20DA=>2164                 dw      snd_track_cmd_tempo    ; 4
335   >20DC=>218E                 dw      snd_track_cmd_vibrato  ; 5
336   >20DE=>2194                 dw      snd_track_cmd_tremolo  ; 6
337   >20E0=>219A                 dw      snd_track_cmd_waveform  ; 7
338                               ;dw      snd_track_cmd_sweep     ; 8
339   >20E2=>0000                 dw      0
340   >20E4=>21A4                 dw      snd_track_cmd_balance   ; 9 
341   >20E6=>0000 >0000 >0000     dw      0, 0, 0, 0, 0        ; A,B,C, D
      >20EC=>0000 >0000       
342   >20F0=>215C                 dw      snd_track_cmd_jump      ; E
343   >20F2=>21AA                 dw      snd_track_cmd_stop      ; F
345   >20F4                   snd_track_cmd_lump:
346                               ; done (reached the next lump)
347   >20F4=>0605                 dec     r5
348   >20F6                   $9:    
349   >20F6=>C505                 mov     r5, @lt_cmdptr(r4)
350                               
351                               ;   update the voices for this tick
352                              ; bl      @snd_voices_tick
353   >20F8=>10E9                 jmp     $0-
354                               
355   >20FA                   snd_track_cmd_note:
356                               PUSH    SP, 11
*** <expansion of push>
1     >20FA=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >20FC=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
357                               
358   >20FE=>0240 >0F00           andi    r0, >0F00
359   >2102=>D1C0                 movb    r0, r7              ; save flags
360                               
361   >2104=>D035                 movb    *r5+, r0
362                               
363   >2106=>06A0 >202E           bl      @snd_track_note_to_hertz_16
364   >210A=>C181                 mov     r1, r6              ; save hertz
365                               
366   >210C=>D035                 movb    *r5+, r0
367   >210E=>06A0 >201E           bl      @snd_track_length_to_incr
368   >2112=>C006                 mov     r6, r0
369                               
370                               PUSH    SP, 5
*** <expansion of push>
1     >2114=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >2116=>C685                     mov  5, @(1-0-1)*2(SP)
*** sound.i
371                                   
372   >2118=>D1C7                 movb    r7, r7
373   >211A=>1605                 jne     $3+                ; force noise? 
374                               
375   >211C=>0280 >0360           ci      r0, 54 * 16        ; too low?  (Note: enhanced chip!)
376   >2120=>1410                 jhe     $0+
378   >2122=>0207 >0400           li      r7, >0400           ; variable periodic noise (+1)
379   >2126                   $3:
380   >2126                   snd_track_note_noise:    
381   >2126=>0227 >FF00           ai      r7, ->0100
382                               
383   >212A=>21E0 >0018           coc     #>0300, r7
384   >212E=>1603                 jne     $1+
385                               
386                               ; variable pitch: need two voices
387   >2130=>06A0 >235C           bl      @snd_seq_alloc_noise_voices
388   >2134=>100B                 jmp     $2+
389                               
390   >2136                   $1:
391                               ; simple single noise channel    
392   >2136=>D007                 movb    r7, r0
393   >2138=>0202 >8888           li      r2, >8888          ; only a noise
394   >213C=>06A0 >2336           bl      @snd_seq_alloc_note  
396   >2140=>1005                 jmp     $2+
398   >2142                   $0:    
399   >2142=>0202 >7777           li      r2, >7777          ; any melodic voice  
400   >2146=>0940                 srl     r0, 4               ; scale to normal hertz
401   >2148=>06A0 >2336           bl      @snd_seq_alloc_note
403   >214C                   $2:    
404                               POP     SP, 5
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >214C=>C17A                     mov *SP+,  5
*** sound.i
405                               
406                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >214E=>C2FA                     mov *SP+,  11
*** sound.i
407   >2150=>045B                 rt
409   >2152                   snd_track_cmd_volume:
410   >2152=>0240 >0F00           andi    r0, >f00
411   >2156=>D900 >000A           movb    r0, @lt_volume(r4)
412   >215A=>045B                 rt
413                               
414   >215C                   snd_track_cmd_jump:
415   >215C=>D035                 movb    *r5+, r0
416   >215E=>0880                 sra     r0, 8
417   >2160=>A140                 a       r0, r5
418   >2162=>045B                 rt
419                               
420   >2164                   snd_track_cmd_tempo:
421                               PUSH    SP, 11
*** <expansion of push>
1     >2164=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >2166=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
422   >2168=>D035                 movb    *r5+, r0
423   >216A=>06A0 >200E           bl      @snd_track_tempo_to_incr
424   >216E=>C900 >0006           mov     r0, @lt_tempoincr(r4) 
425                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >2172=>C2FA                     mov *SP+,  11
*** sound.i
426   >2174=>045B                 rt
428   >2176                   snd_track_cmd_adhsr:
429                               PUSH    SP, 11
*** <expansion of push>
1     >2176=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >2178=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
430                               
431   >217A=>0240 >0F00           andi    r0, >F00
432   >217E=>D900 >000B           movb    r0, @lt_sustain(r4)
433                               
434   >2182=>D935 >0008           movb    *r5+, @lt_a_d(r4)
435   >2186=>D935 >0009           movb    *r5+, @lt_h_r(r4)
436                               
437                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >218A=>C2FA                     mov *SP+,  11
*** sound.i
438   >218C=>045B                 rt
439                               
440   >218E                   snd_track_cmd_vibrato:
441   >218E=>D935 >000C           movb    *r5+, @lt_vibrato(r4)
442   >2192=>045B                 rt
443                                   
444   >2194                   snd_track_cmd_tremolo:
445   >2194=>D935 >000D           movb    *r5+, @lt_tremolo(r4)
446   >2198=>045B                 rt
447                                   
448   >219A                   snd_track_cmd_waveform:
449   >219A=>0240 >0F00           andi    r0, >0f00
450   >219E=>D900 >000E           movb    r0, @lt_waveform(r4)
451   >21A2=>045B                 rt
452                               
453   >21A4                   snd_track_cmd_balance:
454   >21A4=>D935 >000F           movb    *r5+,@lt_balance(r4)
455   >21A8=>045B                 rt    
456                               
457   >21AA                   snd_track_cmd_stop:
458   >21AA=>0460 >1FF6           b       @snd_track_reset
460   >21AE                   snd_voice_ports
461   >21AE=>FFA2 >FFA8 >FFAE     dw      SOUND+>2, SOUND+>8, SOUND+>E, SOUND+>14
      >21B4=>FFB4             
462                               
466   >21B6                   snd_voices_init
467   >21B6=>0201 >F940           li      r1, voices
468   >21BA=>0202 >21AE           li      r2, snd_voice_ports
469   >21BE                   $0:    
470   >21BE=>0203 >8090           li      r3, >8090
471   >21C2                   $1:
472   >21C2=>04F1                 clr     *r1+        ; pv_clock
473   >21C4=>04F1                 clr     *r1+        ; pv_incr
474   >21C6=>04F1                 clr     *r1+        ; pv_hertz
475   >21C8=>04F1                 clr     *r1+        ; pv_track
476   >21CA=>CC52                 mov     *r2, *r1+   ; pv_port
477   >21CC=>CC43                 mov     r3, *r1+    ; pv_freqmask, pv_volmask
478   >21CE=>0223 >2020           ai      r3, >2020   
479   >21D2=>17F7                 jnc     $1          ; >E0F0 -> 0110
480                               
481   >21D4=>05C2                 inct    r2          ; next port
482   >21D6=>0281 >FA00           ci      r1, VOICES_END
483   >21DA=>1AF1                 jl      $0
484                               
485   >21DC=>045B                 rt
486                               
498   >21DE                   snd_voice_alloc
499                               PUSH    SP, 11
*** <expansion of push>
1     >21DE=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >21E0=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
500                               
501   >21E2=>C944 >0006           mov     r4, @pv_track(r5)
502   >21E6=>C940 >0004           mov     r0, @pv_hertz(r5)
503   >21EA=>04D5                 clr     @pv_clock(r5)
504   >21EC=>C941 >0002           mov     r1, @pv_incr(r5)
506                               ; set the effects
507   >21F0=>C0E5 >0008           mov     @pv_port(r5), r3
508   >21F4=>D0A5 >000B           movb    @pv_volmask(r5), r2
509                               
510   >21F8=>05C3                 inct    r3                  ; point to command port
511                               
512   >21FA=>D4C2                 movb    r2, *r3    ; reset
513                               
514   >21FC=>D064 >000B           movb    @lt_sustain(r4), r1     ; envelope on?
515   >2200=>1314                 jeq     $0+
516                               
517   >2202=>D002                 movb    r2, r0
518   >2204=>0260 >0100           ori     r0, >0100           ; envelope/sustain command
519   >2208=>D4C0                 movb    r0, *r3
521   >220A=>D8C1 >0002           movb    r1, @2(r3)          ; sustain amount
522                                   
523   >220E=>D002                 movb    r2, r0
524   >2210=>0260 >0200           ori     r0, >0200           ; envelope attack/decay command
525   >2214=>D4C0                 movb    r0, *r3
527   >2216=>D8E4 >0008 >0002     movb    @lt_a_d(r4), @2(r3) ; values
529   >221C=>D002                 movb    r2, r0
530   >221E=>0260 >0300           ori     r0, >0300           ; envelope hold/release command
531   >2222=>D4C0                 movb    r0, *r3
533   >2224=>D8E4 >0009 >0002     movb    @lt_h_r(r4), @2(r3) ; values
535   >222A                   $0:    
536   >222A=>D024 >000C           movb    @lt_vibrato(r4), r0     ; vibrato on?
537   >222E=>1306                 jeq     $0+
538                              
539   >2230=>D042                 movb    r2, r1
540   >2232=>0261 >0400           ori     r1, >0400           ; vibrato command
541   >2236=>D4C1                 movb    r1, *r3
542                               
543   >2238=>D8C0 >0002           movb    r0, @2(r3) ; values
544                                
545   >223C                   $0:    
546   >223C=>D024 >000D           movb    @lt_tremolo(r4), r0     ; tremolo on?
547   >2240=>1306                 jeq     $0+
548                              
549   >2242=>D042                 movb    r2, r1
550   >2244=>0261 >0500           ori     r1, >0500           ; tremolo command
551   >2248=>D4C1                 movb    r1, *r3
552                               
553   >224A=>D8C0 >0002           movb    r0, @2(r3) ; values
554                                
555   >224E                   $0:    
556   >224E=>D024 >000E           movb    @lt_waveform(r4), r0     ; custom waveform
557   >2252=>1306                 jeq     $0+
558                              
559   >2254=>D042                 movb    r2, r1
560   >2256=>0261 >0600           ori     r1, >0600           ; waveform command
561   >225A=>D4C1                 movb    r1, *r3
562                               
563   >225C=>D8C0 >0002           movb    r0, @2(r3) ; values
565   >2260                   $0:    
566   >2260=>D024 >000F           movb    @lt_balance(r4), r0     ; balance
567                               
568   >2264=>D042                 movb    r2, r1
569   >2266=>0261 >0900           ori     r1, >0900
570   >226A=>D4C1                 movb    r1, *r3
571                               
572   >226C=>D8C0 >0002           movb    r0, @2(r3)  ; value
573                               
574   >2270=>06A0 >227C           bl      @snd_voice_apply2
575                               
576                               POP     SP,11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >2274=>C2FA                     mov *SP+,  11
*** sound.i
577   >2276=>045B                 rt
578                                
586   >2278                   snd_voice_apply
587   >2278=>C125 >0006           mov     @pv_track(r5), r4
588   >227C                   snd_voice_apply2
589   >227C=>D0A5 >000A           movb    @pv_freqmask(r5), r2
590   >2280=>90A0 >0079           cb      #>E0, r2
591   >2284=>1606                 jne     $0+
592                              
593                               ; noise
594   >2286=>F0A5 >0004           socb    @pv_hertz(r5), r2
595   >228A=>C065 >0008           mov     @pv_port(r5), r1
596   >228E=>D442                 movb    r2, *r1
597   >2290=>1010                 jmp     $1+
598                                 
599   >2292                   $0:    
600   >2292=>0200 >0001           li      r0, >1
601   >2296=>0201 >B4F4           li      r1, >B4F4
602   >229A=>3C25 >0004           div     @pv_hertz(r5), r0
603   >229E=>C065 >0008           mov     @pv_port(r5), r1
604                               
605                               ; R0 is, say >3F9.  We write >89 >3F
606   >22A2=>C0C0                 mov     r0, r3
607   >22A4=>0A43                 sla     r3, 4       ; get lo byte
608   >22A6=>06C0                 swpb    r0
609   >22A8=>0240 >0F00           andi    r0, >0f00
610   >22AC=>F002                 socb    r2, r0
611   >22AE=>D440                 movb    r0, *r1
612   >22B0=>D443                 movb    r3, *r1
613   >22B2                   $1:    
614   >22B2=>D024 >000A           movb    @lt_volume(r4), r0
615                               
616   >22B6=>C0A5 >0002           mov     @pv_incr(r5), r2      ; tone voices for noise are silent
617   >22BA=>1609                 jne     $1+
618                               
619                               ; write pan for noise too
620   >22BC=>D024 >000F           movb    @lt_balance(r4), r0
621   >22C0=>D860 >289C >0002     movb    #>f9, @2(r1)
622   >22C6=>D840 >0004           movb    r0, @4(r1)
623                               
624   >22CA=>0200 >0F00           li      r0, >F00
625                               
626   >22CE                   $1:  
627   >22CE=>F025 >000B           socb    @pv_volmask(r5), r0
628   >22D2=>D440                 movb    r0, *r1
629   >22D4=>045B                 rt
637   >22D6                   snd_voice_tick:
638   >22D6=>C0A5 >0002           mov     @pv_incr(r5), r2      ; do nothing if inactive (or claimed by noise)
639   >22DA=>1315                 jeq     $0+
640                               
641   >22DC=>A542                 a       r2, @pv_clock(r5)
642   >22DE=>1713                 jnc     $1+
643                               
644                               ; end of note
645                               ; write "volume off" or key release to command port
646   >22E0=>0200 >0F00           li      r0, >0F00
647   >22E4=>F025 >000B           socb    @pv_volmask(r5), r0
648   >22E8=>C065 >0008           mov     @pv_port(r5), r1
649   >22EC=>D0A4 >000B           movb    @lt_sustain(r4), r2
650   >22F0=>1301                 jeq     $2+
651                               
652   >22F2=>05C1                 inct    r1          ; send key off command rather than volume off
653                               
654   >22F4                   $2: 
655   >22F4=>D440                 movb    r0, *r1
657   >22F6=>04E5 >0006           clr     @pv_track(r5)
658                               
659                               ; was it a noise?
660   >22FA=>9960 >0079 >000A     cb      #>E0, @pv_freqmask(r5)
661   >2300=>1602                 jne     $0+
662                               
663                               ; if so, the previous was ours too
664   >2302=>04E5 >FFFA           clr     @pv_track - pv_size(r5)
666   >2306                   $0:
667   >2306                   $1:
668   >2306=>045B                 rt
674   >2308                   snd_voices_tick:
675                               PUSH    SP, 4, 5, 11
*** <expansion of push>
1     >2308=>022A >FFFA           ai SP, -3*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >230C=>CA84 >0004               mov  4 , @(3-0-1)*2(SP)
2     >2310=>CA85 >0002               mov  5 , @(3-1-1)*2(SP)
3     >2314=>C68B                     mov  11, @(3-2-1)*2(SP)
*** sound.i
676   >2316=>0205 >F940           li      r5, voices
677   >231A                   $0:
678   >231A=>C125 >0006           mov     @pv_track(r5), r4
679   >231E=>1302                 jeq     $1+
680   >2320=>06A0 >22D6           bl      @snd_voice_tick
681   >2324                   $1:    
682   >2324=>0225 >000C           ai      r5, pv_size
683   >2328=>0285 >FA00           ci      r5, VOICES_END
684   >232C=>1AF6                 jl      $0
685                               POP     SP, 4, 5, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >232E=>C2FA                     mov *SP+,  11
2     >2330=>C17A                     mov *SP+,  5 
3     >2332=>C13A                     mov *SP+,  4 
*** sound.i
686   >2334=>045B                 rt
700   >2336                   snd_seq_alloc_note
701                               PUSH    SP, 11
*** <expansion of push>
1     >2336=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >2338=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
702   >233A=>0205 >F940           li      r5, voices
703   >233E                   $0:
704   >233E=>0912                 srl     r2, 1           ; allowed voice?
705   >2340=>1706                 jnc     $2+
706                               
707   >2342=>C2E5 >0006           mov     @pv_track(r5), r11   ; already in use?
708   >2346=>1603                 jne     $2+
710   >2348=>06A0 >21DE           bl      @snd_voice_alloc
711   >234C=>1005                 jmp     $1+
712                               
713   >234E                   $2:
714   >234E=>0225 >000C           ai      r5, pv_size
715   >2352=>0285 >FA00           ci      r5, VOICES_END
716   >2356=>1AF3                 jl      $0-
717                               
718                               ; no voice allocated
719                               
720   >2358                   $1:
721                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >2358=>C2FA                     mov *SP+,  11
*** sound.i
722   >235A=>045B                 rt
735   >235C                   snd_seq_alloc_noise_voices
736                               PUSH    SP, 11
*** <expansion of push>
1     >235C=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >235E=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
737                               
738   >2360=>C080                 mov     r0, r2
739   >2362=>0942                 srl     r2, 4              ; get pitch*15/16
740   >2364=>6002                 s       r2, r0
741   >2366=>0202 >4444           li      r2, >4444          ; only a voice 2
742   >236A=>C181                 mov     r1, r6             ; save length
743   >236C=>04C1                 clr     r1                 ; not a real note
744   >236E=>06A0 >2336           bl      @snd_seq_alloc_note  
746                               ; take the next voice for noise
747   >2372=>0225 >000C           ai      r5, pv_size
748                               
749   >2376=>D007                 movb    r7, r0
750   >2378=>C046                 mov     r6, r1             ; restore length
751   >237A=>0202 >8888           li      r2, >8888          ; only a noise 
752                               
753   >237E=>06A0 >21DE           bl      @snd_voice_alloc
754                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >2382=>C2FA                     mov *SP+,  11
*** sound.i
755   >2384=>045B                 rt
756                               
763   >2386                   snd_song_tick:
764   >2386=>C156                 mov     @ls_phrase(6), 5
765   >2388=>1606                 jne     $0+
766                               
767                               ; moving to next phrase
768   >238A=>C1E6 >0002           mov     @ls_phrases(6), 7
769   >238E=>C177                 mov     *7+, 5
770   >2390=>C585                 mov     5, @ls_phrase(6)
771   >2392=>C987 >0002           mov     7, @ls_phrases(6)
773                               ;...
775   >2396                   $0:
776   >2396=>045B                  rt   
777                               
781   >2398                   snd_seq_tick    
782                               ;dbg
783                               PUSH    SP, 11
*** <expansion of push>
1     >2398=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >239A=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
784                               
785   >239C=>06A0 >2308           bl      @snd_voices_tick
786                               
787                               ; for now
788   >23A0=>06A0 >2068           bl      @snd_tracks_tick
790                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >23A4=>C2FA                     mov *SP+,  11
*** sound.i
791                               ;dbgf     
792                               
793   >23A6=>045B                 rt
796                               ; step through songs and tick them
797   >23A8=>0206 >FA80           li      6, songs
798   >23AC                   $0:
799   >23AC=>C056                 mov     *6, 1
800   >23AE=>1302                 jeq     $1+
801                               
802   >23B0=>06A0 >2386           bl      @snd_song_tick
803   >23B4                   $1:  
804   >23B4=>05C6                 inct    6
805   >23B6=>0286 >FAA0           ci      6, SONGS_END
806   >23BA=>16F8                 jne     $0-
807                               
808                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >23BC=>C2FA                     mov *SP+,  11
*** sound.i
809                               ;dbgf     
810                               
811   >23BE=>045B                 rt
813   >23C0                   snd_seq_init
814                               ;dbg
815                               PUSH    SP, 11
*** <expansion of push>
1     >23C0=>064A                 ai SP, -1*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >23C2=>C68B                     mov  11, @(1-0-1)*2(SP)
*** sound.i
816   >23C4=>06A0 >1FC2           bl      @snd_tracks_init
817   >23C8=>06A0 >21B6           bl      @snd_voices_init
818                                   
819   >23CC=>0200 >2520           li      r0, test_track
820                               ;mov     r0, @tracks + lt_cmdptr         ;;; auto start
821                               
822                               POP     SP, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >23D0=>C2FA                     mov *SP+,  11
*** sound.i
823                               ;dbgf
824   >23D2=>045B                 rt
826                            Vector sound_sequencer, vidws
*** <expansion of vector>
1     >23D4                   sound_sequencer  data vidws, sound_sequencer_entry
      >23D4=>FC60 >23D8       
2     >23D8                   sound_sequencer_entry:    
*** sound.i
827   >23D8=>020A >F740           li      SP, vstack + vstacksize
828   >23DC=>06A0 >2398           bl      @snd_seq_tick
829   >23E0=>0380                 rtwp    
835   >23E2                   xsnd_queue_track:
836                               PUSH    SP, 4, 11
*** <expansion of push>
1     >23E2=>022A >FFFC           ai SP, -2*2
2                                 foreach REG, IDX {
*** <expansion of foreach>
1     >23E6=>CA84 >0002               mov  4 , @(2-0-1)*2(SP)
2     >23EA=>C68B                     mov  11, @(2-1-1)*2(SP)
*** sound.i
837   >23EC=>0204 >FA00           li      4, tracks
838   >23F0                   $0:
839   >23F0=>C514                 mov     @lt_cmdptr(4), @lt_cmdptr(4)
840   >23F2=>1308                 jeq     $1+
842   >23F4=>0224 >0010           ai      4, lt_size
843   >23F8=>0284 >FA80           ci      4, TRACKS_END
844   >23FC=>1AF9                 jl      $0
845   >23FE                   $2:
846                               POP     SP, 4, 11
*** <expansion of pop>
1                                 foreach - REG, IDX {
*** <expansion of foreach>
1     >23FE=>C2FA                     mov *SP+,  11
2     >2400=>C13A                     mov *SP+,  4 
*** sound.i
847   >2402=>045B                 rt
848   >2404                   $1:
849                               ; assign
850   >2404=>0200 >1E00           li      r0, 30 * 256
851   >2408=>06A0 >200E           bl      @snd_track_tempo_to_incr
852                               
853   >240C=>06A0 >1FE2           bl      @snd_track_init    
854   >2410=>10F6                 jmp     $2-
855                              
856                               
857   >2412                   test_track0:
858   >2412=>0010 >28           db      >00, 16,  >28
859   >2415=  >00 >1010 >400A     db      >00, 16,  >10, >40, 10
860   >241A=>0010 >1044 >0A     db      >00, 16,  >10, >44, 10
861   >241F=  >00 >1010 >470A     db      >00, 16,  >10, >47, 10
862   >2424=>0040 >1040 >3C10     db      >00, 64,  >10, >40, 60,  >10, >44, 60,  >10, >47, 60,  >10, >50, 60
      >242A=>443C >1047 >3C10 
      >2430=>503C             
863   >2432=>0010                 db      >00, 16
864   >2434=>0001 >4028           db      >00, 1,   >40, 40
865   >2438=>000F >1000 >0F10     db      >00, 15,  >10, >00, 15,     >10, >10, 15
      >243E=>100F             
866   >2440=>000F >1003 >0F10     db      >00, 15,  >10, >03, 15,     >10, >13, 15
      >2446=>130F             
867   >2448=>000F >1005 >0F10     db      >00, 15,  >10, >05, 15,     >10, >15, 15
      >244E=>150F             
868   >2450=>000F >1007 >0F10     db      >00, 15,  >10, >07, 15,     >10, >17, 15
      >2456=>170F             
869   >2458=>000F >1009 >0F10     db      >00, 15,  >10, >09, 15,     >10, >19, 15
      >245E=>190F             
870   >2460=>000F >100B >0F10     db      >00, 15,  >10, >0B, 15,     >10, >1B, 15
      >2466=>1B0F             
871   >2468=>000F >1011 >0F10     db      >00, 15,  >10, >11, 15,     >10, >21, 15
      >246E=>210F             
872   >2470=>000F >1014 >0F10     db      >00, 15,  >10, >14, 15,     >10, >24, 15
      >2476=>240F             
873   >2478=>000F >1017 >0F10     db      >00, 15,  >10, >17, 15,     >10, >27, 15
      >247E=>270F             
874   >2480=>000F >101A >0F10     db      >00, 15,  >10, >1A, 15,     >10, >2A, 15
      >2486=>2A0F             
875   >2488=>000F >1022 >0F10     db      >00, 15,  >10, >22, 15,     >10, >32, 15
      >248E=>320F             
876   >2490=>000F >1025 >0F10     db      >00, 15,  >10, >25, 15,     >10, >35, 15
      >2496=>350F             
877   >2498=>000F >1028 >0F10     db      >00, 15,  >10, >28, 15,     >10, >38, 15
      >249E=>380F             
878   >24A0=>000F >1030 >0F10     db      >00, 15,  >10, >30, 15,     >10, >40, 15
      >24A6=>400F             
879   >24A8=>000F >1033 >0F10     db      >00, 15,  >10, >33, 15,     >10, >43, 15
      >24AE=>430F             
880   >24B0=>0000                 db      >00, 0
882   >24B2                   test_track1:
883   >24B2=>0010 >2F40 >FF     db      >00, 16, >2F, >40, 255
884   >24B7                   tt0:    
885   >24B7=  >00 >0110 >4020     db      >00, 1, >10, >40, 32,  >10, >50, 32,  >10, >60, 32 
      >24BC=>1050 >2010 >6020 
886   >24C2=>0001 >2E           db      >00, 1, >2E
887   >24C5=  >00 >012D           db      >00, 1, >2D
888   >24C8=>0001 >2C           db      >00, 1, >2C
889   >24CB=  >00 >012B           db      >00, 1, >2B
890   >24CE=>0001 >2A           db      >00, 1, >2A
891   >24D1=  >00 >0129           db      >00, 1, >29
892   >24D4=>0001 >28           db      >00, 1, >28
893   >24D7=  >00 >0127           db      >00, 1, >27
894   >24DA=>0001 >26           db      >00, 1, >26
895   >24DD=  >00 >0125           db      >00, 1, >25
896   >24E0=>0001 >24           db      >00, 1, >24
897   >24E3=  >00 >0123           db      >00, 1, >23
898   >24E6=>0001 >22           db      >00, 1, >22
899   >24E9=  >00 >0121           db      >00, 1, >21
900   >24EC=>0001 >20           db      >00, 1, >20
901   >24EF=  >00 >0121           db      >00, 1, >21
902   >24F2=>0001 >22           db      >00, 1, >22
903   >24F5=  >00 >0123           db      >00, 1, >23
904   >24F8=>0001 >24           db      >00, 1, >24
905   >24FB=  >00 >0125           db      >00, 1, >25
906   >24FE=>0001 >26           db      >00, 1, >26
907   >2501=  >00 >0127           db      >00, 1, >27
908   >2504=>0001 >28           db      >00, 1, >28
909   >2507=  >00 >0129           db      >00, 1, >29
910   >250A=>0001 >2A           db      >00, 1, >2A
911   >250D=  >00 >012B           db      >00, 1, >2B
912   >2510=>0001 >2C           db      >00, 1, >2C
913   >2513=  >00 >012D           db      >00, 1, >2D
914   >2516=>0001 >2E           db      >00, 1, >2E
915   >2519=  >00 >012F           db      >00, 1, >2F
916   >251C=>0001 >E0           db      >00, 1, >E0
917   >251F=>99                 db      tt0 - $ + 1
918                               
919   >2520                   test_track:
920                               ; track volume = 8, ADSR = ...
921   >2520=>0010 >2840 >20     db      >00, 16 ,  >28 ,  >40, 32
922   >2525=  >38 >332D >5044     db		  	>38,  >33, >2D ,  >50, >44 , >60, >44 ;
      >252A=>6044             
923   >252C=>7110 >2004           db			>71, >10, >20, 4
924   >2530=>0010                 db      >00, 16 
925   >2532=>0010 >1030 >08     db      >00, 16, >10, >30, 8
926   >2537=  >00 >10           db      >00, 16 
927   >2539=  >00 >1010 >4010     db      >00, 16, >10, >40, 16
928   >253E=>0010                 db      >00, 16 
929   >2540=>0020 >1051 >20     db      >00, 32, >10, >51, 32
930   >2545=  >00 >10           db      >00, 16
931   >2547=  >00 >4010 >6240     db      >00, 64, >10, >62, 64
932   >254C=>0010 >9080           db      >00, 16,   >90, >80
933   >2550=>0019 >1000 >0F10     db      >00, 25,  >10, >00, 15,     >10, >10, 15,   >90, >98
      >2556=>100F >9098       
934   >255A=>0019 >1003 >0F10     db      >00, 25,  >10, >03, 15,     >10, >13, 15
      >2560=>130F             
935   >2562=>0019 >1005 >0F10     db      >00, 25,  >10, >05, 15,     >10, >15, 15,   >90, >b0
      >2568=>150F >90B0       
936   >256C=>0019 >1007 >0F10     db      >00, 25,  >10, >07, 15,     >10, >17, 15,    >40, 40
      >2572=>170F >4028       
937   >2576=>0019 >1009 >0F10     db      >00, 25,  >10, >09, 15,     >10, >19, 15,   >90, >c0
      >257C=>190F >90C0       
938   >2580=>0019 >100B >0F10     db      >00, 25,  >10, >0B, 15,     >10, >1B, 15
      >2586=>1B0F             
939   >2588=>0019 >1011 >0F10     db      >00, 25,  >10, >11, 15,     >10, >21, 15,     >40, 48,   >90, >f0
      >258E=>210F >4030 >90F0 
940   >2594=>0019 >1014 >0F10     db      >00, 25,  >10, >14, 15,     >10, >24, 15
      >259A=>240F             
941   >259C=>0019 >1017 >0F10     db      >00, 25,  >10, >17, 15,     >10, >27, 15,   >90, >00
      >25A2=>270F >9000       
942   >25A6=>0019 >101A >0F10     db      >00, 25,  >10, >1A, 15,     >10, >2A, 15,    >40, 52    
      >25AC=>2A0F >4034       
943   >25B0=>0019 >1022 >0F10     db      >00, 25,  >10, >22, 15,     >10, >32, 15,   >90, >20
      >25B6=>320F >9020       
944   >25BA=>0019 >1025 >0F10     db      >00, 25,  >10, >25, 15,     >10, >35, 15
      >25C0=>350F             
945   >25C2=>0019 >1028 >0F10     db      >00, 25,  >10, >28, 15,     >10, >38, 15,    >40, 60,   >90, >30
      >25C8=>380F >403C >9030 
946   >25CE=>0019 >1030 >0F10     db      >00, 25,  >10, >30, 15,     >10, >40, 15,   >90, >40
      >25D4=>400F >9040       
947   >25D8=>0019 >1033 >0F10     db      >00, 25,  >10, >33, 15,     >10, >43, 15
      >25DE=>430F             
948   >25E0=>0019 >1036 >0F10     db      >00, 25,  >10, >36, 15,     >10, >46, 15,    >40, 64,   >90, >50
      >25E6=>460F >4040 >9050 
949   >25EC=>0019 >1039 >0F10     db      >00, 25,  >10, >39, 15,     >10, >49, 15
      >25F2=>490F             
950   >25F4=>0019 >103B >0F10     db      >00, 25,  >10, >3B, 15,     >10, >4B, 15,   >90, >60
      >25FA=>4B0F >9060       
951   >25FE=>0019 >1042 >0F10     db      >00, 25,  >10, >42, 15,     >10, >52, 15,    >40, 68,   >90, >70
      >2604=>520F >4044 >9070 
952   >260A=>0019 >1045 >0F10     db      >00, 25,  >10, >45, 15,     >10, >55, 15,   >90, >7f
      >2610=>550F >907F       
953   >2614=>0019 >1048 >0F10     db      >00, 25,  >10, >48, 15,     >10, >58, 15
      >261A=>580F             
954   >261C=>0000                 db      >00, >00
955                               
956   >261E                   test_track4:
957                               ; track volume = 8, ADSR = ...
958   >261E=>0010 >2040 >20     db      >00, 16,  >20,  >40, 32  
959   >2623=  >38 >D42C           db       >38, >D4, >2C  
960   >2626=>5044 >6044           db       >50, >44 , >60, >44 ;
961   >262A                   tt1:    
962                              
963   >262A=>000A >7010 >350F     db      >00, 10,  >70,  >10, >35, 15  ;,     >10, >45, 15
964   >2630=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >33, 15
      >2636=>330F             
965   >2638=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
966   >263D=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
967   >2642=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
968   >2647=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
969   >264C=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
970   >2651=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
971   >2656=>0014                 db      >00, 20
973   >2658=>000A >7410 >350F      db      >00, 10,  >74,  >10, >35, 15  ;,     >10, >45, 15
974   >265E=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >53, 15
      >2664=>530F             
975   >2666=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
976   >266B=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
977   >2670=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
978   >2675=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
979   >267A=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
980   >267F=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
981   >2684=>0014                 db      >00, 20
982                               
983                               
984                            
985   >2686=>000A >7110 >350F       db      >00, 10,  >71,  >10, >35, 15  ;,     >10, >45, 15
986   >268C=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >53, 15
      >2692=>530F             
987   >2694=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
988   >2699=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
989   >269E=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
990   >26A3=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
991   >26A8=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
992   >26AD=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
993   >26B2=>0014                 db      >00, 20
994                               
995                               
996                            
997   >26B4=>000A >7610 >350F    db      >00, 10,  >76,  >10, >35, 15  ;,     >10, >45, 15
998   >26BA=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >33, 15
      >26C0=>330F             
999   >26C2=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
1000  >26C7=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
1001  >26CC=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
1002  >26D1=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
1003  >26D6=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
1004  >26DB=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
1005  >26E0=>0014                 db      >00, 20
1006                              
1007  >26E2=>000A >7210 >350F   db      >00, 10,  >72,  >10, >35, 15  ;,     >10, >45, 15
1008  >26E8=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >33, 15
      >26EE=>330F             
1009  >26F0=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
1010  >26F5=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
1011  >26FA=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
1012  >26FF=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
1013  >2704=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
1014  >2709=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
1015  >270E=>0014                 db      >00, 20    
1017                           
1018                              
1019  >2710=>000A >7310 >350F     db      >00, 10,  >73,  >10, >35, 15  ;,     >10, >45, 15
1020  >2716=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >53, 15
      >271C=>530F             
1021  >271E=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
1022  >2723=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
1023  >2728=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
1024  >272D=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
1025  >2732=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
1026  >2737=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
1027  >273C=>0014                 db      >00, 20    
1028                            
1029  >273E=>000A >7510 >350F     db      >00, 10,  >75,  >10, >35, 15  ;,     >10, >45, 15
1030  >2744=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >53, 15
      >274A=>530F             
1031  >274C=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
1032  >2751=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
1033  >2756=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
1034  >275B=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
1035  >2760=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
1036  >2765=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
1037  >276A=>0014                 db      >00, 20
1038                              
1039  >276C=>000A >7710 >350F     db      >00, 10,  >77,  >10, >35, 15  ;,     >10, >45, 15
1040  >2772=>000A >1043 >0F10     db      >00, 10,  >10, >43, 15,     >10, >33, 15
      >2778=>330F             
1041  >277A=>000F >1048 >0F       db      >00, 15,  >10, >48, 15
1042  >277F=  >00 >0F10 >530F     db      >00, 15,  >10, >53, 15
1043  >2784=>000F >1058 >0F     db      >00, 15,  >10, >58, 15
1044  >2789=  >00 >0F10 >630F     db      >00, 15,  >10, >63, 15
1045  >278E=>000F >1068 >0F     db      >00, 15,  >10, >68, 15
1046  >2793=  >00 >0F10 >730F     db      >00, 15,  >10, >73, 15
1047  >2798=>0014                 db      >00, 20
1048                              
1049  >279A=>0001 >E0           db      >00, 01, >E0
1050  >279D=>8C                 db      tt1 - $ - 1
1051  >279E=>0000                 db      >00, >00
1052  >27A0                       even
1053                                  
1054  >27A0                   test_track5:
1055  >27A0=>0010 >2840 >20     db      >00, 16,  >28,  >40, 32
1056                              ;db      >00, 25,  >10, >00, 15
1057                              ;db      >00, 25,  >10, >04, 15
1058                              ;db      >00, 25,  >10, >08, 15
1059                              
1060                              ;db       >60, >44
1061  >27A5=  >38 >233A           db       >38, >23, >3A
1062                              
1063  >27A8=>0008 >1413 >01     db      >00, 8,  >14, >13, 1
1064                              ;db      >00, 8,  >14, >13, 1
1065                              ;db      >00, 8,  >14, >13, 1
1066                              ;db      >00, 8,  >14, >13, 1
1067  >27AD=  >00 >0814 >2501     db      >00, 8,  >14, >25, 1
1068                              ;db      >00, 8,  >14, >25, 1
1069                              ;db      >00, 8,  >14, >25, 1
1070                              ;db      >00, 8,  >14, >25, 1
1071  >27B2=>0008 >1435 >01     db      >00, 8,  >14, >35, 1
1072                              ;db      >00, 8,  >14, >35, 1
1073                              ;db      >00, 8,  >14, >35, 1
1074                              ;db      >00, 8,  >14, >35, 1
1075  >27B7=  >00 >19           db      >00, 25
1076  >27B9=  >00 >0815 >5305     db      >00, 8,  >15, >53, 5
1077  >27BE=>0008 >1643 >05     db      >00, 8,  >16, >43, 5
1078  >27C3=  >00 >0817 >3305     db      >00, 8,  >17, >33, 5
1079                              
1080  >27C8=>0008 >1853 >01     db      >00, 8,  >18, >53, 1
1081  >27CD=  >00 >0818 >5302     db      >00, 8,  >18, >53, 2
1082  >27D2=>0008 >1853 >03     db      >00, 8,  >18, >53, 3
1083  >27D7=  >00 >0818 >5304     db      >00, 8,  >18, >53, 4
1084  >27DC=>0008 >1863 >01     db      >00, 8,  >18, >63, 1
1085  >27E1=  >00 >0818 >6302     db      >00, 8,  >18, >63, 2
1086  >27E6=>0008 >1863 >03     db      >00, 8,  >18, >63, 3
1087  >27EB=  >00 >0818 >6304     db      >00, 8,  >18, >63, 4
1088  >27F0=>0008 >1873 >01     db      >00, 8,  >18, >73, 1
1089  >27F5=  >00 >0818 >7302     db      >00, 8,  >18, >73, 2
1090  >27FA=>0008 >1873 >03     db      >00, 8,  >18, >73, 3
1091  >27FF=  >00 >0818 >7304     db      >00, 8,  >18, >73, 4
1092  >2804=>0019                 db      >00, 25
1093  >2806=>0000                 db      >00, >00
1094  >2808                              even
1095                               
1096                               ; good snareish      
1097                              ;db       >34, >14, >88
1098                              ; db      >00, 8,  >18, >83, 2
1101                                  
*** nforth.tsm
514   >2808                   reset:   limi	0
      >2808=>0300 >0000       
515                               ;   clear memory
516   >280C=>06A0 >0246           bl      @clr
517   >2810=>F780 >0320           data    _RAMSTART, _RAMEND - _RAMSTART
518                            #if ENHANCED_MEMORY
519                            #else    
524   >2814=>06A0 >0252       	bl	@sinit			; system init
525   >2818=>06A0 >1F18           bl  @sndinit        ; sound init
526   >281C=>06A0 >031E       	bl	@vinit			; video init
527   >2820=>06A0 >178E       	bl	@kinit			; keyboard init
528   >2824=>06A0 >1B80       	bl	@dinit			; device init
530   >2828=>06A0 >1C8A       	bl	@diskinit		; disk init
532   >282C                   boot:	clr	12
      >282C=>04CC             
533   >282E=>1E00             	sbz	0			; Interrupt mode
534   >2830=>1D01             	sbo	1			; Enable external interrupts
535   >2832=>1D02             	sbo	2			; Enable VDP interrupts
536   >2834=>1E03             	sbz	3			; Disable clock interrupts
538                            #if ENHANCED_MEMORY
539                            
540                            #else
555   >2836                   boot0:
556                           	; see if we have GROM extension
557   >2836=>0200 >6000       	li 0, >6000
558   >283A=>06A0 >043C       	bl @gwaddr
560   >283E=>06A0 >2846       	bl @copyram
562   >2842                   boot1:
563   >2842=>0460 >0060       	b	@FORTH_COLD
572   >2846                   copyram 
573   >2846=>0300 >0000           limi 0
574   >284A=>0203 >FF90           li  3, GPLRD
575   >284E                   cr0:    
576   >284E=>D013             	movb *3, 0
577   >2850=>06C0             	swpb 0
578   >2852=>D013             	movb *3, 0
579   >2854=>06C0             	swpb 0			; R1 = start addr in RAM
580   >2856=>0280 >AA55       	ci 0, >aa55
581   >285A=>1610             	jne cr1			; no GROM block
583   >285C=>D053             	movb *3, 1
584   >285E=>06C1             	swpb 1
585   >2860=>D053             	movb *3, 1
586   >2862=>06C1             	swpb 1			; R1 = start addr in RAM
588   >2864=>D093             	movb *3, 2
589   >2866=>06C2             	swpb 2
590   >2868=>D093             	movb *3, 2
591   >286A=>06C2             	swpb 2			; R2 = end addr in RAM
593   >286C=>0221 >0006       	ai 1, 6
594   >2870=>1002             	jmp cr3
596                           	;	copy data into RAM
597   >2872                   cr2:
598   >2872=>DC53             	movb *3, *1+
599   >2874=>DC53             	movb *3, *1+
600   >2876                   cr3:
601   >2876=>8081             	c 1, 2
602   >2878=>1AFC             	jl cr2
604   >287A=>10E9             	jmp cr0
606   >287C                   cr1:
607   >287C=>0300 >0001           limi 1
608   >2880=>045B             	rt
615   >2882                   dieerr:	bl	@type
      >2882=>06A0 >1B54       
616   >2886=>10FF             	jmp	$
618   >2888=>FC40 >0070 >F786 	consttable
      >288E=>0060 >0808 >1F00 
      >2894=>00C0 >1E03 >0168 
      >289A=>0E10 >F900       
620   >289E                   the_end equ $
