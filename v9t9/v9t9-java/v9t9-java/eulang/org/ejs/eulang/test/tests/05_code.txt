<<< test function pointers
a : code ( => Int);

summer = code (provider:code(=>Int) => Int) {
    s := 0; while (t := provider()) != 0 do s += t;     // also tests that while() does a proper comparison
};

v : Int;
inner = code(=>Int) { if v < 5: v++ else 0  };      // also tests that inc of global works
testOne = code () {
   v = 1;
   summer(inner);
};
===
call testOne
assert R0 == 10
>>>

<<< explicit closures 1

/*
    repeatx = code (x : Int; block : code #block (x:Int=>nil) => nil) {
        for i in x do block(i);
    };

    foo = code() {
        p, s := 10, 0;
        repeatx(10, code #block (p:Int => nil) { s += p;  p--; }; 
         s;
    };    
   //  ★(¸.·'´(¸.·'´:•.•:*¨*☆•☆*¨¨*:•.•:`'·.¸)`'·.¸)★

*/

   Closure = data { vars : Byte^; func : code(=>nil); };
    
    repeatx = code (x : Int; block : Closure^ => nil) {
        for i in x do block.func{code(vars:Byte^;x:Int=>nil)^} (block.vars, i);
    };

    foo = code() {
        p, s := 10, 0;
        
        define MyLocals = data { p : Int; s: Int; };
        myLocals : MyLocals = [ p ];
        closure : data { vars : MyLocals^; func : code(vars : MyLocals^ => nil); } = [ 
                &myLocals, code(vars : MyLocals^ => nil) { vars.s += vars.p;  vars.p--; } 
        ];
        repeatx(10, (&closure){Closure^});
        
        // maybe
        p, s = myLocals.p, myLocals.s;
         s;
    };    
===
call foo
assert R0 == 55
>>>
