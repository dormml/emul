/**
 * 
 */
package v9t9.audio.sound;

import java.util.Arrays;

import ejs.base.settings.ISettingSection;
import ejs.base.sound.IFlushableSoundVoice;

/**
 * Reproduce the sound generated by the cassette recording.
 * 
 * From &lt;http://nouspikel.com/ti99/tms9901.htm#Ti99&gt;
 * 
 * <pre>
 * Pin INT13* / P9 is used to output sound to the cassette, this will be digital sound of course, modulated via an electronic circuit in the console.
 * </pre>
 * And from &lt;http://nouspikel.group.shef.ac.uk//ti99/cassette.htm#Cassette%20tape%20format&gt;:
 * 
 * <pre>
 * Texas Instruments adopted a frequency modulation encoding system to store data on tape. 
 * This is only a convention, and you may come up with another, if you feel like it. Similarly, TI defined the format the data 
 * should have whithin a tape file. Again, this is only a convention.
 * </pre>
 * 
 * (From the above, the modulation is not a convention!)
 * @author ejs
 *
 */
public class CassetteSoundVoice extends ClockedSoundVoice implements IFlushableSoundVoice {

	private static final short[] cassetteChirp = new short[] { 
		0x0000, 0x00b7, 0x008b, 0x006b, 0x0066, 0x00a2, 0x00c6, 0x00d6, 0x00fd, 0x0124, 0x0178,
		0x0214, 0x02cb, 0x0409, 0x0650, 0x0a04, 0x0f25, 0x14e2, 0x1687, 0x0e19, 
		(short) 0xfe33, (short) 0xf17c, (short) 0xef28, (short) 0xf52b, (short) 0xfd48, 
		0x0212, 0x02aa, 0x00cd, (short) 0xff18, (short) 0xfefa, (short) 0xffa8, 0x00b9,
		0x0132, 0x100, 0x00c9, 0x0046, (short) 0xfffc, (short) 0xff7a, (short) 0xff5e, 
		(short) 0xfebc, (short) 0xfd8b, (short) 0xfba9, (short) 0xf8a3,
		(short) 0xf384, (short) 0xecbd, (short) 0xe724, (short) 0xe625, (short) 0xebc5, 
		(short) 0xf5bc, 0x0074, 0x0857, 0x0c75, 0x0d4b, 0x0b73, 0x0848,
		0x0575, 0x037b, 0x028f, 0x025d, 0x022d, 0x01c2, 0x015e,
		0x0142, 0x0120, 0x00e8
	};
	private boolean wasSet;
	private boolean state;
	private boolean origState;
	private int[] deltas = new int[0];
	private int deltaIdx = 0;
	private int baseCycles;
	private boolean motor2;
	private boolean motor1;
	private float prevV;
	private float sign = 1f;
	
	public CassetteSoundVoice(String name) {
		super("Cassette");
	}
	
	@Override
	public void setupVoice() {
		setVolume((byte) (state ? MAX_VOLUME : 0));
		wasSet = true;
	}

	/* (non-Javadoc)
	 * @see org.ejs.emul.core.sound.ISoundVoice#setSoundClock(int)
	 */
	public void setSoundClock(int soundClock) {
		this.soundClock = soundClock;
	}
	
	/* (non-Javadoc)
	 * @see org.ejs.emul.core.sound.ISoundVoice#reset()
	 */
	public void reset() {
		wasSet = false;
		origState = false;
		deltaIdx = 0;
		baseCycles = 0;
		prevV = 0f;
		sign = 1f;
	}
	
	/* (non-Javadoc)
	 * @see v9t9.engine.sound.SoundVoice#isActive()
	 */
	@Override
	public boolean isActive() {
		return super.isActive();
	}
	public synchronized void setState(int curr) {
		boolean newState = curr >= 0;
		curr = absp1(curr);
		
		// always note a change; the speed is what counts
		if (motor1 || motor2) 
		{
			int offs = curr >= baseCycles ? curr - baseCycles : curr;
			
			state = newState;
			appendPos(state ? offs : -offs-1);
		
			baseCycles = curr;
		}
	}

	/**
	 * @param pos
	 * @throws AssertionError
	 */
	protected void appendPos(int pos) throws AssertionError {
		if (deltaIdx > 0 && deltas[deltaIdx - 1] == pos)
			return;
		
		if (deltaIdx >= deltas.length) {
			int newlen = deltas.length * 2;
			if (newlen < 16)
				newlen = 16;
			deltas = Arrays.copyOf(deltas, newlen);
		}
		
		deltas[deltaIdx++] = pos;
	}

	public boolean generate(float[] soundGeneratorWorkBuffer, int from,
			int to) {
		
		//appendPos(state ? totalCount : -totalCount-1);
		return wasSet;
	}

	/* (non-Javadoc)
	 * @see v9t9.base.sound.ITimeAdjustSoundVoice#flushAudio(float[], int, int)
	 */
	@Override
	public synchronized boolean flushAudio(float[] soundGeneratorWorkBuffer, int from,
			int to, int totalCycles) {
		boolean generated = false;
		if (from < to && deltaIdx > 0) {
			
			generated = true;
			int ratio = 128 + balance;
			float sampleL = ((256 - ratio) * 1f) / 256.f;
			float sampleR = (ratio * 1f) / 256.f;
			
			int totalSamps = to - from;
			
			int total = 0;
			for (int i = 0; i < deltaIdx; i++)
				total += absp1(deltas[i]);

			if (total == 0)
				total = 1;

			int firstFrom = from;
			
			int idx = 0;
			int consumed = absp1(deltas[idx]) ;
			int next = from + (int) ((long) consumed * totalSamps / total);
			idx++;
			
			int origFrom = from;
			
			//System.out.println("**" + (next-origFrom));
			boolean on = origState;
			sign = on ? 1f : -1f;
			int diff = next - origFrom;
			while (from < to) {
				float v;
				if (diff != 0) {
					int fullPos = (from - origFrom)  * cassetteChirp.length;
					int aPos = fullPos / diff;
					float c = cassetteChirp[aPos] / (float) 0x1800;
					int aOffs = fullPos % diff;
					v = (prevV * (diff - aOffs) + c * (aOffs)) / diff;
				} else {
					v = prevV;
				}
				prevV = v;
				v *= sign;
				soundGeneratorWorkBuffer[from++] += sampleL * v;
				soundGeneratorWorkBuffer[from++] += sampleR * v;
				
				if (from >= next) {
					if (idx < deltaIdx) {
						boolean nextOn = (deltas[idx] >= 0);
						consumed += absp1(deltas[idx++]);
						next = firstFrom + (int) ((long) consumed * totalSamps / total);
						on = nextOn;
						sign = -sign;
					} else {
						break;
//						on = state;
//						next = to;
					}
					origFrom = from;
					diff = next - origFrom;
					
				}
			}
		}
		
		deltaIdx = 0;
		origState = state;
		baseCycles = totalCycles;
		
		return generated;
	}
	
	/**
	 * @param i
	 * @return
	 */
	private int absp1(int i) {
		return i < 0 ? -(i+1) : i;
	}

	@Override
	public void loadState(ISettingSection settings) {
		if (settings == null) return;
		super.loadState(settings);
		setVolume((byte) (settings.getBoolean("State") ? MAX_VOLUME : 0));
		motor1 = settings.getBoolean("Motor1");
		motor2 = settings.getBoolean("Motor2");
	}
	
	@Override
	public void saveState(ISettingSection settings) {
		super.saveState(settings);
		settings.put("State", Boolean.toString(getVolume() != 0));
		settings.put("Motor1", Boolean.toString(motor1));
		settings.put("Motor2", Boolean.toString(motor2));
	}

	/**
	 * @param b
	 */
	public void setMotor1(int curr, boolean b) {
		motor1 = b;
		baseCycles = curr;
	}

	/**
	 * @param b
	 */
	public void setMotor2(int curr, boolean b) {
		motor2 = b;
		baseCycles = curr;
	}
	
}