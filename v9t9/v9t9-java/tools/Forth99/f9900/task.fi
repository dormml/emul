
( Each task consists of a fresh workspace and RP, SP, UP areas )

| 0 constant		>tlink 
| 1 cells constant	>twp
| 2 cells constant	>tpc
| 3 cells constant	>tst

| 4 cells 
	$20 + 
	(#RP) +  (#SP) +  
	#TIB + (#up) +  		constant #task 

| 4 cells 
	$20 + 
	(#RP) +  (#SP) +  
	#TIB + 			 		constant >tuser 

( Initialize and link task structure )
Code (task)	( xt task -- )
							,LIMI	0 ,
	rTOS *R					,CLR					( link )
	@>			rTMP		,MOV	'tasks ,
	0 $+					,JEQ
	
	rTMP		rTOS *R		,MOV					( link to prev task )
	
0 $:
	rTOS		@>			,MOV	'tasks ,		( set new head task )
	
	rTOS		rR3			,MOV
	
				rR3			,AI		4 cells ,		( new WS )
	rR3			rTOS @>(R)	,MOV	>twp ,			( set new WP )
	rSP *R+		rTOS @>(R)	,MOV	>tpc ,			( set new PC from XT )
	rR2						,STST
	rR2			rTOS @>(R)	,MOV	>tst ,			( set new ST )
			
	rR3			rR2			,MOV
	rR2						,AI		(#rp) ,
	rR2			rR3 @>(R)	,MOV	rRP 2* ,		( set new RP end )
	rR2						,AI		(#sp) ,
	rR2			rR3 @>(R)	,MOV	rSP 2* ,		( set new SP end )
	rR2						,AI		#tib ,
	rR2			rR3 @>(R)	,MOV	rUP 2* ,		( set new UP )
	
	rDOCOL		rR3 @>(R)	,MOV	rDOCOL 2* ,		( copy )
	rDOCON		rR3 @>(R)	,MOV	rDOCON 2* ,		( copy )
	rDOUSER		rR3 @>(R)	,MOV	rDOUSER 2* ,	( copy )
	rDOVAR		rR3 @>(R)	,MOV	rDOVAR 2* ,		( copy )
	rDODOES		rR3 @>(R)	,MOV	rDODOES 2* ,	( copy )


	( copy user data )
	rR3 @>(R)	rR3			,MOV	rUP 2* ,		( R3=target )
	rUP			rTOS		,MOV					( TOS=src )
	rTMP					,LI		(#up) ,
0 $:
	rTOS *R+	rR3 *R+		,MOV
	rTMP					,DECT
	0 $-					,JGT
	
	POP ( other is above )
end-code


| Code rp0
	PUSH
	
	@>			rR2		,MOV	'me ,		
	0 $+				,JEQ				( in a task? )

	rR2			rTOS	,MOV
	rTOS				,AI 	4 cells (#rp) +  ,						( RP )
	
	1 $+				,JMP
	
0 $:
	rTOS				,LI 	(RP0) ,
    		 
1 $:
end-code

| Code sp0
	PUSH
	
	@>			rR2		,MOV	'me ,		
	0 $+				,JEQ				( in a task? )
	
	rR2			rTOS	,MOV
	rTOS				,AI 	4 cells (#rp) + (#sp) + ,				( SP )
	
	1 $+				,JMP
	
0 $:
	rTOS				,LI 	(SP0) ,
    		 
1 $:
end-code

| Code regs-init
	rRP *R		rTOS	,MOV	( save R-entry )

	@>		rR2			,MOV	'me ,		
	0 $+				,JEQ				( in a task? )
	
	rR2			 rSP	,MOV 	
	rSP					,AI 	4 cells (#rp) + (#sp) +  ,				( SP )
	
	rR2			 rUP	,MOV
	rUP					,AI 	4 cells (#rp) + (#sp) +  #tib +  ,  	( UP )
	
	rR2			 rRP	,MOV
	rRP					,AI 	4 cells (#rp) +  ,						( RP )
	
	1 $+				,JMP
	
0 $:
	rSP					,LI 	(SP0) ,
	rUP					,LI 	(UP0) ,
	rRP					,LI 	(RP0) ,
    		 
1 $:
	rRP					,DECT
	rTOS 		rRP *R	,MOV	( restore R-entry )

	@>					,BL		' ((DOERS)) ,	

end-code


( enter task )
Code (enter) ( task -- )
						,LIMI	0 ,
	rTOS	@>			,MOV	'me ,			( set me' )
	POP
	
	@>		@>			,MOV	uptime cell+ ,	'ticked ,	( remember last switch )
	
						,LWPI	RomWS ,
	@>			1		,MOV	'me ,
	1	@>(R)	&13		,MOV	>twp ,
	1	@>(R)	&14		,MOV	>tpc ,
	1	@>(R)	&15		,MOV	>tst ,
	
						,RTWP
end-code

( Enter given task )
: enter ( task -- )
	?dup  if (enter) then
	( NOTREACHED )
;


Code ((save)) ( -- )
	RomWS ,		here #cell + ,		( vector )

						,LIMI	0 ,	
	@>			1		,MOV	'me ,
	0 $+				,JEQ
	&13		1	@>(R)	,MOV	>twp ,
	&14		1	@>(R)	,MOV	>tpc ,
	&15		1	@>(R)	,MOV	>tst ,
0 $:
						,RTWP
end-code

( save task )
Code (save) ( -- )
	@>					,BLWP	' ((save)) ,
end-code

( Yield the current task if time elapsed )
: yield
	ints-check
	'ticked @  uptime cell+ @  - if
		(save)
		robin
	then
;

( Find next task )
Code (robin)  ( -- task )
	PUSH
	@>		rTOS		,MOV	'me ,
	1 $+				,JEQ
	
	rTOS *R	rTOS		,MOV	( link )
	0 $+				,JNE
1 $:
	@>		rTOS		,MOV	'tasks ,
0 $:

end-code

[IFUNDEF] (robin)
: (robin)  ( -- task )
	'me @
	dup if  
		@						( link )
	then
	?dup 0= if
		'tasks @		 		( round robin )
	then 
;
[THEN]

( Invoke next task in round robin )
: robin ( -- )
	(robin)
	enter
;

( Remove dead thread )
Code (die)  ( task -- next )
	( TODO: free memory! )
	
	rR2						,CLR				( previous task )
	@>			rR3			,MOV	'tasks ,	( head )
	
0 $:
	rTOS		rR3			,C					( match? )
	1 $+					,JEQ
	rR3			rR2			,MOV				( save prev )
	rR3 *R		rR3			,MOV			 	( step )
	2 $+					,JEQ				( no matches )
	
1 $:
	rR2			rR2			,MOV				( me==head? )
	3 $+					,JEQ
	
	rTOS *R		rTOS		,MOV				( next task )
	rTOS 		rR2 *R		,MOV				( splice link )
	2 $+					,JMP

3 $:
	rTOS *R		rTOS		,MOV				( next task )
	rTOS		@>			,MOV	'tasks ,	( new head )
	
2 $:
end-code


( End a task and continue to the next )
: bury ( task -- )
	(die)  'me !
	
	( currently we are on a dead thread! )
	
	'me @ ?dup if 
		enter
	else
		(main)
	then
;

( End a task )
: die ( err -- )
	\ TOD: need to propagate or hit unhandled handler TODO	\ throw
	?dup if message then
	
	'me @  bury
;

( Start a task using 'xt' )
: task ( xt -- task )
	here  aligned >r	 		( xt  r: task' )
	#task allot
	
	( xt )  >r
	:noname
	r> postpone literal
	[compile] catch
	[compile] die
	postpone ; 
	 
	r@
	
	(task)					( init, phase 1 )
	
	r>
;

( Start a task using 'xt', discard result )
: run ( xt -- )
	task drop
;


: MS	( ms -- )
	&60 &1000  */		( 1/60s delay )
	?dup if
		s>d uptime 2@  D+			( target )
		begin
			uptime 2@  2over D<
		while
			yield
		repeat
		2drop
	else
		yield
	then
;
