

\ normal heap header:  
\ [ 'alloc ( n heap -- addr ) ( throws ) ] 
\ [ 'free ( addr heap -- ) ( throws ) ] 
\ [ 'init ( heap -- ) ] 
\ [ link ]
\ [ low ] [ high ]
| 12 Constant #heap  
| : >link+  6 + ;  

\

\ dictionary heap header:  
\ [ 'alloc ] [ 'free ] [ 'init ] [ link ]
| 8 Constant #dheap

| : dict-halloc ( n heap -- addr ) ( throws )
	drop
	dup mfree  u>   err-no-memory ?throw
	
	\ the new addr
	here
		
    swap  
    
    ( addr n )  allot
    
	\ and remember last 'here'
	here  over cell+  !
;

| : dict-hfree ( buffer heap -- ) 
	\ see if the dictionary can shrink	
	drop 
	dup  cell+  @  here =  if 
		\ restore DP
		dp !
	else
		drop
	then
;

| : dict-hinit ( heap -- )
	['] dict-halloc over  !
	2+
	['] dict-hfree over !
	2+
	[ lastxt literal ] over !
	2+
	0 swap !
;

\ create dictionary heap
8  RamVar gheap

\ each heap is a pointer to end of block chain;  0 if no heap
\
\ a block chain consists of entries like this:
\
\ allocated block:    [ link to prev block &~ 1 ] [ next 'here' ] [ data .... ]
\ deallocated block:  [ link to prev block |  1 ] [ next 'here' ] [ data .... ]

| 4 Constant #heaphdr  

:: halloc ( bytes heap -- a-addr ) ( throws: err-fault | err-no-memory  )
\ Allocate bytes address units of contiguous data space in the given heap. 
\ The initial content of the allocated space is undefined.
\
\ If the allocation succeeds, a-addr is the aligned starting address of the
\ allocated space.
\ 
\ If the operation fails, an exception is thrown. 

	\ every allocation on 2-byte boundary
	bytes  align 
	
	\ get the space, plus a slot for the link pointer
	#heaphdr +  to bytes
	
	\ do alloc
	bytes  heap dup  @  execute  :> addr

	\ link to previous slot
	heap >link+  dup  @   addr !
	
	\ remember last buffer
	addr  swap  !

	\ leave new addr
	addr  #heaphdr +
;

\ Tell if the given address represents an entry allocated on the heap.
\ It does NOT tell if the address is inside a heap-allocated item.
\
: hheap? ( a-addr heap -- t|f )
	swap
	
	\ point to link addr
	#heaphdr -	 >r
	
	\ walk all allocated items
	( heap ) >link+ @ 
	begin
		r@ over = if
			rdrop drop true exit
		then
		
		\ prev entry
		1 nand  @
		dup 0=
	until
	drop rdrop false
;

: h-dump ( heap -- ) 
	>link+  @
	begin
		dup 
	while
		dup	 		( buffer buffer )
		@  dup  	( buffer link link )
		1 AND  if &70 emit then		\ 'free'
		swap  #heaphdr +  u.
		1 NAND
	repeat
	&69 emit
	drop
;

: hfree ( a-addr heap -- ) ( throws: err-invalid-addr | err-fault )
	:> heap
	
	dup  heap hheap?  0=  err-invalid-addr ?throw
	
	\ point to block head
	#heaphdr -  :> buffer
	
	\ mark block deallocated
	buffer @   1 OR  buffer !  
	
	begin
		\ IFF the current block is deallocated and at the end of the 
		\ heap, free space
		buffer if
			buffer @  1 AND		\ deallocated?
			buffer  heap >link+  @  = 	\ and this is the top?
			AND
		else
			0
		then
	while
		buffer @  1 NAND	( -- link ) 
		
		dup  heap >link+  !		( remove block )

		\ do free
		buffer  heap dup  2+  @  execute
		
		( link ) to buffer  			
	repeat
;

: hinit ( heap -- )
	dup  4 +  @ execute 
;

\ ----------------------------------

: hdump ( )
	gheap 	h-dump
;

: ?alloc ( n -- a-addr ) ( throw )
	gheap  halloc
;

: ?free ( a-addr -- ) ( throw )
	gheap hfree
;

\
\ standard words
\
: allocate ( n -- a-addr ior )
	['] ?alloc  catch
;

: free ( a-addr -- ior )
	['] ?free  catch
;

