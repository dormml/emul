/*
 * (c) Ed Swartz, 2005
 * 
 * Created on Dec 30, 2004
 *
 */
package v9t9.cpu;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

import v9t9.MemoryEntry;

/**	This represents a compiled block of code. */
public class CodeBlock implements v9t9.Memory.Listener {
    /** memory we're handling */
    MemoryEntry	ent;
    /** dimensions */
    short addr, size;
    /** class name */
    String className;
    /** ignore this block in the future? */
    boolean ignore;
    /** generated bytecode */
    byte[] bytecode;
    /** implementation */
    CompiledCode code;
    String baseName;
    private boolean running;
    
    public CodeBlock(MemoryEntry ent, short addr, short size) {
        this.ent = ent;
        this.addr = addr;
        this.size = size;
        
        this.baseName = createBaseIdentifier(ent.name); 
        this.className = this.getClass().getName() + "$" + baseName; 
    }
    
    String createBaseIdentifier(String entName) {
        if (entName == null) {
            return v9t9.Globals.toHex4(addr);
        }
        String copy = new String();
        for (int i = 0; i < entName.length(); i++) {
            char c = entName.charAt(i);
            if (Character.isJavaIdentifierPart(c))
                copy += c;
            else
                copy += '_';
        }
        return copy + v9t9.Globals.toHex4(addr);
    }

    public boolean matches(MemoryEntry ent_) {
        return this.ent == ent_;
    }

    /** Build the bytecode for a block of memory */
    boolean build(Executor exec) {
        if (bytecode == null) {
            if (ignore)
                return false;
            if ((bytecode = Compiler.compile(exec, this)) == null) {
                ignore = true;
                return false;
            }
        }
        if (!load(exec))
            return false;
        return true;
    }

    void clear() {
        code = null;
        bytecode = null;
    }

     boolean run(Executor exec) {
        /* build the code if necessary... */
        if (!build(exec))
            return false;
            
        /* now execute */
        running = true;
        code.nInstructions = 0;
        //int origpc = exec.cpu.getPC();
        boolean ret = false;
        try {
            ret = code.run();
        } catch (AbortedException e) {
            System.err.println("Aborted code execution");
        }
        running = false;
        exec.nInstructions += code.nInstructions;
       // System.out.println("invoked "+code.nInstructions+" at "+v9t9.Globals.toHex4(origpc)+" to "+v9t9.Globals.toHex4(exec.cpu.getPC()));
       
        return ret;
    }


    /**
     * @param exec
     * @return
     */
    private boolean load(Executor exec) {
        if (code != null)
            return true;
            
        if (bytecode == null)
            return false;

        // load and construct an instance of the class
        Class clas = exec.compiler.loader.load(className, bytecode);
        try {
            Constructor cons = clas.getConstructor(new Class[] { Executor.class });
            code = (CompiledCode)cons.newInstance(new Object[] {exec});
            code.dump = exec.dump;
            code.dumpfull = exec.dumpfull;
            return true;
        } catch (InvocationTargetException ex) {
            ex.printStackTrace(System.err);
            System.exit(1);
            return false;
        } catch (NoSuchMethodException ex) {
            ex.printStackTrace(System.err);
            System.exit(1);
            return false;
        } catch (IllegalAccessException ex) {
            ex.printStackTrace(System.err);
            System.exit(1);
            return false;
        } catch (InstantiationException ex) {
            ex.printStackTrace(System.err);
            System.exit(1);
            return false;
        }
    }

    /* (non-Javadoc)
     * @see v9t9.Memory.Listener#notifyMemoryChanged(v9t9.MemoryEntry)
     */
    public void notifyMemoryMapChanged(MemoryEntry entry) {
        /* clear the compiled cache no matter what was changed, for now */
        System.out.println("Memory map changed");
        clear();
        if (running)
            throw new AbortedException(); 
    }
}

